
The **Open Shortest Path First (OSPF)** protocol is a link state protocol that handles routing for IP traffic.

OSPF version 2, which is described in RFC 2328, is an open standard, as are version 1 and 2 of the Routing Information Protocol (RIP), which is also a routing protocol.

## OSPF Overview

OSPF was created in the mid-1980s to overcome many of the deficiencies and scalability problems of RIP in large enterprise networks.

**advantages**
* It will run on most routers, since it is based on an open standard
* It uses the SPF algorithm, developed by Edsger Dijkstra, to provide a loop-free topology
* It provides fast convergence with triggered, incremental updates via link state advertisements (LSAs).
* It is a classless protocol and allows for hierarchical design with Variable Length Subnet Masking (VLSM) and route summarization, thus reducing routing overhead
* It contains a two-layer hierarchy to contain problems within an area and to reduce routing overhead.
* It has an intelligent metric (cost), which is the inverse of the bandwidth of an interface.
* It enables you to control routing update information extensively through summarization and filtering

**disadvantages**
* It requires more memory to hold the adjacency (list of OSPF neighbors), topology (a link state database containing all of the routers and their routes/links), and routing tables.
* It requires extra CPU processing to run the SPF algorithm, which is especially true when you first run on your routers and they are initially building the adjacency and topology tables.
* For large networks, it requires careful design to break up the network into an appropriate hierarchical design by separating routers into different areas.
* It is more complex to configure and more difficult to troubleshoot than distance vector protocols.

> Typically, when you have more than 50 routers, Cisco recommends that you use a more advanced routing protocol such as Open Shortest Path First (OSPF) or Enhanced Interior Gateway Routing Protocol (EIGRP). In a mixed-vendor environment, there is basically one choice between these two: OSPF.

### Hierarchical Design: Areas

To provide scalability for very large networks, OSPF supports two important concepts: autonomous systems and areas.

*Autonomous systems (ASs)* Within an AS, areas are used to provide hierarchical routing.

An area is a group of contiguous networks.

Basically, areas are used to control when and how much routing information is shared across your network. In flat network designs, such as those that use IP RIP, if a change occurs on one router (perhaps a flapping route problems), it affects every router in the entire network. With a correctly designed hierarchical network, these changes can be contains within a single area.

> OSPF supports a two-layer hierarchy: the backbone (area 0 or 0.0.0.0) and areas connected to the backbone.

OSPF implements a two-layer hierarchy: the backbone and areas off the backbone

![[Pasted image 20250826005158.png]]

This network includes a backbone and three areas connected to the backbone.
Each area is given a unique number that is 32 bits in length. The area number can be represented by a single decimal number, such as 1, or in a dotted-decimal format, such as 0.0.0.1

Area 0 is a special area and represents the top-level hierarchy of the OSPF network, commonly called the **backbone**.
Through a correct IP addressing design, you should be able to summarize routing information between areas. By summarizing your routing information, perhaps one summarized route for each area, you are reducing the amount of information that routers need to know about. For instance, each area is assigned a separate Class B network number. Through summarization on the border routers between areas, other areas would not need to see all the Class B subnets only the summarized network numbers for each respective area (the Class B network numbers themselves)

> The backbone (area 0) is OSPF is required and non-0 areas (such as areas 1, 2, 3, and so on) must be connected to the backbone.
> The preferred connection is a physical connection; however, OSPF supports a feature called virtual links that enables an area to be logically connected to the backbone.

Area 2, for instance, doesn't need to see all of the subnets of Area 1's 172.18.0.0 network number, since only two paths exist out of Area 2 to the backbone.
Area 2 however, needs to see all of its internal subnets to create optimized routing tables to reach its own internal networks within Area 2.

Therefore, in correctly designed OSPF network, each area should contain specific routes only for its own areas and summarized routes to reach other areas.
By performing this summarization, the routers have a smaller topology database (they know only about links in their own area and the summarized routes) and their routing tables are smaller (they know only about their own area's routes and the summarized routes). Through a correct hierarchical design, you can scale OSPF to very large sizes.

### Metric Structure

Unlike RIP, which uses hop count as a metric, OSPF uses cost. Cost is actually the inverse of the bandwidth of a link: the faster the speed of the connection, the lower the cost.
The most preferred path is the one with the lowest accumulated cost value. By using cost as a metric, OSPF will choose more intelligent paths than RIP.

Remember that on synchronous serial links, no matter what the clock rate of the physical link is, the bandwidth always defaults to 1544 Kbps. You will want to code this correctly with the **`bandwidth`** interface subconfiguration mode command. This is important if you have multiple synchronous serial paths to a destination, especially if they have different clock rates.
OSPF supports load balancing of up to 16 equal-cost paths to a single destination; however, only 4 equal cost paths are used by default.
Remember that if you don't configure the bandwidth metric correctly on your serial interfaces, your router may accidentally include paths with different clock rates, which can cause load-balancing issues.

For example, if you have one serial connection clocked at 1544 Kbps and anther clocked at 256 Kbps and you don't change the bandwidth values, OSPF will see both connections as 1544 Kbps and attempt to use 1544 Kbps when reaching a single destination across these links. This is because the default bandwidth on a serial link is 1544, no matter what the clock speed of the interface is.
This can create throughput problems when the router is performing load balancing half of the connections will go down one link and half down the other, creating congestion problems for the 256-Kbps connection. Therefore, remember that you should change bandwidth of the interface with the `bandwidth` command.

---

## OSPF Operation

each link state protocol, such as OSPF and Intermediate System-Intermediate System (IS-IS), has its own unique features and characteristics.

### Router Identities

Each router in an OSPF network needs a unique ID this must be unique not just within an area, but within the entire OSPF network.
The ID is used to provide a unique identity to the OSPF router. The ID is included in any OSPF messages the router generates the other OSPF messages the router generates that other OSPF routers will process.

The router ID is chosen according to one of the following criteria:
* The highest IP address on the router's active loopback interfaces is used (this is a logical interface on a router).
* If no loopback interface exists with an IP address, the highest IP address on its active interfaces is used when the router boots up.

>  Loopbacks typically have a host mask (/32). Cisco supports other masks for loopback interfaces, but many vendors restrict you to a /32 mask.

The router ID is used by the router to announce itself to the other OSPF routers in the network. This ID must be unique. If no loopback interfaces are configured, the router will use the highest IP address from one of its active physical interfaces.
Optionally, you can manually define the router ID, always ensuring how it will be defined no matter what interfaces exist on the router.

> how a router acquires its router ID for OSPF: the active loopback with the highest IP address or the active physical interface with the highest IP address.

If no active interface exists, the OSPF process will not start, and therefore you will not have any OSPF routes in your routing table. It is highly recommended, therefore, that you use a loopback interface, because it is always up and thus the router can obtain a router ID and start OSPF.

### Finding Neighbors

Whereas RIP accepts routing updates from just about any other RIP router (unless RIPv2 with authentication is configured), OSPF has some rules concerning if and how routing information should be shared.
First, before a router will accept any routing information from another OSPF router, the routers must build an *adjacency* between them, on their connected interfaces. When this adjacency is built, the two routers (on the connected interfaces) are called *neighbors*, indicating a special relationship between the two.

An OSPF router learns about its OSPF neighbors and builds its adjacency and topology tables by sharing link state advertisements (LSAs), which exist in different types. When learning about the neighbors to which a router is connected, as well as keeping tabs on known neighbors, OSPF routers will generate LSA hello messages every 10 seconds.
When a neighbor is discovered and an adjacency is formed with the neighbor, a router expects to see hello messages from the neighbor. If a neighbor's hello is not seen within the dead interval time, which defaults to 40 seconds, the neighbor is declared dead. When this occurs, the router will advertise this information, via an LSA message, to other neighboring OSPF routers.

In order for two routers to become neighbors, the following items must match on each other:
* The area number
* The hello and dead interval timers on their connected interfaces
* The OSPF password (optional), if is configured
* The area stub flag, indicating the type of area (a stub is used to contain OSPF messages and routing information)
* Maximum transmission unit (MTU) sizes on the connected interface

If these items do not match, the routers will not form an adjacency and will ignore each other's routing information.

> remember that the hello process is used to discover and maintain a neighbor relationship with other OSPF routers.
> In order to form a neighbor relationship, two OSPF routers on the same segment must be in the same area, must have matching hello and dead interval timers, must have the same password if authentication is configured, must be of the same type (stub, not-so-stubby, or no stub), and must have the same MTU size configured on their interfaces.

Let's assume that you turned on all your routers simultaneously on a segment. In this case, the OSPF routers will go through three states, called the *exchange* process, in determining whether they will become neighbors:
1. **Down state**
	* The routers have not exchanged any OSPF information with any other router.
2. **Init state**
	* A destination router receives a new router's hello and adds it to its neighbor list (assuming that values in the preceding bullet points match). Not that communication is only unidirectional at this point
3. **Two-way state**
	* The new router receives a unidirectional reply (from the destination router) to its initial hello packet and adds the destination router to its neighbor database.

Once the routers have entered two-way state, they are considered neighbors. At this point, an election process takes place to elect the designated router (DR) and the backup designated router (BDR) on the segment.

### Designated and Backup Designated Routers

An OSPF router will not form adjacencies to just any router. Instead, a client/server design is implemented in OSPF on each broadcast segment.
For each multi-access broadcast segment, such as Ethernet, there is a DR and BDR as well as other OSPF routers, called *DROTHERs*. As an example, if you have ten VLANs in your switched area, you'll have ten DRs and ten BDRs. The one exception of a segment not having these two routers is on a WAN point-to-point link.

When an OSPF router comes up, it forms adjacencies with the DR and BDR on each multi-access segment to which it is connected; if it is connected to three segments, it will form three sets of adjacencies. Any exchange of routing information is between these DR/BDR routers and the other OSPF neighbors on a segment (and vice versa).
An OSPF router talks to a DR using the IP multicast address 224.0.0.6. The DR and the BDR talk to all OSPF routers using the 224.0.0.5 multicast IP address.

> OSPF routers use link state advertisement (LSAs) to communicate with each other. One type of LSA is a hello, which is used to form neighbor relationships and as a keep-alive function.
> Hellos are generated every 10 seconds. When sharing link information (directly connected routes), links are sent to the DR (224.0.0.6) and the DR disseminates link information to everyone else (224.0.0.5) on the segment.
> On point-to-point links, since no DR/BDR is used, all OSPF packets are addressed to 224.0.0.5.

The OSPF router with the highest priority becomes the DR for the segment. If there is a tie, the router with the highest router ID (not IP address on the segment) will become the DR.
By default, all routers have a priority of 1 (priorities can range from 0 to 255 it's an 8-bit value). If the DR fails, the BDR is prompted to DR and another router is elected as the BDR.

**election process**
![[Pasted image 20250828205239.png]]

Where router E is elected as the DR and router B is elected as the BDR.
in this example, each router has the default priority, 1; therefore, router E is chosen as the DR since it has the highest router ID, and router B is chosen as the BDR because it has the second-highest router ID. if a router has a priority of 0, it will never become the DR or BDR.

The DR and BDR priority is changed on an interface-by-interface basis and is configured with the **`ip ospf priority`** command within the interface subconfiguration mode. Once the DR and BDR are elected, they maintain these roles even if other routers form adjacencies with them that have higher priorities: an election or re-election will occur only if no DR or BDR exists.

> The router with the highest priority (or highest router ID) becomes the DR (not the highest IP address on the link)
> This process is true for multi-access segments, but not point-to-point links, where DRs/BDRs are not used.
> Setting the priority to 0 means the router will never become the DR or BDR.

### Sharing Routing Information

After electing the DR/BDR pair, the routers continue to generate hellos to maintain communication. This is considered an *exstart* state, in which the OSPF routers are ready to share link state information.

The process the routers go through is called an *exchange protocol*

**exchange protocol**

1. **Exstart state**
	* The DR and BDR from adjacencies with the other OSPF routers on the segment. Then within each adjacency, the router with the highest router ID becomes the master and starts the exchange process first (shares its link state information).
	* the DR is not necessarily the master for the exchange process.
	* The remaining router in the adjacency will be the slave.
2. **Exchange state**
	* The master starts sharing link state information first with the slave. These are called *database description packets (DBDs, sometimes DDPs)*.
	* The DBDs contain the link state type, the ID of the advertising router, the cost of the advertised link, and the sequence number of the link.
	* The slave responds back with an LSACK (an acknowledgement to the DBD from the master). The slave then compares the DBD's information with it's own.
3. **Loading state**
	* If the master has more up-to-date information than the slave, the slave will respond to the master's original DBD with a link state request (LSR).
	* The master will then send a link state update (LSU) with the detailed information of the links to the slave. The slave will then incorporate this into its local link state database.
	* Again the slave will generate an LSACK to the master to acknowledge the fact that it received the LSU.
	* If a slave has more up-to-date information, it will repeat the exchange and loading state.
4. **Full state**
	* Once the master and the slave are synchronized, they are considered to be in a full state.

To summarize these four steps, OSPF routers share a type of LSA message in order to disclose information about available routers; basically, an LSA update message contains a link and a state, as well as other information.
A *link* is the router interface on which the update was generated (a connected route).
The *state* is a description of this interface, including the IP address configured on it and the relationship this router has with its neighboring router.
However, OSPF routers will not share this information with just any OSPF router it is shared between the OSPF routers and the DR/BDR on a segment.

OSPF uses incremental updates after entering a full state. This means that whenever a change takes place, only the change is shared with the DR, which will then share this information with other routers on the segment.

![[Pasted image 20250828221314.png]]

In this example, Network Z, connected to router C, goes down. Router C sends a multicast to the DR and the BDR (with a destination multicast address of 224.0.0.6), telling them about this change.
Once the DR and the BDR incorporate the change internally, the DR then tells the other routers on the segment (via a multicast message sent to 224.0.0.5, which is all OSPF routers) about the change concerning Network Z. Any router receiving the update will then share this update to the DRs of other segments to which they are connected.

Note that the communications between OSPF routers is connection-oriented, even though multicasts are used.
For example, if a router tells a DR about a change, the DR acknowledges this new piece of information with the source of the communication. Likewise, when the DR shares this information with the other routers on the segment, the DR expects acknowledgements from each of these neighbors.
Remember that when an OSPF router exchanges updates with another, the process requires an acknowledgement: this ensures that a router or routers have received the update.

The exception to the incremental update process is that the DR floods its database every 30 minutes to ensure that all of the routers on the segment have the most up-to-date link state information. It does this with a destination address of 224.0.0.5 (all OSPF routers on the segment).

Each LSA message has a type associated with it. This book focuses on the following three, which are all found within a single area:

* **LSA Type 1 (Router LSA)**
	* These are generated by every router for each link that belongs to an area.
	* They are flooded only inside of the area to which they belong. The Link ID of this LSA is the Router ID of the router that generated it.
* **LSA Type 2 (Network LSA)**
	* These are generated by the DR and describe the routers that are connected to that segment.
	* They are sent inside the area for which the network segment belongs.
	* The Link ID is the interface IP address of the designated router, which describes that particular segment.
* **LSA Type 5 (External LSA)**
	* Autonomous system external LSAs are generated by autonomous system boundary routers (ASBRs) and contain routes to networks that are external to the current AS.
	* The Link ID is a network number advertised in the LSA.

In summary, the first two LSA types represent links within the local area and the last LSA type represents links from a different autonomous system.
These LSA types are placed in a local database on the routing device.

When building the routing table using link state information, an OSPF router can keep up to 16 paths to a single destination in its routing table.
They only restriction is that the paths must have the same accumulated cost metric.

> a two-way state indicates that two OSPF routers are neighbors. A full state indicates the completion of sharing of links between routers. In order to build and maintain the OSPF database, hello (establish neighbors) and LSA (routing information) messages are used.

---

## OSPF Configuration

Configuring OSPF is slightly different from configuring routing protocols such as RIP. When configuring OSPF, use the following syntax:

```
Router(config)# router ospf process_ID
Rotuer(config-rotuer)# network IP_ADDR WILDCARD_MASK area AREA_#
```

The **`process_ID`** is locally significant and is used to differentiate between OSPF process running on the same router. It can be any number from 1 to 65535.
Your router might be a boundary router between two OSPF autonomous systems, and to differentiate them on your router, you'll give them unique process IDs. Note that these ID numbers do not need to match between different routers and they have nothing to do with autonomous system numbers. You would need to use different process numbers if your routing device was connected to two different OSPF networks: you would need a different, locally unique process number for each OSPF network.
Each OSPF process will have its own OSPF database identified by the process ID.

> when configuring the OSPF routing process, you must specify a process ID (identifier).
> This uniquely identifies an instance of the OSPF database on the router and is only locally significant: it doesn't have to match on each router in the AS it can be any number from 1 to 65535.

When configuring OSPF, you specify what interfaces go into an OSPF area by using the **`network`** command. Different process ID numbers are used to identify different OSPF networks a routing device is connected to. Therefore, for example, the **`network 0.0.0.0 255.255.255.255 area 0`** command will include all interfaces in area 0. Each OSPF process will have its own OSPF database identified by the process ID.

As you can see in the command for configuring OSPF, the syntax of this command is different from that of RIP's configuration, where you specify only a class address. OSPF is classless. With this configuration command, you can be very specific about what interface belongs to a particular area.
The syntax of this command lists an IP address or network number, followed by a *wildcard mask*, which is different from a subnet mask. A wildcard mask tells the router the interesting component of the address in other words, what part of the address is should match on. This mask is also used with access lists.

A wildcard mask is 32 bits in length. A 0 in bit position means there must be a match, and a 1 in a bit position means the router doesn't care.
Actually, a wildcard mask is an *inverted* subnet mask, with the 1s and 0s switched.
Using a wildcard mask, you can be very specific about which interfaces belong to which areas. The last part of the configuration command tells the router to which area these addresses on the router belong.

> Unlike in RIP, the `network` statement enables you to specify an IP address and a wildcard mask, which is an inverted subnet mask.
> You must also specify to which area this address or addresses will belong: `network network_# wildcard_mask area area_#`. A trick of converting a subnet mask to a wildcard mask is to subtract the subnet mask from 255.255.255.255; the result will be the corresponding wildcard mask.

![[Pasted image 20250829224410.png]]

```
Rotuer(config)# router ospf 1
Router(config-router)# network 10.1.1.1 0.0.0.0 area 0
Router(config-router)# network 10.1.2.1 0.0.0.0 area 0
Router(config-router)# network 172.16.1.1 0.0.0.0 area 0
Router(config-router)# network 172.16.2.1 0.0.0.0 area 0
```

In this example, the interfaces with address of 10.1.1.1, 10.1.2.1, 172.16.1.1 and 172.16.2.1 all are associated with area 0. A wildcard mask of 0.0.0.0 says that there must be an exact match against the address on the router's interface in order to place it in area 0.

another example that accomplishes the same thing:

```
Rotuer(config)# router ospf 1
Router(config-router)# network 10.0.0.0 0.255.255.255 area 0
Router(config-rotuer)# network 172.16.0.0 0.0.255.255 area 0
```

In this example, interfaces beginning with an address of 10 or 172.16 are to be included in area 0.

Or, if all interfaces on your router belonged to the same area, you could use this configuration:

```
Router(config)# router ospf 1
Router(config-router)# network 0.0.0.0 255.255.255.255 area 0
```

In this example, all interfaces are placed in area 0.

### Loopback Interfaces

A *loopback interface* is logical, virtual interface on a router.

By default, the router doesn't have any loopback interfaces, but they can be easily created. All IOS platforms support loopback interfaces, and you can create as many of these interfaces as you need. These interfaces are treated as physical interfaces on a router: you can assign addressing information to them, include their network numbers in routing updates, and even terminate IP connections on them, such as telnet and SSH.

> A loopback interface is a logical interface that always remains up. Use the `interface loopback` command to create it.

reasons want to create a loopback interface:

* To assign router ID to an OSPF router
* To use for testing purposes, since this interface is always up
* To terminate special connections, such as GRE tunnels or IPsec connections, since this interface is always up

To create a loopback interface:
```
Router(config)# interface loopback port_#
Router(config-if)# ip address IP_ADDR SUBNET_MASK
```

### Default Router Propagation

On your perimeter OSPF router connected to the ISP, you typically have a default route pointing to the ISP. To take this route and redistribute it into your OSPF process, basically making your perimeter router an ASBR, use the following configuration:
```
Rotuer(config)# ip route 0.0.0.0 0.0.0.0 ISP_INTERFACE_OR_IP_ADDR
Router(config)# router ospf PROCESS_ID
Router(config-router)# default-information originate
```

> Make sure your default route doesn't point your internal network, but your ISP's network; otherwise, you'll be creating a routing loop

### OSPF Metric Values

You can affect the cost metric that OSPF uses in picking the best-cost routes for the routing table in two ways.

First, remember that the cost metric is the inverse of the accumulated bandwidth values of router's interfaces. The default measurement that Cisco uses in calculating the cost metric is: cost = 10^8 / (interface bandwidth); 10^8 represents 100 Mbps.

You can also affect the value of the cost by changing the 10^8 value with the `auto-cost reference-bandwidth` command.

**default costs for different interface types**

| Cost Value | Interface type                     |
| ---------- | ---------------------------------- |
| 1785       | 56-Kbps serial line                |
| 1652       | 64-Kbps serial line                |
| 64         | T1                                 |
| 10         | Ethernet (10Mbps)                  |
| 1          | Fast Ethernet (100Mbps)            |
| 1          | Gigabit Ethernet (1000Mbps/1 Gbps) |
| 1          | 10 Gigabit Ethernet (10 Gbps)      |
| 1          | 100 Gigabit Ethernet (100 Gbps)    |

To change the cost of an interface manually, use the following configuration:
```
Router(config)# interface type [slot_#/]port_#
Router(config-if)# ip ospf cost COST_VALUE
```

Notice that the cost is assigned within an interface. This value can range from 1 to 65535.
Note that each vendor might use a different calculation to come up with a cost value.

> It is very important that the cost for a link match for every router on a given segment. Mismatched cost values on a segment can cause routers to run the SPF algorithm continually, greatly affecting the routers' performance.

Normally, you won't be changing the default cost values on an interface. However, since OSPF uses the inverse of bandwidth as a metric, and serial interfaces default to a bandwidth of 1544 Kbps, you will definitely want to match the bandwidth metric on the serial interface to its real clock rate.

To configure the bandwidth on your router's interfaces, use the following command:
```
Router(config)# interface type [slot_#/]port_#
Router(config-if)# bandwidth speed_in_Kbps
```

As an example, if the clock rate were 64,000, you would use the `bandwidth 64` command to configure the bandwidth correctly.

Note that the speed is in Kbps for the `bandwidth` command. For example, assume you configured the bandwidth with this: `bandwidth 64000`. the router would assume the bandwidth metric of the interface is 64 Mbps, not Kbps.

By default, the router will place up to 8 equal-cost OSPF paths to a destination in the router's routing table. This can be increased up to 16 equal-cost paths with the following configuration:
```
Router(config)# router ospf PROCESS_ID
Router(config-router)# maximum-paths #_of_max_paths 
```

> remember that the `bandwidth` command should be used on synchronouse serial interfaces to match the bandwidth metric to the clocked rate of the interface.
> Synchronous serial interfaces, no matter what they are clocked at, default to a bandwidth metric of 1544 Kbps. The default number of maximum paths is eight.

### OSPF Authentication

OSPF supports authentication of neighbors and routing updates. This is used to prevent rogue OSPF routers from injecting bad or misleading routing information into your topological databases.

Authentication can be done with a clear-text password or a digital signature created with the MD5 algorithm.
Of the two, the latter is the more secure: clear-text passwords can be seen by an eavesdropper between two OSPF neighbors. When using MD5, to prevent against a replay attack where the same information is always sent to a neighbor, such as a hello message, a non-decreasing sequence number is included in the message to ensure that the message and the signature are unique.

The authentication information is placed in every LSA and validate before being accepted by an OSPF router. To become neighbors, the keying information (clear-text password or key for the MD5 algorithm) must match on the two peers.

> Remember that if the password/key values on two OSPF neighbors don't match, an adjacency will not occur.
> Of the two methods, using MD5 is definitely much more secure than a clear-text password.

Configuring authentication is a two-step process: specifying the password/key to use, and enabling authentication.
Then configuration of the key is done on an interface-by-interface basis, which means that every neighboring OSPF router off of the same interface must use the password/key.

**configure the password/key value**
```
Router(config)# interface type [slot_#/]port_#
Router(config-if)# ip ospf authentication-key PASSWORD
```

Starting in Cisco IOS 12.4, any password greater than eight characters is truncated to eight characters by the router. The password is stored in clear text in the router's configuration. To encrypt it, use the `service password-encryption` command.

Next, you must specify whether the password is sent in clear text or used by MD5 to create a digital signature. This can be done on the interface or on an area-by-area basis.
To specify the interface method, use this configuration:
```
Router(config)# interface type [slot_#/]port_#
Router(config-if)# ip ospf authentication [messge-digest]
```

if you omit the **`message-digest`** parameter, the key is sent as a clear-text password.

Your other option is to configure the use of the password/key for an area with which the router is associated:
```
Router(config)# router ospf PROCESS_ID
Router(config-router)# area AREA_# authentication [message-digest]
```

Again, if you omit the **`message-digest`** parameter, the key is sent as a clear-text password.

Of the two approaches, the latter is the older method: the interface method (former method) was added in IOS 12.0 and is the preferred approach.

---

## OSPF Troubleshooting

Once you have configured OSPF, the following commands are available to view and troubleshoot your OSPF configuration and operation:

* show ip protocols
* show ip route
* show ip ospf
* show ip ospf database
* show ip ospf interface
* show ip ospf neighbor
* debug ip ospf adj
* debug ip ospf events
* debug ip ospf packet

### The show ip protocols command

The `show ip protocols` command displays all of the IP routing protocols that you have configured and that are running on your router.

```
R1#show ip protocols
Routing Protocol is "ospf 1"
  Outgoing update filter list for all interfaces is not set
  Incoming update filter list for all interfaces is not set
  Router ID 0.0.0.0
  Number of areas in this router is 0. 0 normal 0 stub 0 nssa
  Maximum path: 4
  Routing for Networks:
    0.0.0.0 255.255.255.255 area 0
 Reference bandwidth unit is 100 mbps
  Routing Information Sources:
    Gateway         Distance      Last Update
    192.168.1.100        110      00:00:24
    192.168.100.1        110      00:00:24
  Distance: (default is 110)
```

### The show ip route command

```
R1#show ip route
Codes: C - connected, S - static, R - RIP, M - mobile, B - BGP
       D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area
       N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2
       E1 - OSPF external type 1, E2 - OSPF external type 2
       i - IS-IS, su - IS-IS summary, L1 - IS-IS level-1, L2 - IS-IS level-2
       ia - IS-IS inter area, * - candidate default, U - per-user static route
       o - ODR, P - periodic downloaded static route

Gateway of last resort is not set

O    10.0.1.0 [110/65] via 192.168.1.100, 00:04:18, Serial0
C    192.168.1.0/24 is directly connected, FastEthernet1/0
```

### The show ip ospf command

```
R1#show ip ospf
 Routing Process "ospf 1" with ID 192.168.1.100
 Start time: 00:02:41.184, Time elapsed: 00:05:55.960
 Supports only single TOS(TOS0) routes
 Supports opaque LSA
 Supports Link-local Signaling (LLS)
 Supports area transit capability
 Router is not originating router-LSAs with maximum metric
 Initial SPF schedule delay 5000 msecs
 Minimum hold time between two consecutive SPFs 10000 msecs
 Maximum wait time between two consecutive SPFs 10000 msecs
 Incremental-SPF disabled
 Minimum LSA interval 5 secs
 Minimum LSA arrival 1000 msecs
 LSA group pacing timer 240 secs
 Interface flood pacing timer 33 msecs
 Retransmission pacing timer 66 msecs
 Number of external LSA 0. Checksum Sum 0x000000
 Number of opaque AS LSA 0. Checksum Sum 0x000000
 Number of DCbitless external and opaque AS LSA 0
 Number of DoNotAge external and opaque AS LSA 0
 Number of areas in this router is 1. 1 normal 0 stub 0 nssa
 Number of areas transit capable is 0
 External flood list length 0
 IETF NSF helper support enabled
 Cisco NSF helper support enabled
    Area BACKBONE(0) (Inactive)
        Number of interfaces in this area is 1
        Area has no authentication
        SPF algorithm last executed 00:05:45.244 ago
        SPF algorithm executed 1 times
        Area ranges are
        Number of LSA 1. Checksum Sum 0x0078B1
        Number of opaque link LSA 0. Checksum Sum 0x000000
        Number of DCbitless LSA 0
        Number of indication LSA 0
        Number of DoNotAge LSA 0
        Flood list length 0
```

### The show ip ospf database command

```
R1#show ip ospf database

            OSPF Router with ID (192.168.1.100) (Process ID 1)

                Router Link States (Area 0)

Link ID         ADV Router      Age         Seq#       Checksum Link count
192.168.1.100   192.168.1.100   387         0x80000001 0x0078B1 1
R1#
```

### The show ip ospf interface command

```
R1#show ip ospf interface
FastEthernet1/0 is up, line protocol is up
  Internet Address 192.168.1.100/24, Area 0
  Process ID 1, Router ID 192.168.1.100, Network Type BROADCAST, Cost: 1
  Transmit Delay is 1 sec, State DR, Priority 1
  Designated Router (ID) 192.168.1.100, Interface address 192.168.1.100
  No backup designated router on this network
  Timer intervals configured, Hello 10, Dead 40, Wait 40, Retransmit 5
    oob-resync timeout 40
    Hello due in 00:00:00
  Supports Link-local Signaling (LLS)
  Cisco NSF helper support enabled
  IETF NSF helper support enabled
  Index 1/1, flood queue length 0
  Next 0x0(0)/0x0(0)
  Last flood scan length is 0, maximum is 0
  Last flood scan time is 0 msec, maximum is 0 msec
  Neighbor Count is 0, Adjacent neighbor count is 0
  Suppress hello for 0 neighbor(s)
```

### the show ip ospf neighbor command

### The debug ip ospf adj command

### The debug ip ospf events command

### The debug ip ospf packet command

### Exercise 12-1: Configuring OSPF

---

## Chapter Review

---

## Quick Review

### Questions