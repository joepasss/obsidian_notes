Most larger networks implement redundancy to protect data in case of failures; redundancy can involve multiple wide area network (WAN) connections, multiple paths in your layer 3 network, and/or multiple paths in your layer 2 network.

## VLAN Trunking Protocol

The VLAN Trunking Protocol (VTP) is a proprietary Cisco protocol used to share virtual local area network (VLAN) configuration information between Cisco switches on trunk connections.

VTP enables switches to share and synchronize their VLAN information, which ensures that your network has a consistent VLAN configuration

Assume, for instance, that your network has two switches, and you need to add a new VLAN. You could easily accomplish this by adding the VLAN manually on both switches. However, this process becomes more difficult and tedious if you have 30 switches to deal with. In this situation, you could make a mistake in configuring the new VLAN on one of the switches, such as giving it the wrong VLAN identifier or you might forget to add the new VLAN to one of the 30 switches. VTP can take care of these issues. With VTP you can add the VLAN on one switch and have this switch propagate the new VLAN, via VTP messages, to all of the other switches in your layer 2 network, causing them to add the new VLAN also.

This is also true if you modify a VLAN's configuration or delete a VLAN VTP can verify that your VLAN configuration is consistent across all of your switches. VTP can even perform consistency checks with your VLANs to make sure that all the VLANs are configured identically. Components of a VLAN can include a VLAN number, name, and type.
So, for example, if you have a VLAN number of 1 and a name of "admin" on the switch, but the name "administrator" is used on a second switch for the same VLAN 1, VTP checks for and fixes the configuration mismatches.

VTP messages will propagate only across *trunk* connections, so you will need to set up trunking between your switches in order to  share VLAN information via VTP. VTP messages are propagated as layer 2 multicast frames by layer 2 devices. Therefore, if a router separates two of your switches, the router will not forward the VTP messages from one of its interfaces to another because it is a layer 3 device.

For VTP to function correctly, you must associate your switch with a VTP domain. A domain is a group of switches that have the same VLAN information applied to them. Basically, a VTP domain is similar to an autonomous system, which is used by some routing protocols.
A switch can belong only to a single VTP domain. VTP domains are given names, and when switches generate VTP messages, they include the VTP domain name in their messages. When a VTP message is received by a switch, the VTP message is only processed if the VTP domain in the message is the same as the VTP domain name configured on the switch. In other words, a switch in one VTP domain will ignore VTP messages from switches in other VTP domains.

### VTP Modes

When you are setting up VTP, you can choose from three different modes for your switch's configuration
* Client
* Server
* Transparent

| DESC                                | Server | Client | Transparent |
| ----------------------------------- | ------ | ------ | ----------- |
| Can add, modify, and delete VLANs   | Y      | N      | Y           |
| Can generate VTP messages           | Y      | N      | N           |
| Can propagate VTP messages          | Y      | Y      | Y           |
| Can accept changes in a VTP message | Y      | Y      | N           |
| Default VTP mode                    | Y      | N      | N           |
| Saves VLANs to NVRAM                | Y      | N      | Y           |

A switch configured in either VTP server or transparent mode can add, modify, and delete VLANs. The main difference between these two modes is that the configuration changes mode to a transparent switch affect only *that* switch and no other switch in the network. A VTP server switch, however, will make the change and then propagate a VTP message concerning the change to all of its trunk ports.
If a server switch receives a VTP message, it will incorporate the update and forward the message out its remaining trunk ports, but it will not incorporate the changes in the VTP message in its local VLAN configuration. In this sense, transparent switches are like little islands, where changes on a transparent switch affect no one else but the transparent switch itself, and changes to other switches do not affect transparent switches.

A VTP client switch cannot make changes to its VLAN configuration itself it requires a server switch to tell it about the VLAN changes. When a client switch receives a VTP message from a server switch, it incorporates the changes and then floods the VTP message out its remaining trunk ports

Normally, you would set up one switch in server mode and all other switches in client mode. Then you would control who could make changes on the server switch. However, you should keep in mind that if you make a VLAN configuration mistake on the server switch, this mistake is *automatically propagated* to all the client switches in your network. Imagine the outcome if you accidentally deleted a VLAN on your server switch, and this VLAN had 500 devices in it. If this occurred, all the switches would remove the VLAN from their configurations.

Given this and similar problems, some administrators don't like to use VTP server and client modes; they prefer to configure all of their switches in transparent mode. The problem with transparent mode, however, is that it isn't very scaleable; if you need to add a VLAN manually to each individual switch, which is a time-consuming process. Of course, the advantage of this approach is that if you make a mistake on a transparent switch, the problem is *not propagated* to other switches: it's localized.

You could also set up all of your switches in server mode, which is the default setting for VTP. You could even mix and match these options set up a couple of server switches, and have the remaining switches as clients, or set your switches initially as servers and clients, add all your VLANs on the server switch, allow the clients to acquire this information, and then change all the switches to transparent mode. This process allows you to populate your switches' configurations easily with a consistent VLAN configuration during the setup process.

> if you don't specify the VTP mode for your switch, it will default to *server*.

### VTP Messages

If you use a client/server configuration for VTP, these switches can generate three types of VTP messages:

* Advertisement request
* Subset advertisement
* Summary advertisement

* **advertisement request**
	* VTP message a client generates to acquire VLAN information, to which a server will respond. When the server responds a client's request, it generates a *subset advertisement*
* **subset advertisement**
	* response from server to *advertisement request* from client
	* contains detailed VLAN configuration information
		* VLAN numbers
		* names
		* types
		* and others ...
	* The client use this message to configure itself appropriately.
* **Summary advertisement**
	* generated by a switch in VTP server mode.
	* are generated every 5 minutes (300 seconds) by default, or when a configuration change takes place on the server switch.
	* contains only summarized VLAN information.

When a server switch generates a VTP advertisement, it can include the following information:

* The number and name of the VLAN
* The maximum transmission unit (MTU) size used by the VLAN
* the frame format used by the VLAN
* The security Association identifier (SAID) value for the VLAN (needed if it is an 802.10 VLAN, which is implemented in networks using Fiber Distributed Data Interface [FDDI])
* The configuration revision number
* The name of the VTP domain

This list includes a couple of important items the need further discussion. Switches in either server or client mode will process VTP messages if they are in the same VTP domain; however, some restrictions are placed on whether the switch should incorporate the changes or not.

For instance, one function of the VTP summary advertisements is to ensure that all of the switches have the most current changes. If you didn't make a change on a server switch in the five-minute update interval, when the countdown timer expires, the server switch still sends out a summary advertisement with the same exact summary information. It makes no sense to have other switches, which have the most up-to-date information incorporate the same information in their configuration.
To make this process more efficient, the *configuration revision number* is used to keep track of what server switch has the most recent changes. Initially this number is set to zero (0). If you make a change on a server switch, it increments its revision number and advertises this to the other switches across its trunk links. When a client or server switch receives this information, it compares the revision number in the message to the last message it received. If the newly arrived message has a higher number, this server switch must have made changes. If the necessary VLAN information isn't in the VTP summary advertisement, all client and server switches will generate an advertisement request and the server will respond with the details in a subset advertisement

If a server switch receives a VTP message from another server, and the advertising server has a lower revision number, the receiving server switch will respond to the advertising server with a VTP message with its current configuration revision number. This will tell the advertising server switch that it doesn't

### VTP Pruning

VTP pruning is a Cisco feature that enables your switches to delete or add VLANs to a trunk dynamically, creating a more efficient switching network.

By default, all VLANs are associated with a trunk connection. This means that if a device in any VLAN generates a broadcast, a multicast, or an unknown unicast, the switch will flood this frame out all ports associated with the source VLAN port, including trunks. In many situations, this flooding is necessary, especially if the VLAN spans multiple switches. However, it doesn't make sense to flood a frame to a neighboring switch if that switch doesn't have any active ports in the source VLAN.

#### Trunking Without Pruning

![[Pasted image 20250727132259.png]]

VTP pruning is not enabled. PC-A, PC-B, PC-E, and PC-F are in the same VLAN. if PC-A generates a broadcast, SwitchA will forward this to the access link to which PC-B is connected as well as the trunk (since a trunk is a member of all VLANs, by default). This makes sense, since PC-E and PC-F, connected to SwitchB, are in the same VLAN.

a second VLAN with two members: PC-C and PC-D. If PC-C generates a local broadcast, SwitchA will obviously sent to this to PC-D's port. What doesn't make sense is that SwitchA will flood this broadcast out its trunk port to SwitchB, considering that no devices on SwitchB are in this VLAN. This is an example of wasting bandwidth and resources.
A single broadcast isn't a big problem in this example; however, if a video multicast stream at 5 Mbps was comming from PC-A, the network could experience throughput problems on the trunk, since a switch treats a multicast just like broadcast it floods it out all ports associated with the source port's VLAN.

You could use one of two methods to fix this problem: static VLAN pruning or dynamic VLAN pruning.
With a static configuration, you would manually prune the inactive VLAN off the trunk on both switches. The problem with manual pruning is that if you add a VLAN member to SwitchB, you will have to log into both switches and manually add the pruned VLAN back to the trunk.

#### Trunking with Pruning

The VTP pruning feature enable the switches to share additional VLAN information and to prune inactive VLANs dynamically from trunk connections. In this instance, the switches share which VLANs are active.
For example, SwitchA tells SwitchB that it has two active VLANs. SwitchB, on the other hand, has only one active VLAN, and it shares this fact with SwitchA. Given the shared information, both SwitchA and SwitchB realize that the one of VLAN(dark VLAN) is inactive across their trunk connection, and therefore the one of VLAN(dark VLAN) should be dynamically removed from the trunk's configuration.

The nice thing about this feature is that if you happen to active the dark VLAN on SwitchB by connecting a device to a port on the switch and assigning that port to the dark VLAN, SwitchB will notify SwitchA about the newly active VLAN, and both switches will dynamically add the VLAN back to the trunk's configuration.

![[Pasted image 20250727140336.png]]

> By default, all VLANs can traverse a trunk. VTP pruning is used on trunk connections dynamically to remove VLANs not active between the two switches. It must be enabled on a VTP server switch, and the other switches must be either servers or clients.

Only a VTP switch in *server* mode can enable VTP pruning, and the remaining switches in the domain must be either in VTP server or client mode. If you have transparent mode switches, you'll have to prune VLANs off their trunk links manually.

### Management VLAN

Unlike Cisco routers, every Cisco switch comes with a default configuration. For instance, some preconfigured VLANs are already on the switch, including VLAN 1. During the configuration, all VLAN commands refer to the VLAN number, even though you can configure an optimal name for the VLAN.

Every port on your switch, by default, is associated with VLAN 1. And all communications from the switch itself VTP messages, Cisco Discovery Protocol (CDP) multicasts, and the other traffic the switch's IP configuration is based on the VLAN interface for which you configure you IP address.

VLAN 1 is sometimes called the *management VLAN*, even though you can use a different VLAN. it is common practice to put all of your management devices (switches and management stations) in their own VLAN. If you decide to put your switch in a different VLAN than VLAN 1, it is recommended that you change this configuration on all your management devices so that you can more easily secure them, since other VLANs would have to go through a layer 3 device to access them; and on this layer 3 device, you can set up access control lists to filter unwanted traffic.

It's important that all your switches are in the same management VLAN, since many of the switch's management protocols, such as CDP, VTP and the Dynamic Trunk Protocol (DTP), occur within the switch's management VLAN. If one switch has its management VLAN set to 1 and another connected switch has its management VLAN set to 2, the two switches would lost a lot of interswitch functionality.

### Configuring VTP

If troubleshooting an existing network setup or configuring VTP yourself, it is important to understand the common VTP parameters and their values.

**default VTP configuration for Cisco Switches**

| VTP Component | VTP Default Value |
| ------------- | ----------------- |
| Domain name   | None              |
| Mode          | Server            |
| Password      | None              |
| Pruning       | Disabled          |
| Version       | 1                 |

**Configure VTP from Global Configuration mode on the Cisco switch:**
```
switch(config)# vtp domain <VTP_DOMAIN_NAME>
switch(config)# vtp mode <server|client|transparent>
switch(config)# vtp password <VTP_PASSWORD>
switch(config)# vtp pruning
```

* **`vtp domain`**
	* defines the domain name for your switch
	* in order for switches to share VTP information, they must be in the same domain.
	* Messages received from other domains are ignored.
	* If you don't configure a domain name, the switch will learn from a server advertisement.
* **`vtp mode`**
	* optional
	* defines the VTP mode of the switch
	* default: server mode
* **`vtp password`**
	* optional
	* configure MD5 password for switch which must match the password configured on every switch in the domain.
	* Switches will use this password to verify VTP message from other switches
* **`vtp pruning`**
	* optional
	* most switches, pruning is disabled by default.
	* you can disable or enable
	* If pruning is enabled on a server switch, the server switch will propagate this to all other server and client switches in the same domain.

Once you are done configuring VTP, use the **`show vtp status`** command to check your configuration:
```
IOU1#show vtp status
VTP Version capable             : 1 to 3
VTP version running             : 1
VTP Domain Name                 :
VTP Pruning Mode                : Disabled
VTP Traps Generation            : Disabled
Device ID                       : aabb.cc00.0100
Configuration last modified by 0.0.0.0 at 0-0-00 00:00:00
Local updater ID is 0.0.0.0 (no valid interface found)

Feature VLAN:
--------------
VTP Operating Mode                : Server
Maximum VLANs supported locally   : 1005
Number of existing VLANs          : 5
Configuration Revision            : 0
MD5 digest                        : 0x57 0xCD 0x40 0x65 0x63 0x59 0x47 0xBD
                                    0x56 0x9D 0x4A 0x3E 0xA5 0x69 0x35 0xBC
```

Use the **`show vtp counters`** command to display VTP statistics concerning VTP messages sent and received

### Exercise 10-1: Working with VTP

* VAN-SW1 setup

```
IOU1#config t
Enter configuration commands, one per line.  End with CNTL/Z.

### change hostname
IOU1(config)#hostname VAN-SW1

### trunk
VAN-SW1(config)#interface E0/0
VAN-SW1(config-if)#switchport trunk encapsulation dot1q
VAN-SW1(config-if)#switchport mode trunk

### verify
VAN-SW1(config-if)#do show interface E0/0
Ethernet0/0 is up, line protocol is up (connected)
  Hardware is AmdP2, address is aabb.cc00.0100 (bia aabb.cc00.0100)
  MTU 1500 bytes, BW 10000 Kbit/sec, DLY 1000 usec,
     reliability 255/255, txload 1/255, rxload 1/255
  Encapsulation ARPA, loopback not set
  Keepalive set (10 sec)
  Auto-duplex, Auto-speed, media type is unknown
  input flow-control is off, output flow-control is unsupported
  ARP type: ARPA, ARP Timeout 04:00:00
  Last input 00:00:15, output 00:00:01, output hang never
  Last clearing of "show interface" counters never
  Input queue: 0/2000/0/0 (size/max/drops/flushes); Total output drops: 0
  Queueing strategy: fifo
  Output queue: 0/0 (size/max)
  5 minute input rate 0 bits/sec, 0 packets/sec
  5 minute output rate 0 bits/sec, 0 packets/sec
     79 packets input, 13048 bytes, 0 no buffer
     Received 79 broadcasts (0 multicasts)
     0 runts, 0 giants, 0 throttles
     0 input errors, 0 CRC, 0 frame, 0 overrun, 0 ignored
     0 input packets with dribble condition detected
     720 packets output, 51988 bytes, 0 underruns
     1 output errors, 1 collisions, 0 interface resets
     0 unknown protocol drops
     0 babbles, 0 late collision, 0 deferred
     0 lost carrier, 0 no carrier
     0 output buffer failures, 0 output buffers swapped out
VAN-SW1(config-if)#
```

* VAN-SW2 setup

```
IOU2#config t
Enter configuration commands, one per line.  End with CNTL/Z.

### change hostname
IOU2(config)#hostname VAN-SW2

### trunk
VAN-SW2(config)#interface E0/0
VAN-SW2(config-if)#switchport trunk encapsulation dot1q
VAN-SW2(config-if)#switchport mode trunk

### verify
VAN-SW2(config-if)#do show interface E0/0
Ethernet0/0 is up, line protocol is up (connected)
  Hardware is AmdP2, address is aabb.cc00.0200 (bia aabb.cc00.0200)
  MTU 1500 bytes, BW 10000 Kbit/sec, DLY 1000 usec,
     reliability 255/255, txload 1/255, rxload 1/255
  Encapsulation ARPA, loopback not set
  Keepalive set (10 sec)
  Auto-duplex, Auto-speed, media type is unknown
  input flow-control is off, output flow-control is unsupported
  ARP type: ARPA, ARP Timeout 04:00:00
  Last input 00:00:01, output 00:00:07, output hang never
  Last clearing of "show interface" counters never
  Input queue: 0/2000/0/0 (size/max/drops/flushes); Total output drops: 0
  Queueing strategy: fifo
  Output queue: 0/0 (size/max)
  5 minute input rate 0 bits/sec, 0 packets/sec
  5 minute output rate 0 bits/sec, 0 packets/sec
     834 packets input, 54419 bytes, 0 no buffer
     Received 834 broadcasts (0 multicasts)
     0 runts, 0 giants, 0 throttles
     0 input errors, 0 CRC, 0 frame, 0 overrun, 0 ignored
     0 input packets with dribble condition detected
     92 packets output, 14684 bytes, 0 underruns
     1 output errors, 1 collisions, 0 interface resets
     0 unknown protocol drops
     0 babbles, 0 late collision, 0 deferred
     0 lost carrier, 0 no carrier
     0 output buffer failures, 0 output buffers swapped out
VAN-SW2(config-if)#
```

* configure VAN-SW1 as a VTP server

```
VAN-SW1(config)#vtp domain Lab101
Changing VTP domain name from NULL to Lab101
VAN-SW1(config)#vtp mode server
Device mode already VTP Server for VLANS.
VAN-SW1(config)#vtp password vtppass
Setting device VTP password to vtppass

### verify
VAN-SW1(config)#do show vtp status
VTP Version capable             : 1 to 3
VTP version running             : 1
VTP Domain Name                 : Lab101
VTP Pruning Mode                : Disabled
VTP Traps Generation            : Disabled
Device ID                       : aabb.cc00.0100
Configuration last modified by 0.0.0.0 at 0-0-00 00:00:00
Local updater ID is 0.0.0.0 (no valid interface found)

Feature VLAN:
--------------
VTP Operating Mode                : Server
Maximum VLANs supported locally   : 1005
Number of existing VLANs          : 5
Configuration Revision            : 0
MD5 digest                        : 0xE8 0x62 0x51 0x4D 0xB3 0x28 0xC9 0x4E
                                    0x57 0x93 0x79 0x59 0xBA 0x80 0x27 0xBC
VAN-SW1(config)#
```

* configure VAN-SW2 as a VTP client

```
VAN-SW2(config)#vtp mode client
Setting device to VTP Client mode for VLANS.
VAN-SW2(config)#vtp password vtppass
Setting device VTP password to vtppass

### verify
VAN-SW2(config)#do show vtp status
VTP Version capable             : 1 to 3
VTP version running             : 1
VTP Domain Name                 : Lab101
VTP Pruning Mode                : Disabled
VTP Traps Generation            : Disabled
Device ID                       : aabb.cc00.0200
Configuration last modified by 0.0.0.0 at 0-0-00 00:00:00

Feature VLAN:
--------------
VTP Operating Mode                : Client
Maximum VLANs supported locally   : 1005
Number of existing VLANs          : 5
Configuration Revision            : 0
MD5 digest                        : 0xE8 0x62 0x51 0x4D 0xB3 0x28 0xC9 0x4E
                                    0x57 0x93 0x79 0x59 0xBA 0x80 0x27 0xBC
*** MD5 digest checksum mismatch on trunk: Et0/0 ***
VAN-SW2(config)#

```

* Create VLAN (Sales, Mkt) in VAN-SW1 (server)

```
### Sales
VAN-SW1(config)#vlan 2
VAN-SW1(config-vlan)#name Sales
VAN-SW1(config-vlan)#exit

### Mkt
VAN-SW1(config)#vlan 3
VAN-SW1(config-vlan)#name Mkt

### verify
VAN-SW1(config-vlan)#do show vlan

VLAN Name                             Status    Ports
---- -------------------------------- --------- -------------------------------
1    default                          active    Et0/1, Et0/2, Et0/3, Et1/0
                                                Et1/1, Et1/2, Et1/3, Et2/0
                                                Et2/1, Et2/2, Et2/3, Et3/0
                                                Et3/1, Et3/2, Et3/3
2    Sales                            active
3    Mkt                              active
1002 fddi-default                     act/unsup
1003 token-ring-default               act/unsup
1004 fddinet-default                  act/unsup
1005 trnet-default                    act/unsup

VLAN Type  SAID       MTU   Parent RingNo BridgeNo Stp  BrdgMode Trans1 Trans2
---- ----- ---------- ----- ------ ------ -------- ---- -------- ------ ------
1    enet  100001     1500  -      -      -        -    -        0      0
2    enet  100002     1500  -      -      -        -    -        0      0
3    enet  100003     1500  -      -      -        -    -        0      0
1002 fddi  101002     1500  -      -      -        -    -        0      0
1003 tr    101003     1500  -      -      -        -    -        0      0
1004 fdnet 101004     1500  -      -      -        ieee -        0      0
1005 trnet 101005     1500  -      -      -        ibm  -        0      0

Primary Secondary Type              Ports
------- --------- ----------------- ------------------------------------------

VAN-SW1(config-vlan)#

```

* Check client VLAN
```
VAN-SW2(config)# do show vlan

VLAN Name                             Status    Ports
---- -------------------------------- --------- -------------------------------
1    default                          active    Et0/1, Et0/2, Et0/3, Et1/0
                                                Et1/1, Et1/2, Et1/3, Et2/0
                                                Et2/1, Et2/2, Et2/3, Et3/0
                                                Et3/1, Et3/2, Et3/3
2    Sales                            active
3    Mkt                              active
1002 fddi-default                     act/unsup
1003 token-ring-default               act/unsup
1004 fddinet-default                  act/unsup
1005 trnet-default                    act/unsup

VLAN Type  SAID       MTU   Parent RingNo BridgeNo Stp  BrdgMode Trans1 Trans2
---- ----- ---------- ----- ------ ------ -------- ---- -------- ------ ------
1    enet  100001     1500  -      -      -        -    -        0      0
2    enet  100002     1500  -      -      -        -    -        0      0
3    enet  100003     1500  -      -      -        -    -        0      0
1002 fddi  101002     1500  -      -      -        -    -        0      0
1003 tr    101003     1500  -      -      -        -    srb      0      0
1004 fdnet 101004     1500  -      -      -        ieee -        0      0
1005 trnet 101005     1500  -      -      -        ibm  -        0      0

Primary Secondary Type              Ports
------- --------- ----------------- ------------------------------------------

VAN-SW2(config)#
```

---

## Spanning Tree Protocol

The main function of STP is to remove layer 2 loops from your topology, logically speaking.

Digital Equipment Corporation (DEC), now a part of Hewlett-Packard(HP), originally developed STP. The Institute of Electrical and Electronics Engineers (IEEE) enhanced the initial implementation of STP, giving us the IEEE 802.1d standard. Because the two different implementations of STP, DEC STP and 802.1d, are not compatible with each other, you need to make sure that all your devices support either one or the other. Additions were made to 802.1d, including Rapid STP (RSTP) and Multiple STP (MSTP). Based on these inclusions, the IEEE implementation today is referred to as 802.1D.

All of Cisco's switches support the IEEE 802.1D protocol, which is enabled by default on their switches when sending out untagged frames (the native VLAN). if you have a mixed-vendor environment where some devices are running 802.1D and others are running DEC's STP, you may run into layer 2 looping problems.

### Bridge Protocol Data Units

For STP to function, the switches need to share information about themselves and their connections. What they share are Bridge Protocol Data Units (BPDUs), which are sent out as *multicast* frames to which only other layer 2 switches or bridges are listening. Switches will use BPDUs to learn the topology of the network: what switch is connected to other switches, and whether any layer 2 loops are based on this topology.

STP가 기능하려면, 스위치는 정보(스위치 정보, 연결 정보) 를 공유해줘야 하는데 이때 사용되는게 *Protocol Data Units (BPDUs)*. 스위치는 BDPUs를 이용해서 네트워크의 topology를 learn하게 됨(어느 스위치가 어디 스위치에 연결되어 있는지, 혹시 layer2 에 loop가 있는지 등).

To prevent loops on the network, the switches will logically disable a port or ports in the topology to ensure that there are no loops. Note that the switches don't actually shut down the port(s), but they place the port(s) in a special disabled state for user traffic.

When the port is placed in this special disabled state, the loop on the network is prevented and data can only travel one pathway between the switches. If any changes occur on the layer 2 network (a link goes down, a new link is added, a new switch is added, or a switch fails) the switches will share this information, causing the STP algorithm to be re-executed, and a new loop-free topology is then created.

loop를 방지하려면, 스위치는 논리적으로 port(s)를 disable 해야함. 이때 port(s)를 shut down 하는게 아니고, 특별한 *disabled state*에 place함.
port(s)가 이 special disabled state 에 들어 있으면, loop이 방지되고 네트워크의 트래픽은 한 pathway로만 이동 가능함 혹시 이 layer 2 network에 변경이 생긴 경우에는, 스위치가 BDPUs를 통해서 다른 스위치에 알리고, STP 알고리즘이 재실행됨. 그 다음 새로운 loop-free 토플로지가 생성됨.

By default, BDPUs are sent out every two seconds. This helps speed up convergence. *Convergence* is a term used in networking to describe the amount of time it takes to deal with changes and get the network back up and running. The shorter the time period to find and fix problems, the quicker your network is back online. Setting the BPDU advertisement time tow two seconds enables changes to be quickly shared with all the other switches in the networks, reducing the amount of time any disruption would create.

BDPUs contain a lot of information to help the switches determine the topology and any loops that result from that topology. For instance, each bridge has a unique identifier, called a *bridge* or *switch ID* This is typically the priority of the switch and the MAC address of the switch itself. When a switch advertises a BPDU, it places its switch ID in the BPDU so that a receiving switch can tell from which switch it is receiving topology information.

> that STP is a layer 2 protocol that is used to prevent loops on the network. STP implements the IEEE 802.1d standard, which involves having switches exchange BPDUs to help detect loops on the network.
> *Bridge Protocol Data Unit* messages are special frames sent between switches to share information that is necessary to configure and maintain a loop-free network with spanning tree.
> BPDU messages are sent out as multicasts every two seconds. The BPDU contains information about ports and switches on the network.

### Root Switch

STP is used to find and remove loops from a layer 2 network.

The STP algorithm works in a way that's similar to how link state routing protocols, such as Open Shortest Path First (OSPF), ensure that no layer 3 loops are created; of course, STP deals only with layer 2 loops.

A spanning tree is create first. Basically, a spanning tree is an inverted tree.
At the top of the tree is the root, or what is referred to in STP as the *root switch* or *bridge*.
From the root switch, branches (physical Ethernet connections) extend and connect to other switches, then branches from these switches connect to other switches, and so on.

**Physical topology of a network**
![[Pasted image 20250728231205.png]]

When STP is run, a logical tree structure is built.
**logical topology**
![[Pasted image 20250728231317.png]]

Switch-A is the root switch and is at the top of the tree. Underneath it are two branches connecting to Switch-B and Switch-C. These two switches are connected to Switch-E, creating a loop. Switch-B is also connected to Switch-D.

At this point, STP is still running, and a loop still exists. As STP runs, the switches will determine, out of the four switches which port on these switches will be logically disabled in order to remove the loop.

This ensures that from one device to any other device in the network, only one path will be used to connect the devices.

Actually, the very first step in STP is elect the root switch. BDPUs are used for the election process. when a device advertises a BPDU, the switch puts its switch ID in the BPDU. The switch ID is used to elect the root switch. The switch will the *lowest* switch ID is chosen as root.
The switch ID is made up of two components:
* The switch's priority, which defaults to 32,768 on Cisco switches (2 bytes on length)
* The switch's MAC address (6 bytes on length)

With Cisco switches, the default priority is 32,768, which is defined by IEEE 802.1d. Assuming that all your switches are Cisco switches and you don't change the default priority, the switch with the *lowest* MAC address will be chosen as the root switch.
You can override the election process by changing the priority value assigned to a switch.

For Cisco Catalyst switches that implement VLANs, the switches will have a different switch ID *per* VLAN and a *separate* instance of STP *per* VLAN. Each VLAN has its own root switch.
And within each VLAN, STP will run and remove loops in that particular VLAN. Cisco calls this concept-per-VLAN STP (PVST).

The election process of the root switch takes place each time a topology change occurs in the network, such as the failure of a root switch or the addition of a new switch. All the other switches in the layer 2 topology expect to see BPDUs from the root switch within the *maximum age time,* witch defaults to 20 seconds. If the switches don't see a BPDU message from the root within this period, the assume that the root switch has failed and will begin a new election process to choose a new root switch.

### Root Port

After the root switch is elected, every other switch in the network needs to choose a single port on itself that it will use to reach the root. This port on each switch is called the *root port*.
For some switches, such as Switch-B Switch-C, or Switch-E, may have two or more ports it can use to reach the root switch. If multiple port choices are available, an intelligent method needs to be used to choose the best port.
With STP, a few factors are taken into consideration when choosing a root port. It is important to not that the root switch itself will never have a root port it's the root, so it dosen't need a port to reach itself!

root 스위치가 결정되고 난 뒤에, 다른 스위치들은 root 스위치와 연결할 수 있는 하나의 포트를 선택해야함. 특정 스위치는 여러 개의 포트가 root 스위치에 엑세스 가능할 수 있음 STP를 이용해서 최선의 port를 선택함

#### Port Costs and Priorities

First, each port is assigned a *port cost*. The lower the cost, the more preferable the port.

**802.1d's cost list**

| Connection Type | New Cost Value |
| --------------- | -------------- |
| 10 Gbps         | 2              |
| 1  Gbps         | 4              |
| 100 Mbps        | 19             |
| 10  Mbps        | 100            |

The cost is an inverse reflection of the bandwidth of the port. Switches always prefer lower cost ports over higher cost ones. Each port also has a priority assigned to it, called a *port priority value*, which defaults to 32.

#### Path Costs

**Path Costs** are calculated from the root switch. A path cost is basically the accumulated port costs from the root switch to other switches in the topology. When the root advertises BPDUs out its interfaces, the default path cost value in the BPDU frame is 0. When a connected switch receives this BPDU, it increments the path cost by the cost of its local incoming port.
If the port was a Fast Ethernet port, then the path cost would be figured like this: 0 (the root's path cost) + 19 (the switch's port cost) = 19. This switch, when it advertises BPDUs to switches behind it, will include the updated path cost. As the BPDUs propagate farther and farther from the root switch, the accumulated path cost values become higher and higher.

#### Root Port Selection

If a switch has two or more choices of paths to reach the root, it needs to choose one path and thus have one root port.

1. Choose the path with the *lowest* accumulated path cost to the root
2. If multiple paths to the root are available with the same accumulated path cost, the switch will choose the neighboring switch (that the switch would go through to reach the root) with the lowest switch ID value.
3. If multiple paths all go through the same neighboring switch, it will choose the local port with the lowest priority value.
4. If the priority values are the same between the ports, the switch will choose the physically lowest numbered port on the switch.

After going through this selection process, the switch will have one, and only one, port that will become its root port.

### Designated Port

You know that each switch has a single root port that it uses to reach the root switch. In addition to each switch having a root port, each segment also has a single port that it uses to reach to root, and this port is called a *designated port*.

Imagine, for example, that a segment has two switches connected to it. Either one or the other switch will forward traffic from this segment to the rest of the network.

The third step in running STP is to elect a designated port on a single switch for each segment in the network. The switch (and its port) that is chosen should have the best path to the root switch.

**steps taken by switches in determining which port on which switch will be chosen as the designated port for a particular LAN segment:**
1. The connected switch on the segment with the lowest accumulated path cost to the root switch will be used
2. If there is a tie in accumulated path costs between two switches, the switch with the lowest switch ID will be chosen.
3. If it happens that it is the same switch, but with two separate connections to the LAN segment, the switch port with the lowest priority is chosen.
4. If there is still a tie, the physically lowest numbered port on the switch is chosen.

After going through these steps for each segment, each segment will have a single designated port on a connected switch that it will use reach the root switch. Sometimes the switch that contains the designated port is called a *designated switch*. since it is a port on the switch that is responsible for forwarding traffic. A switch may be connected to two segments, but it may be the designated switch for only one of those segments; another switch may provide the designated port for the second segment.

every active port on the root switch is designated port. because the cost of the attached network segments to reach the root is 0, the lower accumulated cost value.

### Port States

A port can be in one of five states when it is participating in STP:

* Blocking
* Listening
* Learning
* Forwarding
* Disabled

Of the five states, only the first four are used when the algorithm is running.

#### Blocking State

Ports will go into *blocking state* under one of three conditions:

1. During election of a root switch
2. When a switch receives a BPDU on a port that indicates a better path to the root switch then the port which the switch is currently using to reach the root
3. If a port is not a root port or designated port

A port in a blocking state will remain there for 20 seconds by default (the maximum age timer). During this state, the port is listening to and processing only BPDUs on its interfaces. Any other frames that the switch receives on a blocked port are dropped.
In a blocking state, the switch is attempting to figure out which port is going to be the root port, which ports on the switch need to be designated ports, and which ports will remain in a blocking state to break up any loops.

#### Listening State

After the 20-second timer expires, a root port or designated port will move to a *listening state*. Any other port will remain in a blocking state. During the listening state, the port is still listening for BPDUs and double-checking the layer 2 topology.
Again, the only traffic that is being processed on a port in this state consists of BPDUs; all other traffic is dropped. A port will stay in this state for the length of the *forward delay timer*. The default value is 15 seconds.

#### Forwarding State

Finally, after the forward delay timer expires, ports that were in a learning state are placed in a *forwarding state*, the port will process BPDUs, update its MAC address table with frames that it receives, and forward user traffic through the port.

### Disabled State

The *disabled* state is a special port state. A port in a disabled state is not participating in STP. This could be because the port has been manually shut down by an administrator, manually removed from STP, disabled because of security issues, or rendered nonfunctional because of a lack of a physical layer signal

### Layer 2 Convergence

STP goes through a staged process, which *slows down* convergence. For switches, convergence occurs once STP has completed: a root switch is elected, root and designated ports have been chosen, the root and designated ports have been placed in a forwarding state, and all other ports have been placed in a blocking state.

If a port has to go through all four states, convergence takes 50 seconds: 20 seconds in blocking, 15 seconds in listening, and 15 seconds in learning.

If a port doesn't have to go through the blocking state but starts at a listening state, convergence takes only 30 seconds. This typically occurs when the root port is still valid but another topology change has occurred.

Remember that during this time period (until the port reaches a forwarding state), no user traffic is forwarded through the port. So, if a user was performing a telnet session, and STP was being recalculated, the telnet session, from the user's perspective, would appear stalled or the connection would appear lost.

#### PortFast Overview

The faster that convergence takes place, the less disruption it will cause for your users. You can reduce the two timers to speed up your convergence time, but this can create more problems if you aren't aware of what you are doing when you change them.
For user ports, you can use the *PortFast* feature to speed up convergence. PortFast should be used only on ports that will not create layer 2 loops, such as ports connected to PCs, servers, and routers (sometimes referred to as user, or edge, ports).

A port with PortFast enabled always placed in a forwarding state this is true even when STP is running and the root and designated ports are going through their different states. So, when STP is running, PortFast ports on the same switch can still forward traffic among themselves, limiting your STP disruption somewhat.
However, if these devices wanted to talk to devices connected to other switches, they would have to wait until STP completed and the root and designated ports had moved into a forwarding state.

PortFast is a great option to configure when you want to use Preboot Execution Environment (PXE) boot with your workstations, where the device booting is trying to contact a DHCP server right away at bootup. If you are not using PortFast in this scenario, the workstation will not be able to contact the DHCP server before 50-second timers of STP have expired.

> Ports connected to non-switch devices should be configured with PortFast, such as PCs, servers, and routers.
> However, make sure that you don't enable PortFast on a port connected to another layer 2 switch, because you may inadvertently be create layer 2 loop, which can bring down the network.

#### PortFast Configuration

PortFast works will all versions STP supported by Cisco switches. Configuring the PortFast feature is simple, and you can enable it globally or on an interface-by-interface basis.

```
### globally
Switch(config)# spanning-tree portfast default

### interface-by-interface
Switch(config)# interface <type [slot_#/]port_#>
Switch(config-if)# spanning-tree portfast [trunk]
```

The optional `trunk` parameter enables PortFast on trunk connections to non-switch devices, such as a router or server with a trunk card

#### BPDU Guard Feature

BPDU Guard is used on ports configured with the PortFast feature.

if a PortFast port receives a BPDU, the switch immediately disables the port. Remember that PortFast is used on non-switch ports to keep them in a forwarding state; the assumption is that a PortFast port is not connected to a switch and therefore shouldn't be receiving BPDUs.

To enable BPDU Guard, use the following Global Configuration command:
```
IOU1(config)#spanning-tree portfast bpduguard

### verify
IOU1(config)#do show spanning-tree summary totals
Switch is in pvst mode
Root bridge for: VLAN0001-VLAN0003
Extended system ID           is enabled
Portfast Default             is disabled
PortFast BPDU Guard Default  is enabled
Portfast BPDU Filter Default is disabled
Loopguard Default            is disabled
EtherChannel misconfig guard is enabled
Configured Pathcost method used is short
UplinkFast                   is disabled
BackboneFast                 is disabled

Name                   Blocking Listening Learning Forwarding STP Active
---------------------- -------- --------- -------- ---------- ----------
3 vlans                      0         0        0         18         18
```

At the reception of BPDUs, the BPDU Guard operation disables the port that has PortFast configured. The BPDU Guard transitions the port into an errdisable (error disabled) state, and a message appears on the console.

When a port has been placed in an error disabled state, use the `errdisable recovery acuse bpduguard` command to remove the error disabled state

```
Switch(config)# errdisable recovery cause bpduguard
```

Optionally, you can have the switch periodically do this by configuring the command with an interval, specified in seconds:

```
Switch(config)# errdisable recovery interval <seconds>
```

This automatically clears all errdisable states, including BPDU violations, on all ports every x seconds. However, if a BPDU violation occurs again, the port is placed back into an errdisable state.

### Per-VLAN Spanning Tree+ (PVST+)

STP doesn't guarantee an optimized, loop-free network.

![[Pasted image 20250729022039.png]]

In this example, the network has two VLANs, and the root switch is Switch-8. The Xs are ports placed in a blocked state to remove any loops.
If you look at this configuration for VLAN 2, it definitely isn't optimized. For instance, VLAN 2 devices on Switch-1, if they want to access VLAN 2 devices on Switch-4, have to go to Switches-2,3,6,9,8 and then 4.

When one instance of STP is running, this is referred to as a *Common Spanning Tree (CST)*. Cisco also supports a process called Per-VLAN Spanning Tree Plus (PVST+).
With PVST+, each VLAN has its own instance of STP, with its own root switch, its own set of priorities, and its own set of BPDUs. In this scenario, the BPDUs have an additional field that is a component of the switch or bridge ID with these three subfields: switch priority, extended system ID, and the switch's MAC address.
The extended system ID is a new field and carries the VLAN ID (VID) for the instance of STP.

With the addition of this field, it is possible to have different priorities on switches in different VLANs; thus you have the capability of having multiple root switches (one per VLAN).
Each VLAN in PVST+, by default, will develop its own loop-free topology.

PVST+, just like CST, doesn't create an optimized, loop-free network; however, you can make STP changes in each VLAN to optimize traffic patterns for each separate VLAN. It is highly recommended that you tune STP for each VLAN to optimize it.

Another advantage that PVST+ has it that if STP changes are occurring in one VLAN, they do not affect other instances of STP for other VLANs, making for a more stable topology. Given this it is highly recommended that you implement VTP pruning to prune off VLANs from trunks of switches that are not using those VLANs.

The downside of PVST+ is that because each VLAN has its own instance of STP, more overhead is involved: more BPDUs and STP tables are required on each switch. Plus, it makes no sense to use PVST+ unless you tune it for your network, which means more work and monitoring on your part.

> PVST+ supports one instance of STP per VLAN, enabling you to tune for the most optimal paths for each VLAN. CST supports one instance of STP for all VLANs.


### Simple STP Example

![[Pasted image 20250729023144.png]]

assume that these switches do not support Rapid STP (RSTP), but only 802.1d STP. and there is only one VLAN. The ports on each switch are labeled with a letter and a number. The letter is the port designator, and the number is the cost of the port as a BPDU enters the port.

#### Electing the Root Switch

once all these switches are booted up is the election of the root switch. The switches share BPDUs with one another to elect the root.

In this example, all of the switches are using the default priority (32,768). that the switch with the lowest switch ID is elected as root. Since all of the switches have the same priority, the switch with the lowest MAC address (Switch-1) is chosen as the root switch.

#### Choosing Root Ports for Each Switch

After the root switch is elected (Switch-1), each non-root switch must choose a root port that it will use to reach the root.

* Switch-1
	* all root-port or no root port because it is root switch
* Switch-2
	* has 2 ports to use to reach the root: E and F
	* When Switch-1 generates its BPDUs on Ports I and J, the original path cost is set to 0.
	* port E -> cost 20, port F -> cost 10
	* F : root port
* Switch-3
	* port C -> cost 10, port D -> cost 70
	* C : root port
* Switch-4
	* port H -> cost 30, port G -> cost 50
	* H : root port
* Switch-5
	* port A -> cost 10, port B -> cost 50
	* A : root port

that all switches in the network are simultaneously running STP and figuring out for themselves where the root switch and which of their own ports should be the root port.
This is also true for choosing a designated port on a segment

![[Pasted image 20250729025804.png]]

#### Choosing Designated Ports for Each Segment

After the root ports are chosen, each switch will figure out, on a segment-by-segment basis, whether its connected port to the segment should be a designated port or not.
the designated port on a segment is responsible for moving traffic back and forth between the segment and the rest of the layer 2 network. The segments themselves, of course, are completely unaware of this process of choosing a designated port the switches are figuring this out.

When choosing a designated port, the first thing that is examined is the accumulated path cost for the switch (connected to the segment) to reach the root. For two switches connected to the same segment, the switch with the lowest accumulated path cost will be the designated switch for that segment, and its port connected to that segment becomes a designated port.

**Segment B, Segment C**

Since the root switch has the lowest accumulated path cost, its local port J becomes the designated port for LAN Segment-B, and local port I becomes the designated port for LAN Segment-C

**Segment A**

* Switch-3's port D and Switch-4's port H
* Switch-3 cost 10, Switch-4 cost 40

**Segment D**

* Switch-4's port G
* Switch-5's port B
* Switch 5 cost 10, Switch 4 cost 30

![[Pasted image 20250729030642.png]]

#### Changing Port States

After the designated ports are chosen, the switches will move their root and designated ports through the various states

![[Pasted image 20250729030758.png]]

In this example, two ports are left in a blocking state: Switch-2's port E and Switch-4's port G

> STP guarantees only a layer 2 loop-free topology
> it does not guarantee an optimal topology!

---

## Rapid Spanning Tree Protocol

The 802.1d standard was designed back when waiting for 30 to 50 seconds for layer 2 convergence wasn't a problem.

However, in today's networks, this can cause serious performance problems for networks that use real-time applications, such as voice over IP (VoIP) or video.

To overcome these issues, Cisco developed proprietary bridging features called PortFast, UplinkFast, and BackboneFast. The problem with these features, however, is that they are proprietary to Cisco.

RSTP is an IEEE standard, defined in 802.1w, which is interoperable with 802.1d and an extension to it. With RSTP, there are only three port states:

* Discarding
* Learning
* Forwarding

A port in a discarding state is basically the grouping of 802.1d's blocking, listening, and disabled states.

### Additional Port Roles

With RSTP, there is still a root switch and there are still root and designated ports, performing the same roles as those in 802.1d.

However, RSTP adds two additional port types: *alternative* ports and *backup* ports.

These two ports are similar to the ports in a blocking state in 802.1d. An alternative port has an alternative path or paths to the root but is currently in a discarding state. A backup port is on a segment that could be used to reach the root switch, but an active port is already designated for the segment.

an alternative port is a secondary, unused root port, and a backup port is a secondary, unused designated port.

The third port role change in RSTP is that there is no longer a blocking state; this has been replaced by a *discarding* state. All ports are either in a forwarding or discarding state: the root ports and designated ports are in a forwarding state all other ports are in a discarding state.

Given these new port roles, RSTP calculates the final spanning tree topology the same way as 802.1d. Some of the nomenclature was changed and extended, and this is used to enhance convergence times.

> the new port states introduced in RSTP include alternate, backup, and discarding ports. All active ports in RSTP are either in forwarding, learning, or discarding state. Once all ports are in a forwarding or discarding (blocking) state, RSTP has converged.

### RSTP BPDUs

The 802.1w standard introduced a change with BPDUs. Some additional flags were added to the BPDUs, so that switches could share information about the role of the port the BPDU is exiting or leaving.
This can help a neighboring switch converge faster when changes occur in the network.

In 802.1d, if a switch didn't see a root BPDU within the maximum age time (20 seconds), STP would run, a new root switch would be elected, and a new loop-free topology would be created. This is a time-consuming process.
With 802.1w, if a BPDU is not received in three expected hello periods (6 seconds), STP information can be aged out instantly and the switch considers that its neighbor is lost and actions should be taken. This is different from 802.1d, where the switch had to miss the BPDUs from the root. In 802.1w, if the switch misses tree consecutive hellos from a neighbor, actions are immediately taken.

### RSTP Convergence Features

The 802.1w standard includes new convergence features that are very similar to Cisco's proprietary UplinkFast and BackboneFast features.

The first feature, which is similar to Cisco's BackboneFast feature, allows a switch to accept *inferior* BPDUs.

**Accepting inferior BPDUs**
![[Pasted image 20250803081914.png]]

the root bridge is Switch-A. Both of ports on Switch-B and Switch-C directly connected to the root are root ports. For the segment between Switch-B and Switch-C, Switch-B provides the designated port and Switch-C provides a backup port. Switch-B also knows that is designated port is an alternative port, via Switch-C from Switch-C's BPDUs.

the link between the root and Switch-B fails. Switch-B can detect this by either missing three hellos from the root port or detecting a physical layer failure.
If you were running 802.1d, Switch-B would see an inferior root BPDU (worse cost value) coming via Switch-C, and therefore all ports would have to go through blocking, listing, and learning states, which would take 50 seconds, by default to converge.

With the inferior BPDU feature, assuming that Switch-B knows that Switch-C has an alternate port to their directly connected segment, Switch-B can notify Switch-C to take its alternative port and change it to a designated port, and Switch-B will change its designated port to a root port. This access takes only a few seconds, if even that.

The seconds convergence feature introduces in 802.1w is *rapid transition*.

Rapid transition includes two new components:

1. edge ports
2. link types

**edge ports**

An edge port is a port connected to an non-layer 2 device, such as a PC, server, or router.
RSTP with rapid transition of edge ports to a forwarding state is the same as Cisco's proprietary PortFast.
Changes in the state of these ports do not effect RSTP to cause a recalculation, and changes in other port types will keep these ports in a forwarding state.

Rapid transition can take place in RSTP only for edge ports and links that are point-to-point(P2P).

**Link types**

The link type is automatically determined in terms of the duplexing of the connection. Switches make assumption that if the port is configured for full duplex between the two switches, the port can rapidly transition to a different state without having to wait for any timers to expire.
If they are half duplex, this feature won't work by default, but you can manually enable for P2P half-duplex switch links.

**Rapid transition example**
![[Pasted image 20250803084201.png]]

When this (link between Switch-A and Switch-C fails) happens, Switch-C can no longer reach Switch-A on its root port. However, looking at the BPDUs it has been receiving from Switch-A and Switch-B, Switch-C knows that the root is reachable via Switch-B and that Switch-B provides the designated port for the segment between Switch-B and Switch-C. Switch-C knowing this, changes the state of the backup port to a root port and places it immediately into a forwarding state, notifying Switch-B of the change.
This update typically takes less than a second, assuming that the failure of the segment between the root and Switch-C is a physical link failure, instead of three missed consecutive hello BPDUs.

> RSTP converges much more rapidly than the original IEEE STP (802.1d) on point-to-point (P2P) links

#### RSTP Configuration

Cisco switches support three types of STP

**STP Types**

| STP                                    | DESC                                                                                   |
| -------------------------------------- | -------------------------------------------------------------------------------------- |
| PVST+                                  | 802.1d per VLAN with Cisco-proprietary extensions (PortFast, UplinkFast, BackboneFast) |
| PVRST+                                 | 802.1w (RSTP) per VLAN                                                                 |
| Multiservice Transport Platform (MSTP) | 802.1s, referred to as multiple STP, combines Cisco's PVST+ with IEEE standards        |

To enable PVRST+
```
Switch(config)# spanning-tree mode rapid-pvst
```

Once enabled, you can view the STP on per-VLAN basis
```
IOU1(config)#do show spanning-tree vlan 1      

VLAN0001
  Spanning tree enabled protocol rstp
  Root ID    Priority    32769
             Address     aabb.cc00.0100
             This bridge is the root
             Hello Time   2 sec  Max Age 20 sec  Forward Delay 15 sec

  Bridge ID  Priority    32769  (priority 32768 sys-id-ext 1)
             Address     aabb.cc00.0100
             Hello Time   2 sec  Max Age 20 sec  Forward Delay 15 sec
             Aging Time  300 sec

Interface           Role Sts Cost      Prio.Nbr Type
------------------- ---- --- --------- -------- --------------------------------
Et0/0               Desg FWD 100       128.1    Shr Peer(STP) 
Et0/1               Desg FWD 100       128.2    Shr 
Et0/2               Desg FWD 100       128.3    Shr 
Et0/3               Desg FWD 100       128.4    Shr 
Et1/0               Desg FWD 100       128.5    Shr 
Et1/1               Desg FWD 100       128.6    Shr 
Et1/2               Desg FWD 100       128.7    Shr 
Et1/3               Desg FWD 100       128.8    Shr 
Et2/0               Desg FWD 100       128.9    Shr 
Et2/1               Desg FWD 100       128.10   Shr 
Et2/2               Desg FWD 100       128.11   Shr 
Et2/3               Desg FWD 100       128.12   Shr 
Et3/0               Desg FWD 100       128.13   Shr 
Et3/1               Desg FWD 100       128.14   Shr 
Et3/2               Desg FWD 100       128.15   Shr 
Et3/3               Desg FWD 100       128.16   Shr Edge 
```

You can also verify STP on a per-port basis with the `show spanning-tree interface` command
```
IOU1(config)#do show spanning-tree interface E0/0

Vlan                Role Sts Cost      Prio.Nbr Type
------------------- ---- --- --------- -------- --------------------------------
VLAN0001            Desg FWD 100       128.1    Shr Peer(STP) 
VLAN0002            Desg FWD 100       128.1    Shr Peer(STP) 
VLAN0003            Desg FWD 100       128.1    Shr Peer(STP) 
```

> To troubleshoot problems with PVRST+, use the `debug spanning-tree pvst+` command; to troubleshoot problems with ports changing state within STP, use `debug spanning-tree switch state`

### PVST+ and RSTP Optimization

**PVST+ and RSTP non-optimized**
![[Pasted image 20250803090013.png]]

This example shows two VLANs, numbered 1 and 2. The default behavior with Cisco's switches is that a single root switch is used for all VLANs, based on the switch with the lowest switch ID.
In this instance, this is Switch-A. Notice that based on RSTP's calculation, Switch-C disabled its port to Switch-B for both its VLANs. The downside of this design is that of the two connections to the distribution layer, only one is being utilized on the access switch.

**PVST+ and RSTP optimized**
![[Pasted image 20250803090340.png]]

To obtain this kind of topology, however, you must tune your network, making sure that Switch-A is the root for VLAN 1 and Switch-B is the root for VLAN 2.
With this kind of design, you can actually utilize both of you uplink connections on your access layer switch up to the distribution layer switches.
VLAN 1 will use the left-hand uplink connection and VLAN 2 the right-hand uplink connections.

you must manually change each switch's priority to create the desired topology.
```
Switch(config)# spanning-tree vlan VLAN_# root primary
Switch(config)# spanning-tree vlan VLAN_# root secondary
Switch(config)# spanning-tree vlan VLAN_# priority PRIORITY_#
```

the default priority for a switch is 32768.
The first command changes the switch's priority to 4096 for the specified VLAN.
The second command changes the switch's priority to 8192 for the specified VLAN.
The third enables you to customize the priority for the specified VLAN.

```
## switch pvst prepare
Swtich-A(config)# spanning-tree mode rapid-pvst
Switch-B(config)# spanning-tree mode rapid-pvst

## VLAN 1
Switch-A(config)# spanning-tree vlan 1 root primary
Switch-B(config)# spanning-tree vlan 1 root secondary

## VLAN 2
Switch-A(config)# spanning-tree vlan 2 root secondary
Switch-B(config)# spanning-tree vlan 2 root primary
```

priorites for the primary and secondary are switched on the two VLANs to allow for the use of both uplinks from Switch-C, the access layer switch.

> Any STP configuration changes you make on your switches are affected immediately, which means that layer 2 will have to reconverge, causing a brief disruption in your layer 2 network.

### STP Troubleshooting

*broadcast storm*: Switches send broadcast messages to all ports on the switch (expect the port it was received on). If you have a layer 2 loop, that means there are multiple pathways between the switches, and the broadcast message would be rebroadcasted from one switch to another, using up bandwidth and processing power on the switches

Broadcast storms are bad, because they will eventually bring the network down.

#### Loop Identification

One indication of a broadcast storm is very high CPU and port utilization on your switches.
you can examine a switch's or several switches' CPU utilization with the `show processes` and `show process cpu` commands.

A constantly high CPU utilization could indicate a loop. To verify that a layer 2 loop is causing the problem, capture and analyze traffic with a protocol analyzer to determine whether the same packet appears multiple times. This is typically done by connecting your protocol analyzer to a switch and using the Switch Port Analyzer (SPAN) feature on your switch, which copies frames from an interface or VLAN to the SPAN port. A good analyzer should be able to see that a loop exists and notify you of this problem.

Once a loop is identified, to restore connectivity quickly, you should start disabling ports that are the part of the loop; then diagnose the problem to determine whether a configuration issue on your part or the addition of a new layer 2 device is causing the problem.

If you are having problems identifying that is causing the loop, turn on debug for STP `debug spannig-tree events`

### Configuration Remedies

To simplify your troubleshooting process, disable as many features as necessary.

If you are not certain which switch is the root switch, log into the switch that logically should be the root and force it to become the root by changing its priority to 1 with the `spanning-tree vlan VLAN_# priority` command.

> include the MAC addresses of each switch in your network topology diagram. Then, when troubleshooting loop problems, you'll find it much easier to determine whether a rogue switch was introduced into the topology may be creating the loop.

Make sure that all your switches are running either 802.1d or 802.1w (RSTP). Use the `show spanning-tree` command to verify this as well as whether or not the switch is playing the role of root for a VLAN.

### Exercise 10-2: Monitoring STP

---

## EtherChannels

It is common to need higher bandwidth speeds for certain kinds of connections in your network, such as connections from the access layer to the distribution layer, between distribution layer switches, between distribution and core layer switches.

### EtherChannel Overview

An EtherChannel is a layer 2 solution that enables you to aggregate multiple layer 2 Ethernet-based connections between directly connected devices. Basically, an EtherChannel bundles together multiple Ethernet ports between devices, providing what appears to be a single logical interface.
From STP's perspective, it sees the EtherChannel as a single logical connection between the connected devices, which means that you can actually use all of the individual connections, simultaneously, in the channel you've created.

EtherChannels provide these advantages:
* **Redundancy**
	* If one connection in the channel fails, you can use other connections in the channel.
* **More bandwidth**
	* Each connection can be used simultaneously to send frames.
* **Simplified management**
	* Configuration is done on the logical interface, not on each individual connection in the channel.

### EtherChannel Restrictions

Interfaces in an EtherChannel must be configured identically: speed duplexing, and VLAN settings (in the same VLAN if they are access ports, or the same trunk properties) must be the same.
When setting up EtherChannels, you can use up to eight interfaces bundled together:

* Up to eight Fast Ethernet connections, providing up to 800 Mbps
* Up to eight Gigabit Ethernet connections, providing up to 8 Gbps
* Up to eight 10-Gigabit Ethernet connections, providing up to 80Gbps

Typically you can have a total of six EtherChannels on a switch, but this is larger one the higher-end IOS switches

> when forming an EtherChannel, all ports must be configured for the same speed, trunk encapsulation type (access, 802.1Q, or ISL), and duplex setting.

### EtherChannel Operations

Channels can be formed dynamically between devices by using one of two protocols: Port Aggregation Protocol (PAgP) or Link Aggregation Protocol (LACP).

| Protocols | DESC                                                                                                                                                                                   |
| --------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| PAgP      | Proprietary to Cisco. it enables connected devices to group similarly configured ports dynamically into single channel                                                                 |
| LACP      | Defined in the IEEE 802.3ad standard. Like PAgP, it learns from a connected device which ports between the two are identically configured and dynamically forms a channel between them |

Once a channel is formed, load balancing ca be used by the connected devices to utilize all the ports in the channel. Load balancing is performed by reducing part of the binary addressing in the frame or packet to a numeric value and then associating the numeric value to one of the ports in the channel. Load balancing can use MAC or IP addresses, source or destination addresses, or both source and destination address pairs.
With load balancing, you are guaranteed that all links in the channel will be utilized; however, you are not guaranteed that all the ports will be utilized the same.

For example, if you are load balancing based on source addresses, you are guaranteed that different source MAC address will use different ports in the channel. All traffic from a single-source MAC address, however, will always use the same port in the channel.
Given this situation, if one device is generating a lot of traffic, that link will possibly be utilized more than other links in the channel. In such a situation, you may want to load balance based on the destination address or both the source and destination addresses.

### EtherChannel Configuration

```
Switch(config)# interface type [slot_#/]port_#
Switch(config-if)# channel-group group_# mode mode
Switch(config-if)# port-channel load-balance {dst-ip | dst-mac | src-dst-ip | src-dst-mac | src-ip | src-mac}
```

The *`group_#`* specifies the channel group to which the interface belongs, which can be from 1 to 6.

The `mode` can be one of those:
* auto
	* PAgP
	* Passively listens for PAgP queries from Cisco device configured with either desirable or on. By default, the interface is not part of a channel.
* desirable
	* PAgP
	* Generates PAgP queries to form a channel, but by default is not part of a channel.
* on
	* PAgP
	* Generates PAgP queries and assumes the port is part of a channel.
* active
	* LACP
	* Enables a channel if the other side responds to its LACP messages.
* passive
	* LACP
	* Passively listens for LACP messages to form a channel from an active port.

> If you want to treat this as a layer 3 interface, on a router for example, and assign an IP address to it, the port channel must be designated as `interface port-channel group_#`

Use the `port-channel load-balance` command to configure the type of load balancing you want to use on the channel. If you omit this command it defaults to load balancing based on source MAC address (src-mac)

> if one side of a PAgP EtherChannel is set to auto for the mode, the other needs to be set to either on or desirable.
> The active and passive modes are used only to establish an EtherChannel using LACP.

```
### SwitchA Etherchannel
SwitchA(config)# interface g1/0/1
SwitchA(config-if)# channel-group 1 mode auto
SwitchA(config-if)# exit

SwitchA(config)# interface g1/0/2
SwitchA(config-if)# channel-group 1 mode auto

### SwitchB
SwitchB(config)# interface g1/0/4
SwitchB(config-if)# channel-group 1 mode on
SwitchB(config-if)# exit

SwitchB(config)# interface g1/0/5
SwitchB(config-if)# channel-group 1 mode on 
```

### Exercise 10-3: Working with EtherChannel 

---

## Chapter Review