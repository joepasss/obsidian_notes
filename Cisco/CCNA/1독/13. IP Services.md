## Understanding Network Services

Several basic network services are used or provided by Cisco network devices. hostname resolution services, Network Time Protocol (NTP), Simple Network Management Protocol (SNMP), File Transfer Protocol (FTP), Trivial File Transfer Protocol (TFTP), telnet, and Secure Shell (SSH).

### Hostname Resolution

When entering commands on your Cisco device, you will want to simplify by supplying friendly names to commands instead of using device IP addresses.

Friendly names can be resolved to an IP address in a couple of ways: you can create a hostname table that resolves the names locally on your device, or you can configure your device to query a Domain Name System (DNS) server.

#### Creating Hostname Tables

To reference the devices on the network by their names, you can create a hostname table of names matching IP addresses that are local to the device.

To create a hostname entry in the hostname table you use the `ip host <name> <ip_address>` command from Global Configuration mode.

For example, if you are connected to R1 and want to reference R2 by name using ping or telnet, you would use the following command to configure R2 as a resolvable name:
```
R1> enable
R1# config term
R1(config)# ip host R2 13.0.0.2
```

You can create multiple entries by executing the `ip host` command multiple times with a different name and IP address each time. Once you have created the entries in the table, you can view the entries with the `show hosts` command:

```
R1#show hosts
Default domain is not set
Name/address lookup uses static mappings

Codes: UN - unknown, EX - expired, OK - OK, ?? - revalidate
       temp - temporary, perm - permanent
       NA - Not Applicable None - Not defined

Host                      Port  Flags      Age Type   Address(es)
R2                        None  (perm, OK)  0   IP    192.168.100.1

```

After you've created the hostname entry, you can use that hostname with other commands, such as `ping`, `telnet`, or `traceroute`.

#### Understanding DNS

Domain Name System is a common network service that enables system names to be translated into their IP addresses; this enables us to communicate using friendly names.

DNS is a hierarchy of servers that are designed to resolve *fully qualified domain names* (FQDNs) to IP addresses.

![[Pasted image 20250830044136.png]]

if you try to connect to web site at `www.gleneclarke.com`, your system first sends a query to the DNS server on your network asking for the IP address of `www.glenclarke.com`. If your local DNS server does not know the IP address of the site, it then sends the query to the DNS root servers on the Internet. They then forward the request on the .com name servers, and then on to my DNS server. My DNS server has the IP address of my web site in its database, so my server sends that back to your DNS server in your office. Your DNS server then sends the IP address to your client system that wants to visit the web site.

#### Configure DNS Lookups

If you want your Cisco device to perform DNS lookups on entries you type that are not commands, such as `server1.glenclarke.com`, you can configure DNS lookups with the `ip domain-lookup` command.
DNS lookup is actually enabled by default, but many administrators disable it using the `no ip domain-lookup` command, because if typos appear in a command, the device thinks it is a name and tries to resolve it (which takes extra time).

After ensuring that domain lookups are enabled, you then specify the DNS server where the lookup will be performed using the `ip name-server <ip_dns_server>` command. You can also configure the optional setting of the domain name if you like, which is then automatically appended to any hostnames that are used to create an FQDN.

```
VAN-R1>enable
VAN-R1#config term
VAN-R1(config)# ip domain-lookup
VAN-R1(config)# ip name-server 12.0.0.100
VAN-R1(config)# ip domain-name glenclarke.com
```

If you want to verify that your device is configured to perform domain lookups, use the `show hosts` command:

```
VAN-R1# show hosts
Default Domain is glenclarke.com
Name/address lookup uses domain service
Name servers are 12.0.0.100
Codes: UN - unknown, EX - expried, OK - OK, ?? - revalidate
       temp - temporary, perm - permanent
       NA - Not Applicable, None - Not defined
Host          Port    Flags        Age  Type    Address(es)
LA-R1         None    (perm, OK)   0    IP         13.0.0.2
```

### Network Time Protocol

The date and time on your router are important for a multiple reasons. The two most common ones are:
* Logging of messages
* Using digital certificates for authentication

Obviously, having the correct timestamp on a log message will help you in forensis when examining logging messages regarding security. Digital certificates are used for authentication, and one of the components validated on a device's certificate is whether it is current: the certificate includes beginning and ending dates and times.
A peer that receives the certificate will compare its current time and make sure that it falls between the beginning and ending dates and times on the certificate.

You can set the date ant time on your device in two ways:
* Manually configure the date and time using the `clock set` command
* Use NTP

NTP is an open standard that enables you to synchronize your router's time with a centralized time server, where your device periodically polls the NTP server for the current date and time.
NTP uses the User Datagram Protocol (UDP) on port 123.
NTP running on your device can get the correct time from an internal or external server.
The reliability of the server refers to the stratum level of the clock source. The most accurate source is an atomic clock, but most networks typically don't need that kind of precision and instead obtain time from a global positioning system (GPS) source. You can also synchronize your devices' times by using global time servers available on the internet, such as the Google public time service, to synchonize time with Google's atomic clocks. In this case, you can configure the NTP settings on your devices to refer to `time.google.com`.

NTP has three basic methods of delivering time messages between the time server and the NTP client:

* **Broadcast**
	* The NTP server periodically announces the time using a broadcast message.
	* This method assumes that all clients are in a local subnet.
* **Multicast**
	* The NTP server periodically announces the time using a multicast message.
	* In most cases, multicast routing must be set up to disseminate the time across the network.
* **Unicast**
	* The NTP client periodically (commonly, every 10 minutes) queries the NTP server for the correct time.

> Most administrators will implement a multicast solution, because it scales the best: the server sends out only one message, which, if multicast routing is configured correctly, will appear on all network segments that have NTP clients.
> The unicast approach is commonly used in smaller networks because it is easier to set up.

Cisco IOS devices support two versions of NTP:

* NTPv3/v4
* SNTP (Simple NTP)

NTPv3/v4 supports MD5 for authentication. A shared key is preconfigured on the time server and your networking device. This key is commonly referred as a *pre-shared* key (PSK), because it must exist on both devices before it can be used for authentication purposes.

The time server hashes the current date and time message with the PSK using MD5 and adds this signature to the time message. Your router repeats this process with the received date and time and its locally configured PSK, and it then compares the two hash values; this is commonly referred to as a *message digest* or *digital signature*, and it verifies that the message is valid (the same key was used)

SNTP, as its name implies, is a simpler method of acquiring time. Unlike NTPv3 or NTPv4, Cisco's IOS implementation of SNTP (as well as that of most vendors) doesn't support authentication of time messages.

NTP is a critical component for network management on networking devices, including logging and authentication functions. NTP ensures that all your devices are synchronized with the same time source.
However, NTP doesn't require authentication with a time source. Because of this, a hacker could send NTP packets to your devices, changing their time, and as a result affecting logging and authentication functions. There are three solutions to this problem:

* Use NTP or virtual private network (VPN) to connect to the time source.
* Use access control lists (ACLs) to filter timing information from only valid time sources.
* Set up your own master time source instead of using an untrusted one on the internet.

#### NTP Configuration

IOS devices can be configured as NTP servers and/or clients.
They are typically configured as time servers to relay time from a reliable local master clock.

> You should not use an IOS device as a local master clock, because IOS doesn't support a method of connecting to an externally reliable time source, such as GPS.
> However, many operating systems, such as Linux, support NTP server applications that support external clock connections such as GPS

```
# define NTP servers on an IOS device
IOS(config)# ntp server IP_ADDR [version number] [key keyid] [source interface] [prefer]
```

You first need to define the IP address of the remote NTP server. If you don't specify the version number for NTP, it defaults to 3 (NTPv3).

The optional `key` parameter references authentication information to be used to verify the server's or peer's timing communications: this must match what the server is using when NTPv3 authentication is performed.

The `source` parameter specifies what IP address on the IOS device to use as the source address in the IP packet header when sending communications to the remote NTP server (note that you identify the layer 3 interface on the IOS device to reference the IP address to use). If you omit this parameter, it defaults to the address of the outgoing layer 3 interface.

When you are entering multiple NTP servers, you can use the `prefer` parameter, which specifies that this NTP server is preferred over other servers for synchronization purposes; otherwise, the first server configured is the first one that the IOS device will query.

You need to configure three commands to set up authentication:

```
IOS(config)# ntp authenticate
IOS(config)# ntp authentication-key key_# md5 key_value
IOS(config)# ntp trusted-key key_#
```

The `ntp authenticate` command enables NTP authentication.

The `ntp authentication-key` command defines a reference number for the key (key_#) as well as the authentication key. (the same key_# and key_value must configured on the remote NTP server.)

The `ntp trusted-key` command specifies which NTP devices should be trusted with authentication, which prevents an accidental synchronization to a system that is not trusted.

Notice that a reference number is used. The reference number must match that used in the `ntp authentication-key` command.
By using a key number, you can create multiple keys, enabling you to update keys more easily and to use different keys for different peers.

Once you have defined authentication, you need to reference the key number in the corresponding `ntp server` command, which tells the IOS device which key to use when sending messages to specific peers.

#### NTP Verification

Once you have configured NTP on your IOS device, you can use various `show` commands to examine your configuration and troubleshoot problems.
To see the current time on the router's software clock, use the `show clock` command.

You'll use two basic commands to examine NTP information:

* **`show ntp associations`**
* **`show ntp status`**

The `show ntp associations` command displays associations with the NTP server(s).

```
IOS> show ntp associations
  address       ref clock     st  when  poll  reach  delay  offset  disp
*~192.168.1.11  192.168.1.11  2   31    1024  377    4.1    -8.38   1.5
* mater (syncd), # master (unsyncd), + selected, - candidate, ~ configured
```

The first set of leading characters displays synchronization information:

| char | info                                                    |
| ---- | ------------------------------------------------------- |
| *    | This router is synchronized to this peer                |
| #    | The router is almost synchronized to this peer          |
| +    | The peer has been selected for possible synchronization |
| -    | The peer is a candidate for synchronization             |
| ~    | The peer has been statically configured                 |

Each column contains the following information

| col       | info                                                                                                                                       |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------------ |
| address   | Lists the address of the NTP peer devices                                                                                                  |
| ref clock | Lists the addresses of where peers in the address column are getting their time                                                            |
| st        | indicates the time since the last NTP message was received from this peer                                                                  |
| poll      | indicates the polling interval, in seconds, that this router is using to contact the specified peer                                        |
| reach     | Indicates the peer's reachability, in octal                                                                                                |
| delay     | Displays the round-trip delay, in milliseconds, to the peer                                                                                |
| offset    | Displays the relative time of the peer's clock to the local router's clock, in milliseconds                                                |
| disp      | Dispersion is a value reported in seconds. It represents the maximum clock difference ever reported between the server and the local clock |

The `show ntp status` command displays the status of NTP on the router
```
IOS# show ntp status
Clock is synchronized, stratum 2, reference is 192.168.1.11
nominal freq is 250.0000 Hz, actual freq is 249.9990 Hz, precision is 2**19
reference time is AFE2525E.70597C87 (00:10:39.511 EDT Thu Jan 1 2004)
clock offset is 6.21 msec, root delay is 83.98 msec
root dispersion is 81.96 msec, peer dispersion is 2.02 msec
```

In this example, IOS is synchronized to the NTP server at 192.168.1.11, which provides a stratum level 2 service.

#### NTP Configuration Example

![[Pasted image 20250831224542.png]]

```
Router(config)# ntp server 192.168.1.11 key 99 source ethernet0
Router(config)# ntp authenticate
Router(config)# ntp authentication-key 99 md5 55ab8972G
Router(config)# ntp trusted-key 99
Router(config)# interface ethernet1
Router(config-if)# ntp disable
Router(config)# interface ehternet2
Router(config-if)# ntp disable
```

In this example, the NTP server is 192.168.1.11, which is specified in the first command. The next three commands set up authentication, and refer back to the first command with the key reference number of 99

Notice that the hash key is `55ab8972G`, which must *also* configured on the NTP server.
Last, NTP is disabled on two interfaces that it doesn't expect to receive time messages from.

### Simple Network Management Protocol

Some management of network devices requires the use of SNMP, which is commonly used to manage (configure and/or monitor) a remote networking device.

#### SNMP Overview

SNMP comprises three components:

* **Network management station (NMS)**
	* This device accesses and manages agents and is sometimes referred to as the *manager*
* **Agent**
	* This is a device managed by an NMS.
* **Management information base (MIB)**
	* This database defines how information (configuration, operational, and statistical) is stored on an agent.

The interaction is between the NMS and the agent, which can involve two types of connections:

* NMS sends `get` or `set` commands to the agent; `get` commands are used for retrieving MIB information, and `set` commands are used to change MIB information.
* The agent sends `traps`, or `informs`, to the NMS, which are a form of log message, indicating an important condition on the device.

Information stored on an agent is located in an MIB. Each MIB is uniquely identified with an object identifier (OID). Get, send, and trap messages are based on the MIB information identified by a particular OID.

#### SNMP Versions

There are three main versions of SNMP. SNMPv1 and v2 use community strings for security: read-only and read-write.

The read-only community string is used to restrict the reading of MIB information, and the read-write community string is used to change MIB information.
The main problem with community strings, however, is that they are sent in clear text and are thus susceptible to eavesdropping attacks.
SNMPv2c also added the support of inform requests, which enables a management station to access multiple MIBs in one request.
SNMPv3 is an enhancement of SNMPv2. In addition to supporting the same MIB structure and gets, sets, and traps, SNMPv3 supports authentication, message integrity, and payload encryption.
Message integrity is used to ensure that SNMP messages have not been tampered with and are coming from a legitimate source; this is accomplished with the MD5 or Secure Hashing Algorithm v1 (SHA-1) hashed message authentication code (HMAC) functions.
Payload encryption is used so that a man-in-the-middle (MITM) attack cannot examine the get, set, and trap command information.

In an MITM attack, an attacker's device sees traffic flowing between the source and destination. Encryption can be used to defeat MITM attacks: the attacker can still see the packets, but the content is encrypted from eavesdroppping.
Encryption is accomplished with the Data Encryption Algorithm (DES), Tripe DES (3DES), or Advanced Encryption Standard (AES) encryption algorithms.

**SNMP Security Models**

| SNMP Version | Level        | Auth             | Encryption     | Desc                                                                |
| ------------ | ------------ | ---------------- | -------------- | ------------------------------------------------------------------- |
| 1            | NoAuthNoPriv | Community string | No             | Authentications with a community string match                       |
| 2c           | NoAuthNoPriv | Community string | No             | Authenticates with a community string match                         |
| 3            | NoAuthNoPriv | Username         | No             | Authenticates with a username                                       |
| 3            | AuthNoPriv   | MD5 or SHA       | No             | Provides MD5/SHA for authentication                                 |
| 3            | AuthPriv     | MD5 or SHA       | DES, 3DES, AES | Provides MD5/SHA for authentication and encryption via DES/3DES/AES |

#### SNMP Configuration

```
IOS(config)# snmp-server location LOCATION_INFORMATION
IOS(config)# snmp-server contact CONTACT_NAME
```

The first command identifies the location of the device, such as the building, floor, and wiring closet in which the Cisco device resides.
The second command identifies the administrator contact information. Both of these can be pulled from the NMS.

#### SNMPv2c Configuration

```
IOS(config)# snmp-server community STRING ro
IOS(config)# snmp-server community STRING rw
IOS(config)# snmp-server host NMS_IP_ADDRESS traps STRING
IOS(config)# snmp-server enable traps
```

The first command defines the community string used to enable read-only access.
The second command defines the community string for read-write access.
Note that community sting is sent, in clear text, in the SNMP packet to restrict access.
The last two commands enable the sending of SNMP traps to an SNMP management station (you also have to match the community string on the IOS device to what the NMS has configured).

#### SNMPv3 Configuration

The configuration of SNMPv3 is much more complicated.

```
IOS(config)# snmp-server view VIEW_NAME OID_MIB {included | excluded}
IOS(config)# snmp-server group GROUP_NAME {v1 | v2c | v3} 
                {auth | noauth | priv} [read READ_VIEW] 
                [write WRITE_VIEW] [notify NOTIFY_VIEW]
                [access-list ACL_ID]
IOS(config)# snmp-server user USER_NAME GROUP_NAME {v1 | v2c | v3}
                [auth {md5 | sha} AUTH_PASSWORD] [priv {des | 3des | aes  { 128 | 192 | 256}} ENCR_PASSWORD]
                [access ACL_ID]
IOS(config)# snmp-server host HOST_NAME_OR_IP [traps | informs]
                [version {1 | 2c | 3}] [auth USER_NAME]
IOS(config)# snmp-server enable traps
```

SNMP views (`snmp-server view`) control which OIDs can or can't be accessed. Using views is optional, but by default there's no restriction to accessing the OIDs if you have SNMP access to the IOS device.

Groups (`snmp-server group`) define the level of access. With groups, you can specify which version of SNMP is used, the required authentication type, which views can be accessed via gets, sets, and traps, and which NMS can access them (via an ACL)

Users define the actual NMS. The authentication credentials define the HMAC signature function and key used to create signatures, and the privilege credentials define the encryption algorithm and key to use.

**simple SNMPv3 configuration example**
```
IOS(config)# access-list 10 permit host 10.0.1.12
IOS(config)# snmp-server view myview interfaces included
IOS(config)# snmp-server group mygroup v3 priv read myview access 10
IOS(config)# snmp-server user myuser mygroup v3 auth sha a3fh95t11a priv aes 128 dkfjiewokd892a
IOS(config)# snmp-server host 10.0.1.12 traps version 3 auth myuser
IOS(config)# snmp-server enable traps
```

In this example, an SNMP view was created that included the "interfaces" MIB/OID.
An SNMP group for v3 was created, limiting the view to read access. The group references the view and the ACL to restrict SNMPv3 access.
The SNMP user specifies the access credentials (protection) and references the group to use.
The SNMP server is defined with traps being sent to the server, and the SNMP user configuration is referenced so the router knows the access method to enforce.
Finally, SNMP traps are enabled so the router can send events to the SNMP management station.

### Other Network Services

#### TFTP and FTP

Cisco administrators can use TFTP or FTP services to transfer files to and from their Cisco devices. Both TFTP and FTP are file transfer protocols with a few differences:

* TFTP does not support authentication, while FTP does
* TFTP uses UDP, while FTP is TCP based
* TFTP runs on UDP port 69 by default, while FTP uses TCP port 21 by default.

Cisco administrators typically use TFTP to back up their device configuration an their IOS. The `copy` command in Cisco supports TFTP as both a source and a destination, so you can copy to the TFTP server or copy from the TFTP server.

For example, to back up your IOS to the TFTP server, you can use the `copy flash: tftp:` command and answer the questions, such as what is the filename to copy, what is the IP address of the remote host (the TFTP server), and what is the filename to be created at the destination.

You can also use FTP to back up files from the Cisco device. a bit more configuration is needed to use FTP, such as the username and password that needs to be configured before using the FTP feature.

#### Telnet and SSH

Cisco administrators will want to administer their devices remotely either by using telnet as the protocol or using SSH.

Telnet has been a remote administration protocol for many years but has major drawback in that it is a protocol that send all data, including username and passwords, in clear text. This means anyone who can intercept the telnet traffic can see what you are doing and also discover your credentials to log on to the device.

This is where SSH comes in. SSH is a protocol that also enables remote administration of your devices, but it encrypts all the traffic from your administration computer to the device you are managing.
This means that if someone intercepts the traffic, it is encrypted, so the attacker will not be able to view the details of what you are doing.
It is important to note that SSH also encrypts the username and password that is used during logon.

### Exercise 13-1: Configuring Hostname Resolution

Configure hostname tables on VAN-R1 and LA-R1.
Configure each system for DNS name resolution using a DNS server.

![[Pasted image 20250901003544.png]]

```
### VAN-R1
VAN-R1> enable
VAN-R1# config term
VAN-R1(config)# ip host LA-R1 13.0.0.2

### view the hostname table
VAN-R1# show hosts

### ping test
VAN-R1# ping LA-R1

### TFTPServer
VAN-R1# config term
VAN-R1(config)# ip host TFTPServer 12.0.0.100

### verify
VAN-R1# show hosts
VAN-R1# ping TFTPServer
```

```
### Configure router for the domain name of exer13-1.loc and point to the DNS server of 12.0.0.100 for name resolution
VAN-R1(config)# ip domain-lookup
VAN-R1(config)# ip name-server 12.0.0.100
VAN-R1(config)# ip domain-name exer13-1.loc
```

```
### LA-R1
LA-R1> enable
LA-R1# config term
LA-R1(config)# ip host VAN-R1 13.0.0.1

### verify
LA-R1# show hosts
LA-R1# ping VAN-R1

### TFTPServer
LA-R1# config term
LA-R1(config)# ip host TFTPServer 12.0.0.100

### DNS server
LA-R1(config)# ip domain-lookup
LA-R1(config)# ip name-server 12.0.0.100
```

---

## Configuring DHCP Services

DHCP enables devices to acquire their IP addressing information dynamically, without the administrator needing to configure IP address information on each host on the network.
DHCP is built on a client/server model and defines two components:

* **Server**
	* Delivers IP configuration information to the DHCP client (hosts)
* **Client**
	* Requests and acquires host configuration information from the DHCP server

Using a DHCP server to assign addressing information provides these three networking advantages over manually configuring addressing information on devices:

* Reduces the amount of time it takes to address a network
* Reduces the likelihood of IP addressing errors on devices
* Provides mobility for employees to move around the network, connect, and obtain the correct IP addressing information based on their location

### Understanding DHCP

DHCP is an application-layer protocol that can automatically configure each system on the network with IP address information. Your first step to configuring a DHCP server on your Cisco router is to enable the service; then you can configure a pool. A pool is the range of IP address that DHCP gives out on the network, as well as any additional settings such as the router address (the `default gateway`), the DNS server, and how long the system is to have the IP address.

a DHCP client goes through four phases to obtain an IP address from the DHCP server:
1. DHCP Discover
	* The DHCP discover message is sent by a client to all systems on the network using the destination broadcast address (FF-FF-FF-FF-FF-FF).
	* This message basically saying, "If you are a DHCP server, I need an IP address"
	* all phases use this broadcast address (FF-FF-FF-FF-FF-FF) for communication because the client does not have an IP address yet.
2. DHCP Offer
	* Any DHCP servers on the network that receive the discover message will send an offer to the client basically stating, "I am a DHCP server and you can have this IP address."
	* If a system is not a DHCP server, it discards the DHCP discover message when it receives it.
3. DHCP Request
	* After receiving an offer, the client sends out a DHCP request message starting which offer (IP address) it want to receive.
	* Keep in mind that the client may receive many offers, so when the client sends out the DHCP request message confirming which offer it is taking, all other DHCP servers retract their offers.
4. DHCP Acknowledgement (ACK)
	* After the DHCP server receives the DHCP request message from the client requesting to have the IP address that was offered, the DHCP server sends a final acknowledgement message indicating to the client that the address is now that server's address and indicating how long the server will have the address (lease time).
	* The DHCP acknowledgement message also contains any additional IP address options for the client, such as the router address and the DNS server address.

When configuring DHCP, you will need to create a DHCP *scope*, which is a group of addresses, known as a *pool*, that the DHCP server is allowed to give out to clients.
When configuring the scope, you also specify the DHCP *lease time*, or how long a client or how long a client is to have the IP address assigned to it.

Configuring shorter lease times such as one day means that more traffic is generated, because the client needs to renew the address sooner than it would if the lease time were set to seven days, for example.

### DHCP Server Configuration

```
### configure a DHCP server on a Cisco IOS device
IOS(config)# service dhcp
IOS(config)# ip dhcp pool POOL_NAME
IOS(dhcp-config)# network NETWORK_NUMBER [mask | /prefix-length]
IOS(dhcp-config)# dns-server ADDRESS [address2... address8]
IOS(dhcp-config)# default-router ADDRESS
IOS(dhcp-config)# lease {days [hours] [minutes] | infinite}
IOS(dhcp-config)# exit
IOS(config)# ip dhcp excluded-address LOW_ADDRESS [high-address]
```

* `service dhcp`
	* Enables the DHCP server and/or relay features on your IOS device. Without this command, the IOS device will not act as a server or relay agent.
	* As of IOS 12.2, this command is enabled by default.
* `ip dhcp pool`
	* Creates a name for the DHCP server address pool and places you in DHCP pool subcommand mode.
* `network`
	* Specifies the subnet network number and mask of the DHCP address pool. Also *prefix-length* specifies the number of bits that make up the address prefix.
	* The prefix is an alternative way of specifying the network mask of the client.
	* The prefix length must be preceded by a forward slash (/).
* `domain-name`
	* Specifies the domain name to be assigned to the client.
* `dns-server`
	* Specifies the IP address of a DNS server that is available to a DHCP client.
	* One IP address is required; however, you can specify up to eight IP addresses in one command line.
* `default-router`
	* Specifies the IP address of the default gateway to be assigned to the DHCP client.
* `lease`
	* Specifies the duration of the lease. IP addresses are leased to hosts, typically on a temporary basis.
	* When a client's address lease time reaches half the life of the lease, it will attempt to renew the existing addressing information it obtained previously.
	* If unsuccessful in its renewal attempt, the device will continue to attempt renewal at periodic intervals.
	* The default lease duration is one day, but other parameters can be configured for the pool, such as an TFTP server address for VoIP phones.
	* You can set the lease to infinite, which would mean the lease does not expire.
* `ip dhcp excluded-address`
	* Specifies the IP addresses that the DHCP server should not assign to DHCP clients based on the network numbers you've defined for the DHCP pool or pools.
	* These addresses are already used in the subnet, such as static addresses assigned to the switches and routing device.
	* If you are defining network numbers for your pool, make sure you exclude the network number and the directed broadcast address from the pool.
	* Notice that this command is not part of the pool configuration, but is Global Configuration command.

To view the DHCP pool information, use the `show ip dhcp pool` command:
```
IOS# show ip dhcp pool
Pool 1:
  Utilization mark (high/low) : 85 / 15
  Subnet size (first/next)    : 24 / 24
  Total addresses             : 254
  Leased addresses            : 11
  Pending event               : none
  1 subnet are currently in the pool :
  Current index        IP address range        Leased addresses
  10.1.1.12            10.1.1.1 - 10.1.1.254   11
```

With this command, you can view the total number of available addresses, the configured address range, and the number of currently leased address.

To view the current IP addresses assigned to DHCP clients, use the `show ip dhcp binding` command:
```
IOS# show ip dhcp binding
Bindings from all pools not associated with VRF:
IP address    Client-ID/        Lease expiration        Type
              Hardware address/
              User name
10.1.1.1/24   0064.6973.636f    Mar 29 2014 04:36 AM    Automatic
```

This command lists the IP addresses assigned to the clients: the IP-to-MAC address bindings.

When assigning IP addresses to clients, IOS will first ping the IP address to ensure that it hasn't been assigned to anyone else; additionally, IOS will examine its ARP table to ensure that the IP address isn't in use by any other device.

To view these conflicts, use the `show ip dhcp conflict` command

If an address conflict is detected, the address is removed from the DHCP pool and administrator must manually resolve the problem. Use the `clear ip dhcp conflict` command to clear a conflicted address form the list.
Optionally, you can use the `debug ip dhcp server` command to troubleshoot problems with the operation of DHCP on an IOS device.

### DHCP Relay Configuration

In larger networks, networking devices that need address via DHCP may not reside on the same broadcast domain as the DHCP server and therefore are unable to reach a DHCP server.
In most companies, the DHCP servers are centralized at the distribution layer or in the data center. Therefore, by default, the DHCP servers will not see the DHCP requests that the clients are advertising; routers don't forward broadcast messages to solve this issue.

The solution to this problem is to use the IOS feature *DHCP relay*: the Cisco router acts as a relay agent with the DHCP REQUEST message.

![[Pasted image 20250903103150.png]]

when the router receives the broadcasted addressing request from the client, it changes it to a unicast message, with the router as the source and the DHCP server as the destination.
The agent includes the network number to help to DHCP server choose the correct addressing pool. All messages between the agent and the DHCP server are delivered using unicast. From the client's perspective, it thinks it's actually communicating locally with the DHCP server.

```
### configure the router as a DHCP relay agent
Router(config)# service dhcp
Router(config)# interface g0/0
Router(config-if)# ip helper-address DHCP_SERVER_IP_ADDR
```

The **`service dhcp`** command is enabled by default you need to execute this only if the DHCP service has been manually disabled.
You can navigate to the interface you want to configure to listen for DHCP messages.
The **`ip helper-address`** command is used to configure the router as a DHCP relay agent and defines the DHCP server to forward DHCP messages to. You can configure this command multiple times if you have redundant DHCP servers.

If you want to verify that the DHCP relay operation is configured properly and identify the address of the DHCP server that the DHCP messages are forwarded to, you can use the `show ip interface` command:
```
VAN-R1#show ip interface
GigabitEthernet0/0 is up, line protocol is up (connected)
  Internet address is 12.0.0.1/8
  Broadcast address is 255.255.255.255
  Address determined by setup command
  MTU is 1500 bytes
  Helper address is 14.0.0.10
  Directed broadcast forwarding is disabled
```

### Exercise 13-2: Configuring DHCP Services

Configure VAN-R1 as a DHCP server to provide IP address of 12.100.0.1 up to 12.100.0.50.

```
VAN-R1# config term
VAN-R1(config)#ip dhcp pool VAN_Pool
VAN-R1(dhcp-config)#network 12.0.0.0 255.0.0.0
VAN-R1(dhcp-config)#default-router 12.0.0.1
VAN-R1(dhcp-config)#domain-name exer13-2.loc
VAN-R1(dhcp-config)#dns-server 12.0.0.100

VAN-R1(config)#ip dhcp excluded-address 12.0.0.1 12.0.0.120

### verify
VAN-R1#show ip dhcp binding
```

---

## Network Address Translation

Address translation was originally developed to solve two problems: to handle a shortage of IPv4 addresses and to hide network addressing schemes.

Most people think that address translation is used primarily to solve the first problem, However, network address translation provides solutions for many problems and has many advantages.

### Running Out of Addresses

After the huge Internet explosion during the early and mid-1990s, it was foreseen that the current IP addressing scheme would not accommodate the number of devices that would need public addresses.
A long-term solution was conceived to address this; it called for the enhancement of the TCP/IP protocol stack, including the addressing format.
This new addressing format is called IPv6. Whereas the current IPv4 addressing scheme uses 32 bits to represent addresses, IPv6 uses 128 bits for addressing, creating billions of extra addresses.

### Private Addresses

It took a while for IPv6 to become standard, and on top of this, its adaptation early on was quite slow, even with ISPs on the Internet backbone.
The main reason that is standard wasn't embraced for a long time is the success of the two short-term solutions to address shortage problem: schemes to create additional addresses, called *private addresses*, and translation of these addresses to public address using address translation.

RFC 1918, by the Internet Engineering Task Force (IETF), is a document that was created to address the shortage of addresses. When devices want to communicate, each device needs a unique IP address. RFC 1918 created a private address space that any company can use internally.

**range of private addresses**

| Class | Range                       |
| ----- | --------------------------- |
| A     | 10.0.0.0-10.255.255.255     |
| B     | 172.16.0.0-172.31.255.255   |
| C     | 192.168.0.0-192.168.255.255 |

> Private addresses are a scheme developed by IETF to overcome the limited number of available public IP addresses.
> However, private addresses cannot be placed in packets that will be routed to a public network; they must be translated first.
> Translation typically takes place on a perimeter device, such as a router of security appliance

One of the main issues addressed in RFC 1918 is that private addresses can be used only internally within a company and cannot be used to communicate to devices in a public network, such as the Internet.
If you send packets with RFC 1918 addresses in them to you ISP, for instance, your ISP will either filter them or not be able to route this traffic back to your devices.
Obviously, this creates a connectivity problem, since many of you devices with private addresses need to send and receive traffic to and from public networks.

### Address Translation

A second standard, RFC 1631, was created to solve the connectivity problem of RFC 1918.
It defines Network Address Translation (NAT), which enables you to change an IP address in a packet to a different address. When communicating to devices in a public network, your devices needs to use a source address that is a public address.
Address translation enables you to translate your internal private addresses to public addresses before these packets leave your network.

> Common devices that can perform address translation include firewalls, routers, and servers.
> Typically address translation is done at the perimeter of the network by either a router or (more commonly) a firewall.

Actually, RFC 1631 doesn't specify that the address you are changing has to be a private address it can be *any* address.
This is useful if you use randomly chose someone else's public address space but still want to connect to the Internet. Obviously, you don't own this address space, but address translation enables you to keep your current addressing scheme and have those source addresses translated to your ISP-assigned address before your packets enter the Internet.

**common reasons for using NAT:**
* You have to use private addressing because your ISP didn't assign you enough public IPv4 addresses.
* You are using public addresses but have changed ISPs, and your new ISP won't support these public addresses.
* You are merging two companies and they are using the same address space
	* for instance, 10.0.0.0 which creates routing and reachabliligy issues.
* You want to assign the same IP address to multiple machines so that users on the Internet see this offered service as a single local computer.

### Address Translation Types

Address translation comes in a variety of types, such as NAT, Port Address Translation (PAT), dynamic address translation, and static address translation.
Because of the many terms used, the concept of address translation can be confusing, especially because many people use the address translation terms incorrectly.

#### Terms and Definitions

**common terms used in address translation**

| Term                      | Def                                                            |
| ------------------------- | -------------------------------------------------------------- |
| inside                    | Addresses located inside your network                          |
| outside                   | Addresses located outside your network                         |
| local                     | IP address physically assigned to a device                     |
| global                    | Public IP address physically or logically assigned to a device |
| inside local IP address   | Inside device with an assigned private IP address              |
| inside global IP address  | Inside device with a registered public IP address              |
| outside global IP address | Outside device with a registered public IP address             |
| outside local IP address  | Outside device with an assigned private IP address             |

**some terms used for types of address translation**

| Translation Type | Desc                                                                                                                                                 |
| ---------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| simple           | One IP address is translated to a different IP address                                                                                               |
| extended         | One IP address and one TCP/UDP port number are mapped to a different IP address and, possibly, port number.                                          |
| static           | A manual address translation is performed between two addresses and possibly port numbers.                                                           |
| dynamic          | An address translation device automatically performs address translation between two addresses and possibly port numbers                             |
| NAT              | Only IP addresses are translated (not port numbers)                                                                                                  |
| PAT              | Many inside IP addresses are translated to a single IP address, where each inside address is given a different TCP or UDP port number for uniqueness |

### Implementing NAT

NAT translates one IP address to another. This can be a source address or a destination address.
Two basic implementations of NAT can be used: *static* and *dynamic*.

#### Static NAT

With static NAT, a manual translation is performed by an address translation device, translating one IP address to a different one.

Typically, static NAT is used to translate destination IP addresses in packets as they come into your network, but is's also used to translate source addresses as they leave your network.

**simple example of outside users trying to access an inside web server**
![[Pasted image 20250903123515.png]]
In this example, you want Internet users to access to access an internal web server, but this server is using a private address (10.1.1.1). If an outside user were to enter this private address in the destination IP address field, that would create a problem, because the user's ISP would drop the packet.
Therefore, the web server needs to be presented as having a public address. This is defined in the address translation device.

in this figure the web server is assigned an inside global IP address of 200.200.200.1 on the router, and your DNS server advertises this address to outside users.
When outside users send packets to the 200.200.200.1 address, the router examines its translation table for a matching entry. In this case, it sees that 200.200.200.1 maps to 10.1.1.1.
The router then changes the destination IP address to 10.1.1.1 and forwards the packet to the inside web server.

Note that if the router didn't do the translation to 10.1.1.1, the web server wouldn't know this information was meant for itself, since the outside user sent the traffic originally to 200.200.200.1.

Likewise, when the web server sends traffic out to the public network, the router compares the *source* IP address to entries in its translation table, and if it finds a match, it changes the inside local IP address (private source address, 10.1.1.1) to the inside global IP address (public source address, 200.200.200.1).
Static translations are always present in the translation table.

#### Dynamic NAT

With static address translation, you need to build the translations manually. So if you have 1000 devices, you need to create 1000 static entries in the address translation table, which is a lot of work.
Typically, static translation is done for inside resources that outside people want to access. When inside users access outside resources, dynamic translation is typically used. In this situation, the global address assigned to the internal user isn't that important, since outside device don't directly connect to your internal users they just return traffic to them that the inside user requested.

With dynamic NAT, you must manually define two sets of addresses on your address translation device: one set defines which inside addresses are allowed to be translated (the local addresses), and the other defines what these addresses are to be translated to (the global addresses).
When an inside user sends traffic through the address translation device, say a router, it examines the source IP address and compares it to the internal address pool. If it finds a match, it determines which inside global address pool it should use for the translation. If then dynamically chooses an address in the global address pool that is not currently assigned to an inside device. The router adds this entry in its address translation table, the packet is translated, and the packet is then sent to the outside world. If no matching entry is found in the local address pool, the address is not translated and is forwarded to the outside world in its original state.

When returning traffic enters your network, the address translation device examines the destination IP address and checks it against the address translation table. Upon finding a matching entry, the address translation device converts the global inside address to the local inside address in the destination IP address field of the packet header and forwards the packet to the inside network.

Dynamic NAT translations are added to the translation table when a source matches the dynamic NAT policy configuration and are removed once an idle timer is reached.
All traffic from a source is translated to the same destination, no matter how many connections are opened from the source.

### Port Address Translation

One problem with static or dynamic NAT is that it provides only a one-to-one address translation. Therefore, if you have 5000 internal devices with private addresses, and all 5000 devices try to reach the Internet simultaneously, you need 5000 public address in your inside global address pool.
If you have only 1000 public addresses, only the first 1000 devices are translated and the remaining 4000 won't be able to reach outside destinations.

To overcome this problem, you can use *address overloading*. Many other terms are used to describe this process, including Port Address Translation (PAT) and Network Address Port Translation (NAPT).

Dynamic PATs are added to the translation table when a new connection matches the dynamic PAT policy configuration and are removed once an idle timer is reached or the connection ends.
For example, with TCP, the connection ends when the FIN and FIN-ACK segment messages are seen, or a hard reset (RST) is performed. Most translation devices are smart enough to use the same PAT address for multiple connections opened to the same destination.
For example, if you download a web page from a web server, that typically takes dozens of connections. In this situation, most translation devices, will use the same source address for all these translations.
This ensures that the destination server is seeing all these connections from the same source.

> PAT or dynamic NAT address overloading, enables you to use the same global IP address for all internal devices, where the source port in a TCP or UDP header is used (possibly changed) to differentiate among the different translated connections.
> Dynamic NAT with overload is used when more devices need to access the Internet than you have public IP addresses assigned by you ISP.

#### Same IP Address, Different Port Numbers

With PAT, all devices that go through the address translation device have the same global IP address assigned to them, so the source TCP or UDP port numbers are used to differentiate the different connections.
If two devices have the same source port number, the translation device changes one of them to ensure uniqueness.
When you look at the translation table in the address translation device, you'll see the following items with PAT is performed on a packet:

* Inside local IP address (original source Private IP)
* Inside local Port number (original source port number)
* Inside global IP address (translated public source IP)
* Inside global port number (new source port number)
* Outside global IP address (destination public address)
* Outside global Port number (destination port number)

One main advantage of NAT over PAT is that NAT will basically work with most types of IP connections. Since PAT relies on port numbers to differentiate connections, PAT works only with TCP and UDP; however, many vendors, also support Internet Control Message Protocol (ICMP) with PAT using a proprietary translation method.

> Most vendors use the sequence number in an ICMP echo message, along with the source address, to uniquely identify a translation for ICMP traffic.

#### Example Using PAT

![[Pasted image 20250903151408.png]]

both PCs execute a telnet to 199.199.199.1, and both of these connections use a source port number of 50,000.
When these connections reach the address translation device, the device performs its PAT translation.
For the first connection, say PC-A, the source IP address (inside local) is changed to 200.200.200.7 (inside global). Since this is the first connection and the source port is not found in the translation table, the source port number is left as is.
When PC-B makes a telnet connection to the remote device, since it is using a source port number (50,000) already in the table for a connection to the telnet server, the address translation device changes it from 50,000 to an unused number in the translation table (for example, 50,001).
Therfore, when traffic is sent from the telnet server to the inside PCs, the address translation device will be able to differentiate the two connections and undo the translation correctly by examining both the destination IP address and port number in the telnet relay packets: the destination port of 50,000 will be redirected to PC-A and the destination port of 50,001 will be changed back to 50,000 and redirected to PC-B.
In both cases, the destination IP address is also changed to the inside local address of the device to which the packet will be forwarded.

> Note that you don't have to restrict yourself to one type of address translation process.
> For instance, PAT is typically used for inside-to-outside connections, while static NAT is used for outside-to-inside connections.

#### Port Address Redirection

The previous example showed PAT being carried out dynamically by the address translation device. In some situations, however, this will not work. For instance, your ISP may assign a single public IP address. You need to use this with PAT to enable inside users to access outside resources.
However, you'll have a problem if you want outside users to access an internal service, such as a web server.
Dynamic PAT, unfortunately, won't work in this situation.

Another solution to this problem is available: static PAT, often called *port address redirection (PAR)*.
Assume that your ISP assigned you a single public IP address: 199.199.199.1. You need to use this address for inside users to access the outside world, but you still need the outside world to access an internal web server.
With static PAT, you set up your address translation device to look not only at the destination IP address (199.199.199.1), but also at the destination port number (80 for a web server). You create a static PAT entry such that when the address translation device sees this combination of address and port numbers, the device translates it to the inside local IP address and, possibly, the port number used for the service on this inside device.

For example, assume you are given the network shown back. In this example, your ISP has assigned you a single IP address, 200.200.200.1, and this address must be configured on your router's S0 interface. This presents a problem in this example, since you have an internal web server that you want external users to access.
Port address redirection can be used to overcome this problem. You would set up a static PAT entry on your router that would take TCP traffic sent to 200.200.200.1 on port 80 and redirect to 10.1.1.1 on port 80. Without PAR, the router would try to process the web connection itself since this IP address is assigned to its own local interface.

### Advantages of Address Translation

network address translation devices are typically used to give you an almost inexhaustible number of address as well as to hide your internal network addressing scheme.

Another advantage of address translation is that if you change ISPs or merge with another company, you can keep your current addressing scheme and make any necessary changes on your address translation device or devices, making your address management easier.

Another big advantage of address translation is that it gives you tighter control over traffic entering and leaving your network.
For example, if you are using private addresses internally, all traffic entering and leaving must pass through an address translation device. Because of this restriction, it is much easier to implement your security and business policies.

### Disadvantages of Address Translation

Even though network address translation solves many problems and has many advantages, it also has its share of disadvantages.

* Each connection has an added delay
* Troubleshooting is more difficult
* Not all applications work with address translation

Because address translation changes the contents of packets and, possibly, segment headers, as well as computing any necessary new checksum values, extra processing is required on each packet.
This extra processing, obviously, will affect the throughput and speed of your connections. The more packets that pass through your address translation device needing translation, the more likely your users will notice the delay. Therefore, choosing the appropriate product for address translation becomes very important.

Whenever problems arise with connections involving address translation, it can be difficult to troubleshoot them.
It is difficult to track down the real source and destination of a connection you have to log into your address translation device and look at your translation tables. And if the packet is going through multiple layers of translation, possible at both the source and destination sites, this can be a hair-pulling experience.
Also, even through one of the advantages of address translation is that it hides external hacker can more easily hide hid identity and IP address by sending his packets through a translation device or multiple translation devices.

Probably the most difficult issue with address translation is that not all applications will work with it.
For instance, some applications embed IP addressing or port information in the actual data payload (such as FTP), expecting the destination device to use this addressing information in the payload instead of what is in the packet and segment headers. This can pose a problem with address translation, since address translation, by default, doesn't translate data payload information, only header information.
Multimedia and NetBIOS applications are notorious for embedding addressing information in data payloads. In some instances, some vendors' address translation devices can detect this process for certain applications and fix it when building the appropriate translation in the translation table.
For instance, Cisco routers with the IOS firewall feature set and ASA security appliances support a fix-up process that covers many of these application issues, including embedded addressing information. However, if your product doesn't support this feature, you'll need to disable address translation for the affected device.

### NAT Configuration

NAT can be static or dynamic. The configuration process is similar for both types. Probably the most difficult thing about configuring address translation is understanding the difference between the terms *inside* and *outside*.
These terms refer to where your devices are located and where the external network is. This is important when it comes to the configuration of address translation. On the IOS device, you must perform two basic configuration steps:

* Define the address translation type (Global Configuration Mode commands)
* Define the location of device (Interface Subconfiguration Mode comands)

#### Configuring Static NAT

static NAT is typically used when devices on the outside of your network want to access resources, such as web, DNS, and e-mail servers, on the inside.

```
Router(config)# ip nat inside source static
                    INSIDE_LOCAL_SOURCE_IP_ADDRESS
                    INSIDE_GLOBAL_SOURCE_IP_ADDRESS
Router(config)# ip nat outside source static
					OUTSIDE_GLOBAL_DEST_IP_ADDR
					OUTSIDE_LOCAL_DEST_IP_ADDR
```

The **`inside`** and **`outside`** parameters specify the direction in which translation will occur.

For instance, the `inside` keyword specifies that the inside source local IP addresses are translated to an inside global IP address when *leaving* the network; and the destination global IP addresses are translated to inside local IP addresses when *entering* your network.

the `outside` keyword changes the outside *destination* global IP address to an outside local address (the `ip nat outside source static` command is used when you are connecting two company networks together and their addresses overlap).

After you configure your translations, you must specify which interfaces on your router are considered to be on the inside and which are on the outside with the following configuration:

```
Router(config)# interface type [slot_#/]port_#
Router(config-if)# ip nat {inside | outside}
```

Specify `inside` for interfaces connected to the inside of your network `outside` for interfaces connected to external networks, such as your ISP.

**simple static NAT**
![[Pasted image 20250906095515.png]]

In this example, an internal web server (192.168.1.1) will be assigned a global ip address of 200.200.200.1

```
Router(config)# ip nat inside source static 192.168.1.1 200.200.200.1
Router(config)# interface ethernet 0
Router(config-if)# exit
Router(config)# interface serial 0
Router(config-if)# ip nat outside
```

The **`ip nat inside source static`** command defines the translation.
The **`ip nat inside`** and **`ip nat outside`** commands specify what interfaces are on the inside (E0) and what interfaces are on the outside (S0).
Note that any packets that don't match the address translation rule will pass between these two interfaces untranslated. If you want only translated packets to pass between these interfaces, you'll need to configure an appropriate ACL or ACLs.

> Use the `ip nat inside` or `ip nat outside` Interface Subconfiguration mode command to specify which interfaces are considered inside and which are outside.

#### Configuring Dynamic NAT

When you are configuring dynamic NAT, you'll need to configure three things: what inside addresses are to be translated, what global addresses will be used for the dynamic translation, and what interfaces are involved in the translation.

To specify what internal devices will have their source address translated, use the following command:
```
Router(config)# ip nat inside source
					list STANDARD_IP_ACL_NAME_OR_#
					pool NAT_POOL_NAME
```

The **`ip nat inside source list`** command requires you to configure a standard IP ACL that has a list of the inside source addresses that will be translated any addresses listed with a `permit` statement will be translated, and any addresses lists with a `deny`, or the implicit deny, statement will not be translated.

To create the pool of source inside global IP addresses, use this command:
```
Router(config)# ip nat pool NAT_POOL_NAME
							BEGINNING_INSIDE_GLOBAL_IP_ADDR
							ENDING_INSIDE_GLOBAL_IP_ADDR
							netmask SUBNET_MASK_OF_ADDR
```

the pool name that you specify references the inside addresses that will be translated from the `ip nat inside source list` command.
Next, list the beginning and ending IP addresses in the pool, followed by the subnet mask for the addresses.

Once you have done this, the last thing you need to configure is which interfaces are considered to be on the inside and outside of your network.
Use the **`ip nat inside`** and **`ip nat outside`** interface Subconfiguration mode commands.

> The `ip nat inside source list` command specifies which internal addresses will be dynamically translated. that translation takes place only when a packet matches a **permit** statement in the ACL: matching a **deny** statement or the implicit deny attempts the packet from translation.
> The `ip nat pool` command specifies the global addresses to use when performing dynamic translation of local addresses.

```
Router(config)# ip nat inside source list 1 pool nat-pool
Router(config)# access-list 1 permit host 192.168.1.10
Router(config)# access-list 1 permit host 192.168.1.11
Router(config)# ip nat pool nat-pool 200.200.200.2 200.200.200.3 netmask 255.255.255.0
Router(config)# interface ethernet 0
Router(config-if)# ip nat inside
Router(config-if)# exit
Router(config)# interface serial 0
Rotuer(config-if)# ip nat outside
```

The **`ip nat inside source list`** command specifies the inside source IP addresses that will be translated.
Notice that these are addresses in ACL 1 (192.168.1.10 and 192.168.1.11). They are associated with the global address pool called nat-pool.
The `ip nat pool` command specifies the global addresses that the inside source address will be translated to.
And finally, ethernet 0 is specified as being on the inside and serial 0 is on the outside.

### PAT Configurations

This configuration, which is very similar to configuring dynamic NAT, requires three basic translation commands.
The first thing you specify is which inside device will have their source address translated. You'll use the same command that you used in dynamic NAT, but you'll add the `overload` parameter to specify that PAT is to be performed:

```
Router(config)# ip nat inside source
					list STANDRARD_IP_ACL_#
					pool NAT_POOL_NAME overload
```

Next, you specify the global pool to use. Again, you'll use the same command you used in dynamic NAT:

```
Router(config)# ip nat pool NAT_POOL_NAME
							BEGINING_INSIDE_GLOBAL_IP_ADDR
							ENDING_INSIDE_GLOBAL_IP_ADDR
							netmask SUBNET_MASK_OF_ADDR
```

you can specify more than one address to use in PAT, or you can specify a single IP address (use the same address for the beginning and ending address).

And last, you have to tell the IOS which interfaces are inside and outside, respectively, in terms of the **`ip nat inside`** and **`ip nat outside`** commands.

```
# 200.200.200.1 is being used in the static translation for the internal server.
# IP addr is placed in the address pool (200.200.200.2)
# address translation is restricted to performing PAT for only two devices: 192.168.1.10 and 192.168.1.11

Router(config)# ip nat inside source 
					list 1 
					pool nat-pool overload
Router(config)# access-list 1 permit host 192.168.1.10
Router(config)# access-list 1 permit host 192.168.1.10
Router(config)# ip nat pool nat-pool 200.200.200.2
						200.200.200.2
						netmask 255.255.255.0
Router(config)# interface ethernet 0
Router(config-if)# ip nat inside
Router(config-if)# exit
Router(config)# interface serial 0
Router(config-if)# ip nat outside
```

### Address Translation Verification

Once you have configured address translation, you can use many different commands to verify and troubleshoot the operation address translation on your router.

For instance, if you want to see the address translation table on your router, use the **`show ip nat translations`** command.

```
Router# show ip nat translations
Pro  Inside global  Inside local  Outside local  Outside global
---  200.200.200.1  192.168.1.1   ---            ---
---  200.200.200.2  192.168.1.2   ---            ---
```

In this example, two addresses are being translated: 192.168.1.1 (inside local) to 200.200.200.1 (inside global) and 192.168.1.2 (inside local) to 200.200.200.2 (inside global).

Notice no protocol is listed (Pro) or port numbers, indicating that these are NAT translations, not PAT.

```
# example of show command with PAT translation
Router# show ip nat translations
Pro  Inside global       Inside local       Outside local  Outside global
tcp  200.200.200.1:1080  192.168.1.1:1080   201.1.1.1:23   201.1.1.1:23
tcp  200.200.200.2:1081  192.168.1.2:1080   201.1.1.1:23   201.1.1.1:23
```

In this example, both 192.168.1.1 and 192.168.1.2 are accessing the same outside device (201.1.1.1) using telnet.

Notice that both also use the same source port number (1080 under the Inside local). The IOS has noticed this and changed the second connection's source port number from 1080 to 1081 to differentiate the two connections.

You can even see address translations statistics on your router with `show ip nat statistics`

```
Router# show ip nat statistics
Total translations: 2 (0 static, 2 dynamic; 0 extended)
Outside interfaces: Serial0
Inside interfaces: Ethernet0
Hits: 98 Misses: 4
Expired translations: 1
Dynamic mappings:
-- Inside Source
access-list 1 pool nat-pool refcount 2
pool nat-pool: netmask 255.255.255.255
start 200.200.200.10 end 200.200.200.254
type generic, total addresses 12, allocated 1 (9%), misses 0
```

In this example, there are currently two dynamic translations in the translation table.
Hits refers to the number of times the IOS looked into the translation table and found a match (an existing translation that can be used for the packet), while Misses indicates the number of time the IOS looked in the table for a translation, didn't find one, and had to create an entry in the translation table for the packet.

For dynamic entries in the translation table, you can clear all the entries, or specific entries, using the following commands:
```
Rotuer# clear ip nat translation *
Router# clear ip nat translation inside
						GLOBAL_IP_ADDR LOCAL_IP_ADDR
Router# clear ip nat translation outside
						GLOBAL_IP_ADDR LOCAL_IP_ADDR
Router# clear ip nat translation protocol inside
						GLOBAL_IP_ADDR GLOBAL_PORT
						LOCAL_IP_ADDR LOCAL_PORT
```

The first command clears all dynamic entries in the table. Note that to clear static entries, you need to delete your static NAT configuration commands from within configuration mode.

In addition to **`show`** commands, you can also use **`debug`** commands for troubleshooting. The `debug ip nat` command, for instance, will show the translations the IOS is doing every translated packet. This is useful in determining whether the IOS is translating your packet and segment header addressing information correctly.
Please note that on a busy network, this command will require a lot of CPU cycles on your router.

> show ip nat translation command to display the router's translations.
> clear ip nat translation command to clear dynamic translations from the translation table.
> The debug ip nat command shows the router performing address translation in a real-time fashion.

### Exercise 13-3: Configuring NAT Overloading

![[Pasted image 20250906162510.png]]



### Address Translation Troubleshooting

---

## Quality of Service

Networks today require the capabilities to carry different types of traffic, such as regular data, voice and video, and must somehow ensure that all the data reaches the destination in a timely manner.
Network administrators have to ensure that adequate bandwidth is given to critical business applications or applications that require more bandwidth, such as voice and video applications.

*Quality of Service (QoS)* has a set of mechanisms that enable network devices to make decisions related to bandwidth and performance in order to optimize network traffic.

**router with three Gigabit interfaces connected to LANs**
![[Pasted image 20250906193426.png]]

Let's assume there are many hosts on each of these LANs that need to send lots of traffic out to the internet on the Fast Ethernet interface.
The problem is that you have all this traffic coming from three Gigabit interfaces trying to funnel through the lower bandwidth of the 100Mbps connection going to the internet.
As the administrator for this network you may need to optimize traffic to ensure that critical application data gets a higher priority over other traffic.

The general idea of QoS is that when a packet is received by a router, or a frame is received by a switch, it can be marked for a particular type of service that is need by network devices in order to determine the level of priority to give to the packet or frame.

### Forwarding Per-Hop Behavior and QoS Terminology

Cisco uses differentiated services, or *DiffServ*, as a tool to achieve QoS on the network.

DiffServ as technology uses per-hop behavior (PHB). which is used to determine the priority assigned to a packet when traveling through a router (a hop).

You should be familiar with a number of terms and concepts when discussing DiffServ (and QoS).

#### Classification and Marking

The first step to implementing QoS is that packets or frames must be classified as a particular type of traffic and then marked so that the networking devices can perform QoS actions on those packets.

*Classification* of packets is done by the QoS features of a device analyzing the header of the packet to determine the type of traffic it is. For example, QoS can use an ACL to identify packets coming from a specific network being high priority traffic.

After the packet or frame has been classified, it is then *marked* to achieve a type of service. The packet or frame is marked by adding information to the header of the packet or frame. With IP packets, there is a *Type of Service* (ToS) field in the packet that is marked with a *Differentiated Service Code Point* (DSCP).
DSCP codes are used by DiffServ to indicate what type of actions network devices should take with a packet.

**Examples of the DiffServ DSCP codes**
* **Expedited Forwarding (EF)**
	* This code is applied to packets that require low latency and low packet loss.
	* voice traffic would use EF
	* IP phones mark their VoIP packets with EF by default
* **Assured Forwarding (AF)**
	* These codes are used to mark queues for a packet and their drop priority.
	* The format for the code is AF*XY*, where X is the queue (1 to 4) for the packet, and Y is the drop priority value 1 to 3.
* **Class Selector (CS)**
	* This field applies the packet to a class.
	* The class is identified with a value of CS*n*, where *n* is a number from 0 to 7.

In a layer 2 frame, a field in the 802.1Q header, the *Class of Service* (CoS) field, is marked by a layer 2 device using trunking to indicate any actions that devices should take with the frame.
Note that wireless traffic is layer 2 traffic as well, but it uses a ToS field instead of CoS

#### Queuing

When a device needs to deliver a message and the interface is busy, the device will need to place the message in queue. With QoS, each classification of traffic can be placed into different queues, with a scheduler determining when the traffic in a queue can be forwarded, typically based on priority.

#### Congestion

QoS offers features that enable you to avoid congestion on a network link.

*Congestion* occurs, for example, when traffic coming from three Gigabit interfaces is trying to go out one Fast Ethernet interface at 100 Mbps.
To handle congestion on a link, such as WAN link, you can use priority features and queueing features to ensure that delay-sensitive traffic is handled first on a congested link.

#### Policies

You can use policies to limit the bit rate of a link like the way ISPs limit the bit rate of your Internet traffic based on what you paid for.

Using policies, you can monitor traffic and compare it against a traffic contract, typically referred to as the *committed information rate (CIR)*.
When traffic exceeds the contracted bit rate, you can drop the extra traffic. When monitoring the traffic bit rate, you can take a number of actions, such as enabling the packet to continue, dropping the packet, or marking the packet with a different DSCP value.

#### Shaping

Shaping is a QoS feature that enables administrators to enforce lower bit rates on an interface than what it is capable of handing.

Shaping is typically used by ISPs to enforce bandwidth utilized by customers based on their subscription.
Shaping can be used by administrators to limit bandwidth used by different departments.
Shaping is similar to policies, expect with shaping, you typically buffer the over-usage traffic for later delivery instead of dropping it.

---

## Logging and Syslog

An *event* is something that happens (such as someone logging in); an *incident* is an issue with what happend (an unauthorized login access was detected).

Logging plays a key role in your management and security solution. Even through SNMP supports traps, the number of traps you can use is limited: logging supports many more types and kinds of messages than SNMP traps.

Logging to a syslog server makes it easier for you to manage and keep a historical record of your logging information from a multitude of devices.
Syslog uses UDP and runs on port 514.
Unfortunately, all logging information is sent in clear text, it has no packet integrity checking, and it is easy for a hacker to send false data to the syslog server. Therefore, it is highly recommended that you encrypt information between your network devices and the syslog server and that you set up a filter on the syslog server to accept only logging information from particular IP addresses.

By default, logging messages are sent to the router's console port; however, the following locations are also supported: terminal lines, internal memory buffer, SNMP traps, and a syslog server.
Common destinations used by administrators are logging buffer (RAM), the console terminal, and syslog servers.
Syslog is most common, since it enables you to centralize (aggregate) logging messages easily on a server.
The advantage of using syslog is that messages can be stored on a hard drive on the syslog server instead of on the router itself, freeing up router resources.

### Logging Messages

All of Cisco's log messages can contain the following information:

* **528Timestamp**
	* The date and time of the occurrence (optional)
* **Log message name**
	* The name of the message
* **Severity level**
	* The severity level of the log message, embedded in the log name
	* `%SYS-5-CONFIG_I`, where 5 is the severity level
* **Message text**
	* A very brief description of the event

```
Nov 19 12:30:00 EST: %SYS-5-CONFIG_I: Configured from console by vty0 (10.0.11.11)
```

In this example, the timestamps have been enabled (they are disabled by default).
This is followed by the category of logging (SYS indicates a system message), the severity level (5), and the subcategory (CONFIG) indicates a change on the router).
Last is the message text.

### Logging Severity Levels

**the severity levels of log messages**

| level | name          | desc                                                                                                |
| ----- | ------------- | --------------------------------------------------------------------------------------------------- |
| 0     | Emergency     | The router is unusable (IOS can't load)                                                             |
| 1     | Alerts        | The router needs immediate attention; for instance, the temperature is too high                     |
| 2     | Critical      | There is a critical condition; for instance, the router is running out of memory.                   |
| 3     | Errors        | An error condition exists, such as an invalid memory size.                                          |
| 4     | Warnings      | A warning condition exist; for instance, a crypto operation failed.                                 |
| 5     | Notifications | A normal event occurred; for instance, an interface changed state                                   |
| 6     | Informational | This is an informational message; for instance, a router dropped a packet because of an ACL filter. |
| 7     | Debug         | This is the output of debug commands                                                                |

### Logging Configuration

```
Router(config)# logging [host] {hostname | IP_ADDR}
Router(config)# logging trap LEVEL_NAME_OR_#
Router(config)# logging console LEVEL_NAME_OR_#
Router(config)# logging buffered LEVEL_NAME_OR_#
Router(config)# logging monitor LEVEL_NAME_OR_#
Router(config)# logging facility FACILITY_TYPE
Router(config)# logging source-interface INTERFACE_NAME
Router(config)# logging on
```

* **`logging [host]`**
	* Defines a syslog server to which log messages are sent.
* **`logging trap`**
	* Defines the severity level at which to log messages
	* This command must specify the name or number of the level.
	* The level indicates any message at that level or higher.
	* if you set the level to 3, messages from levels 1 to 3 would be logged.
* **`logging console`**
	* Defines the logging level for the console line
* **`logging buffered`**
	* Defines the logging level for the log messages stored in the router's RAM
* **`logging monitor`**
	* Defines the logging level for log messages sent to the router's other lines, such as virtual type terminals (VTYs).
* **`logging facility`**
	* Directs logging information to the appropriate file on the syslog server.
	* The default is local7, but this can be changed.
	* The facility type enables you to keep different log files for different devices on the same syslog server, making it easier to find log messages.
* **`logging source-interface`**
	* Specifies which interface on the router will be used to reach the syslog server.
	* By default, the router will use its routing table to determine what interface, and thus what source IP address to use, when sending a log message.
	* You may want to configure this command if the router can use multiple interfaces to reach the log server, with the possibility that multiple source IP addresses could be used, but the syslog server is allowing log messages only from one of the router's IP addresses.
* **`logging on`**
	* You must enable logging with this command.
	* However, this is not necessary for log messages sent to the console, which is enabled by default.

By default, Cisco IOS devices do not include the local timestamp (date and time) with the syslog messages sent to the syslog server: they rely on the server attaching its time to the message.

To have the IOS device include its own local time:
```
Router(config)# service timestamps {log | debug} datetime [msec]
```

You can add timestamps to log messages or the output of `debug` commands.
The `msec` parameter specifies that the current millisecond value should be included in the router's timestamped log message.

### Logging Verification

Use the `show logging` command to verify your configuration.

### Logging CLI Example

![[Pasted image 20250907150236.png]]

```
Router(config)# logging 10.0.0.1
Router(config)# logging trap 5
Router(config)# logging source-interface fa0/0
Router(config)# logging on
```

---

## Working with NetFlow

NetFlow is a Cisco-proprietary technology used to classify and identify traffic and to provide statistics for the traffic.

Originally it was meant for QoS and traffic management purposes, but it can be used to detect attacks by looking for anomalies in traffic sessions.

**Common uses for NetFlow**
* Network traffic accounting
* Usage-based network billing
* Network capacity and planning
* Security
* Denial-of-service (DoS) monitoring capabilities
* Network monitoring and troubleshooting

> NetFlow enables administrators to identify applications causing network congestion, diagnose slow performance, and verify that an application receives the appropriate amount of bandwidth based on its class of service (CoS).
> Benefits include network, application, and user monitoring, network planning, and accounting/billing.

NetFlow is like a telephone bill: it shows you who (source) is connecting to whom (destination), what application and/or protocol they are using, how long the connection lasted, how much information was transmitted across the connection (source versus destination), and much, much more.

> Cisco relies on the use of NetFlow, but there are other, similar solutions in the marketplace.
> The open standard sFlow is commonly supported by other vendors.

### NetFlow Architecture

a *flow* is basically a session between two devices: the parameters associated with a connection involving information in the layer 3 and layer 4 headers, as well as some other components, to identify a flow.

A flow may involve the following:
* Layer 3 protocol
* Source and destination IP addr
* Source and destination port numbers
* CoS or ToS information
* Input interface name
* Flow timestamp
* Next-hop IP address
* TCP flags

Minimally, a flow must contain a source IP address, a destination IP address, and an ingress interface.

Cisco uses application-specific integrated circuits (ASICs) to capture the flow information.
The technology used by the ASICs, Cisco Express Forwarding (CEF), implements many features to offload processing of the CPU to an interface or a card.
The most common feature of CEF is to offload forwarding of the traffic from the CPU to the ASIC.
Another function of CEF is to create flow information for NetFlow.
Even though ASICs capture the flow information, the IOS device's CPU must be involved in forwarding the flow information to a NetFlow collector: this can be very CPU-intensive.

Some NetFlow information can be examined locally on the IOS device; however, to gather and examine NetFlow information over long periods of time, you need a NetFlow collector (basically a logging server that understands NetFlow flow information).

**versions**

| ver | Desc                                                                                                                                                   |
| --- | ------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 1   | Original version of NetFlow                                                                                                                            |
| 5   | The standard and most common implementaion                                                                                                             |
| 7   | Specific to the 6500, 6800, and 7600 products                                                                                                          |
| 8   | Reduces resources usage (summarized flow information)                                                                                                  |
| 9   | Flexible file format to support additional fields and use for IPv6, multiprotocol label switching (MPLS), Border Gateway Protocol (BGP), and multicast |

The most common implementation of NetFlow is version 5, but the most flexible is version is 9.

When sending NetFlow information to a collector, you must identify the version used on both the IOS device and collector so that both can understand the flow information.
The NetFlow information is sent using UDP as a transport protocol.

Many, many products in the marketplace can perform the function of a NetFlow collector.
NetFlow collector is a Cisco product that provides a GUI to examine flow information and statistics in a visual format, including bar charts, pie charts, and histograms, to name a few.

One concern with a collector is the number of devices and amount of flow information the collector will receive: you can quickly overburden a collector if you send too much information to it.

> Minimally, a flow must contain a source IP address, a destination IP address, and an ingress interface.
> Traffic is considered in the same flow if the packets contain the same IP addressing, port numbers, and layer 3 protocol information.
> Sending flow information to a collector can be CPU-intensive. One concern with a collector is the number of devices and amount of flow information the collector will receive.
> Version 5 is the most common implementation of NetFlow.

### NetFlow Configuration

To configure NetFlow, you must perform the following four tasks:

1. Enable data capturing on an interface: ingress is incoming and egress is outgoing.
2. Define the IP address and UDP port of the NetFlow collector.
3. Optionally identify the version of NetFlow to export the flow information.
4. Verify the NetFlow configuration, operation, and statistics.

> Even though ASICs capture the flow information using CEF, the flow information must be stored in RAM.
> IOS enables you to define memory limits for NetFlow if you have limited memory on your IOS device. The default cache size depends on the particular Cisco product and platform.

```
## Enable NetFlow, export the information to a NetFlow collector
IOS(config)# ip cef
IOS(config)# interface TYPE NUMBER
IOS(config-if)# ip flow {ingress | egress}
IOS(config-if)# exit
IOS(config)# ip flow-export version {1 | 5 | 9}
IOS(config)# ip flow-export destination MGMT_IP UDP_PORT
```

NetFlow versions very based on device and code. As of IOS 12.4, for example, routers support only version 1, 5 and 9.

Most Cisco management stations, acting as collectors, listen up UDP port 9997 by default. Flow monitors are NetFlow components that enable you to define global NetFlow parameters, such as the cache size and the number of unique flow records to collect.
This configuration is then applied to a respective interface.

### NetFlow Verification

```
# verify that it is enabled on the respective interface
IOS# show ip interface g1/0/0
.
.
.
Input features: Ingress-NetFlow, MCI check
Output features: Egress-Netflow

# verify the NetFlow configuration and get an overall status of the NetFlow operation
Router# show ip flow export
Flow export v5 is enabled for main cache
  Exporting flows to 10.51.12.4 (9991)
  Exporting using source IP address 10.1.97.17
  Version 5 flow records
  11 flows exported in 8 udp datagrams
  0 flows failed due to lack of export packet
  0 export packets were sent up to process level
  ...
  
# To view a summary of the flow information captured by IOS device
Router# show ip cache flow
```

---

## Chapter Review

---

## Quick Review