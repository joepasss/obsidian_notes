
the next generation of TCP/IP: IP version 6 (IPv6)

Because of the many deficiencies found in IPv4, as well as the poor scalability for hierarchical addressing found in IPv4, IPv6 was developed to meet the rapidly growing needs to small companies, corporations, and the explosive growth of the internet, especially in emerging markets such as China and India.

## Necessity of IPv6

An IPv4 address is 32 bits in length; that means there are 2^32 actual IP addresses, which equals 4.3 billion addresses.

Not all of these available, however: only 3.7 billion of these are actually usable. Many addresses are reserved, such as research (239-254), broadcast (255), multicast (224-239), private (10, 172.16 and 192.168), and loopback addresses (127).
And, of course, many of the useable addresses are already assigned, leaving very, very few addresses for the new growth.

Unlike 32-bit IPv4 addresses, IPv6 uses a 128-bit address. This allows for 3.4 x 10^38 addresses, which is enough for many IP addresses for each person on Earth, and probably on multiple planets.

### Growth Issues

During the early-to-mid-1990s, concern began to grow about the diminishing number of IPv4 addresses. The temporary solution to this problem was to set aside an address space, called *private addresses*, which anyone could use in a public network. (defined in IETF RFC 1918: 10.0.0.0/8, 172.16.0.0-172.31.255.255, and 192.168.0.0-192.168.255.255)

To access a public network, address translation is used to translate the private addressing information to a public address, commonly with static Network Address Translation (NAT) translations for internal services and dynamic overloading (PAT) for user connection.

Many changes in the marketplace, however, are quickly reaching the point where address translation won't be enough: there won't be any public addresses left to translate to.

* Currently more than 3 billion people are connected to the Internet, and this is exponentially increasing based on fast-emerging technical markets.
* More than 2 billion smart phones, tablets, and similar devices offer common data services such as e-mail and web browsing, and this number is expected to grow as more and more businesses implement mobile applications.
* More data services are being offered on consumer products, such as automobiles, household appliances, and industrial devices, and this number is expected to grow into the billions.

it's not matter of *if* public addresses are going to be depleted, and not even *when* it's going to happen, but *how soon* in the near future this is going to happen.

Because IPv4 is only a 32-bit address, and because the designers did not foresee the growth of the internet, we have run out of IPv4 address.

The goal of IPv6 is to increase the address space (it is a 128-bit address space), which gives us more than enough IPv6 address for everyone in the world to use and handles future growth.

### IPv6 Features

Obviously, the replacement for IPv4 needs to support enough addresses for this growing demand, but it also needs to provide ease of use and configuration, enhanced security, and the ability to interoperate with IPv4 as the transition takes place.

**IPv6 built in features**
* **Very large address space**
	* IPv6's large address space deals with global growth, where route prefixes can be easily aggregated in routing updates.
	* Support for multihoming to Internet service providers (ISPs) with a single address space is easily accomplished.
	* Autoconfiguration of addressing information, including the capability of including Media Access Control (MAC) address in the IP address, as well as plug-and-play options, simplifies address management.
	* Renumbering and modification of addresses is easily accommodated, as is public-to-private readdressing, without involving address translation.
* **Security**
	* IP security (IPsec) is built into IPv6, whereas it is an awkward add-on in IPv4.
	* With IPv6, two devices can dynamically negotiate security parameters and build a secure tunnel between them with no user intervention.
* **Mobility**
	* With the growth of mobile devices, such as smart phones and tablets, devices can roam between wireless networks without breaking their connections.
* **Streamlined encapsulation**
	* The IPv6 encapsulation is simpler than that of IPv4, providing faster forwarding rates by routers and better routing efficiency.
	* No checksums are included, reducing processing on endpoints. No broadcast are used, reducing utilization of devices within the same subnet.
	* QoS information is built into the IPv6 header, where a flow label identifies the traffic; this alleviates intermediate network devices from having to examine contents inside the packet, the TCP/UDP headers, and payload information to classify the traffic for QoS correctly.
* **Addressing capabilities**
	* As with IPv4, addresses can be assigned statically or obtained via Dynamic Host Control Protocol (DHCPv6).
	* However, unlike IPv4, IPv6 supports stateless autoconfiguration, which enables a device to acquire addressing automatically without implementing a DHCP server solution.
* **Transition capabilities**
	* Various solutions exist to enable IPv4 and IPv6 to coexist successfully when migrating between the two.
	* One method, dual stack, enables you to run both protocols simultaneously on an interface of a device.
	* A second method, tunneling, enables you to tunnel IPv6 over IPv4, and vice versa, to transmit an IP version of one type across a network using another type.
	* Cisco supports a third method, Network Translation-Protocol Translation (NAT-PT), to translation between IPv4 and IPv6 (sometimes the term *proxy* is used instead of Protocol).

---

## IPv6 Addressing

### IPv6 Address Format

Whereas IPv4 addresses use a dotted-decimal format, in which each byte ranges from 0 to 255, IPv6 addresses use eight sets of four hexadecimal addresses (16 bits in each set), separated by a colon (:),
```
xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx
```

This notation is commonly called *string* notation. Each hexadecimal value ranges from 0 to 9 and A to F (0-F).

**some important items concerning IPv6 addresses:**
* Hexadecimal values can be displayed in either lower- or uppercase for the characters
* A leading zero in a set of numbers can be omitted; (0012 or 12)
* If you have successive fields of zeros in an IPv6 address, you can represent them as two colons (::)
* 0:0:0:0:0:0:0:5 could be represented as ::5; and 2000:C67:0:0:8888:9999:1111:0 could be represented as 2000:C67::891::00 would be invalid, since :; appears more than once in the address.
* An unspecified address is represented as ::, since it contains all zeros.

### Calculating Hex Addresses

![[Pasted image 20250908154906.png]]


**HEX -> DEC**
fe80 = 15 x 16^3 + 14 x 16^2 + 8 x 16^1 + 0 x 16^0
     = 61440 + 3584 + 128 + 0
     = 65152

**HEX -> BIN**
fe80 = 1111 1110 1000 0000

### Types of IPv6 Addresses

many types of IPv4 addresses exits: unicast, broadcast, multicast, research, private, and so on. IPv6 also has different types of addresses

**Three main types of IPv6**
* **Anycast**
	* This is very different from an IPv4 broadcast.
	* An anycast address is used for one device to talk to the nearest device that has that address assigned to its interface (one-to-the-nearest address), where many interfaces can share the same address.
	* These addresses are taken from the unicast address space but can represent multiple devices, such as multiple default gateways.
	* For example, using an anycast address as a default gateway address on your routers, user devices have to know of only one address, and you don't need to configure a protocol such as Hot Standby Router Protocol (HSRP) or Virtual Router Redundancy Protocol (VRRP).
* **Multicast**
	* This is similar to a multicast in IPv4
* **Unicast**
	* This represents a single unique address used for direct communication.

#### Anycast

One of the problems with addressing in IPv4 is the use of broadcasts, which every device has to process on a segment (even when the broadcast isn't ultimately destined to a device).
IPv4 relies heavily on broadcasts to discover devices on a segment, such as Address Resolution Protocol (ARP), and to acquire addressing, such as Dynamic Host Control Protocol (DHCP).

In IPv6, broadcasts no longer exist: they've been replaced with anycast and multicast addresses.

> anycast addresses are used for one device to talk to the nearest device that has that address assigned to its interface (one-to-the-nearest).
> An anycast address is an IPv6 address from the global address pool configured on multiple devices

An anycast address identifies one or more *interfaces*.
Sometimes people use the term *node* to designate an interface on a device. Basically, an anycast is a hybrid of a unicast and multicast address.

With a unicast, one packet is sent to one destination; with a multicast, one packet is sent to all members of the multicast group; and with an anycast, a packet is sent to any one member of a group of devices that are configured with the anycast address.

By default, packets sent to an anycast address are forwarded to the closet interface (node), which is based on the routing process employed to get the packet to the destination.
Given this process, anycast addresses are commonly referred to as *one-to-the-nearest* addresses.
And, interestingly enough, anycast addresses are allocated from the global pool of unicast addresses in IPv6, making a unicast address and an anycast address indistinguishable from each other when you look at them in a packet.
And since multiple devices can be configured with the same anycast address, anycast addresses are commonly used when there is a need to load-balance traffic such as web content to two different destinations.

#### Multicast

Multicasts in IPv6 serve a function similar to their counterpart in IPv4: they represent a group of interfaces interested in seeing the same traffic.

**A multicast packet example for IPv6**
![[Pasted image 20250908161050.png]]
The first 8 bits are set to FF.
The next 4 bits are the lifetime of the address: 0 is permanent and 1 is temporary.
The next 4 bits indicate the scope of the multicast address (how far the packet can travel):1 is for a node, 2 is for a link, 5 is for the site, 8 is for the organization, and E is global (the Internet).

For example, a multicast address that begins with FF02::/16 is a permanent link address, whereas an address of FF15::/16 is a temporary address for a site.
FF02::1 represents all IPv6 devices (similar to a broadcast in IPv4). FF02::2 represents all routers on an IPv6 segment or VLAN.

> FF02::1 is a multicast address that represents all IPv6 devices (similar to a broadcast address in IPv4).
> FF02::2 is a multicast address that represents all routers on an IPv6 segment or VLAN.
> all multicast addresses start with FF in IPv6.

#### Unicast

IPv6 unicast addresses are assigned to each not (interface), and their uses are discussed in RFC 4291.

**The five types of unicast addresses**

| Addr        | Value     | Desc                                                                                                                                                                                                                                                                            |
| ----------- | --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Global      | 2000::/3  | Global unicast addresses are IPv6 public IP addresses that are routable on the internet, and which are assigned by the Internet Assigned Numbers Authority (IANA). They are equivalent to IPv4 public IP addresses. ISPs summarize these to provide scalability in the internet |
| Reserved    | (range)   | Reserved addresses are used for specific type of anycast as well as for future use. Currently about 1/256th of the IPv6 address space is reserved                                                                                                                               |
| Private     | FE80::/10 | Like IPv4, IPv6 originally supported private addressing, which is used by devices that don't need to access a public network. The first two digits are FE, and the third digit can range from 8 to F.                                                                           |
| Loopback    | ::1       | Like the 127.0.0.1 address in IPv4, 0:0:0:0:0:0:0:1, or ::1, is used for local testing functions; unlike IPv4, which dedicates a complete Class A block of addresses for local testing, only one address is used for local testing in IPv6.                                     |
| Unspecified | ::        | 0.0.0.0 in IPv4 means "unknown" address. In IPv6, this is represented by 0:0:0:0:0:0:0:0, or ::, and is typically used in the source address field of the packet when an interface doesn't have an address and is trying to acquire one dynamically.                            |

multiple addresses of any type can be assigned to a device's interface: unicast, multicast, and anycast.

#### Private Addresses

Private addresses are used for devices that don't need to access a public network such as the Internet.
There are two kind of private addresses:

* **Site-local/unique-local**
	* site-local address (aka unique-local address) is considered a private IP address, similar to the 10.0.0.0/8 private IP with IPv4.
	* This address is used for local communication within a site.
	* A site-local address always starts with FEC:: through FFF::.
* **Link-local**
	* A link-local address is similar to an APIPA address in IPv4 and is used for communication on the network link.
	* A link-local address starts with FE80::/10 (FE8:: through FEB::).

Site-local addresses are similar to the RFC 1918 addresses and represent a particular site or company. These addresses can be used within a company without having to waste any public IP addresses not that this is a concern, given the large number of addresses available in IPv6.

However, by using private addresses, you can set up address translation policies for IPv6 to easily control who is allowed to leave your network and receive returning traffic.

Link-local addresses are a new concept in IPv6. These kinds of addresses have a smaller scope as to how far they can travel (that is, no farther than the local link, the data link layer).
Routers will process packets destined to a link-local address, but they will not forward them to other links. Their most common use is for a device to acquire unicast site-local or global unicast addressing information, discover the default gateway, and discover other layer 2 neighbors on the segment.
When a device is using link-local addresses, it must specify an outbound interface, since every interface is connected to a "link"

> Site-local addresses start with FEC:: through FFF::
> Link-local addresses start with FE8:: through FEB:: (usually FE80).
> The loopback address is ::1, which is equivalent to IPv4's 127.0.0.1

#### Global Unicast Addresses

With the exception of the multicast address space of FF00::/8, unicast and anycast addresses make up the rest of the address types. Global unicast addresses have the first three bits of the first hex value always set to 001, so this means a global unicast address always start with a 2 or a 3, such as 2000 or 2001.
However, IANA has currently assigned only 2000::/3 addresses to the global pool, which is about 1/6th of the available IPv6 addresses. Of these addresses, only 2001::/16 are assigned to various Internet address registries.

Global unicast addresses are made up of two components: a subnet ID (64 bits) and an interface ID (64 bits).
![[Pasted image 20250908190441.png]]

The subnet ID contains the registry of the address (which is responsible for assigning it, such as IANA), the ISP prifix (which ISP is associated with the address), the site prefix (which company is assigned the address space), and a subnet prefix (subnets within the site).
ISPs are assigned an ISP prefix range that enables them easily to aggregate their prefixes, advertising just a single route to the Internet backbone; this alleviates one main problem today with how the internet grew and how ISPs, initially, were assigned IPv4 address spaces that could not be summarized easily.
Another advantage of this address allocation is that the subnet prefix is 16 bits in length. Therefore, with a single global site address, a company can address up to 65,536 subnets.

The last half of the IPv6 address, the interface ID, represents a particular interface within the site.
One requirement with addresses from 2000::/3 through E000::/3 is that the interface ID must have a 64-bit value in it to be considered valid. Therefore, addresses that have 0s for the last 64 bits are considered invalid IPv6 unicast addresses.
For example, 2004:1234:5678:90AB:: is invalid, since the interface ID (the last 64 bits) is binary zeroes.

> global addresses have a first digit of a 2 or 3, and are currently usually 2000 or 2001.
> An interface can be assigned multiple IPv6 addresses this includes link-local, global unicast, and/or anycast addresses.

#### Modified EUI 64

The interface ID is typically composed of a part of the MAC address of the interface. When this is done, the interface ID is commonly called an *extended unique identifier 64 (EUI-64)*.

**Example of the frame with an EUI-64 format**
![[Pasted image 20250908191422.png]]

The *organizationally unique identifier (OUI)*, which is the first 24 bits of the MAC address on a network card, is mapped into the first 24 bits of the interface ID.
The seventh bit in the highest order byte is set to 1, indicating that the interface ID is unique across the site, or 0, indicating that it is unique within the local scope only.

The OUI mapping is followed by the 16-bit value of FFFE. The last 24 bits of the MAC address are then mapped into the last part of the interface ID.

> That addresses that have 0s for the interface ID part of a unicast IPv6 address is invalid.
> with the EUI-64 method, 0xFFEE is inserted between the upper 3 bytes and the lower 3 bytes of the MAC address, which then becomes the host ID of the address.

---

## IPv6 Enhancements

IPv6 has made some enhancements and changes over IPv4 that make it more network-friendly and scaleable.
These enhancements include the IPv6 header, ICMPv6, and neighbor discovery.

### IPv6 Header

**IPv4 header and its fields**
![[Pasted image 20250908191915.png]]

This header contains 12 fields, Without any options, the IPv4 header is 20 bytes, and with options, it is at most 40 bytes.

In IPv6, six of these header fields are no longer part of the new IPv6 header.

* **Header length**
	* This is no longer necessary in IPv6 because all IPv6 headers are fixed-length
* **Identification**
	* This function hasn't been used for a long time in IPv4 and has been deprecated in IPv6.
* **Flags**
	* This function hasn't been used for a long time in IPv4 and has been deprecated in IPv6.
* **Fragment Offset**
	* Fragmentation is processed differently in IPv6 and doesn't need fields in the IPv6 header for this process (this has been moved to the Extension Header Information field in IPv6).
* **Header Checksum**
	* Today's data link layer technologies are reliable, so this field is no longer necessary in IPv6.
* **Padding**
	* This field is no longer necessary in IPv6.

**IPv6 header**
![[Pasted image 20250908192746.png]]

explanation of the eight fields in the IPv6 header

* **Version**
	* This 4-bit field contains the number 6 instead of 4.
* **Traffic Class**
	* This 8-bit field is similar to the ToS field in the IPv4 header.
* **Flow Label**
	* This 20-bit field is new to IPv6 and has no IPv4 equivalent.
	* It is used to mark individual traffic flows for additional policy functions performed by the routing device.
* **Payload length**
	* This 16-bit field indicates the size of the payload.
	* In IPv4, the Total Packet Length Field is the size of the entire packet, but in IPv6, the Payload Length field doesn't include the size of the IPv6 header.
* **Next Header**
	* This 8-bit field performs the same function as the protocol field in the IPv4 header.
* **Hop Limit**
	* This 8-bit field performs the same function as the TTL field in the IPv4 header.
* **Source IP Address*
	* This 128-bit (16-byte) field indicates the source IPv6 address.
* **Destination IP Address**
	* This 128-bit (16-byte) field indicates the destination IPv6 address.


Following these eight fields are the extension header, if any exist. These are replace the IPv4 Options field.
The number of extensions is not fixed, so the total length of the Extension header Information field is variable.
### ICMPv6

ICMPv6 has a protocol number of 58. Like ICMP in IPv4, ICMPv6 is used to help perform diagnostic tests and identify problems (echo, echo reply, destination unreachable, hop count exceeded, and so forth). However, a lot more functionality has been added to ICMPv6.

In a sense, ICMPv6 is like the "Swiss Army Knife" of IPv6 protocols. It takes over the responsibility that other, separate, protocols in IPv4 perform:
* **Address Resolution Protocol (ARP)**
	* IPv4 uses ARP to resolve IP addresses to MAC addresses.
	* ARP no longer exists as a separate protocol in IPv6; ICMPv6 now performs its functions
* **Internet Group Management Protocol (IGMP)**
	* IPv4 uses this protocol so that routing devices can learn if there are multicast devices in a VLAN that want to receive a multicast stream and to forward the necessary stream or streams to the VLAN.
	* IGMP no longer exists as a separate protocol in IPv6; ICMPv6 now performs its functions.

ICMPv6 has taken over the role of other protocols as well and also has new functionality.

**new functions in ICMPv6**
* **Router solicitation and advertisement**
	* Enables devices to query routing devices on a segment using a multicast message or routing devices to advertise themselves via multicast messages; also allows for the redirection of end stations to the best gateway for a destination network
* **DNS solicitation and advertisement**
	* Enables devices to query for DNS servers on a segment using a multicast message or DNS server to advertise themselves via multicast messages
* **Neighbor solicitation and advertisement**
	* Commonly referred to as *neighbor discovery*, determines the data link layer address for neighbors on the same link (the replacement of IPv4's ARP), finds neighboring routers, and keeps track of the reachability of neighbors via mutlicast messages

---

## Address Assignment

You can use four methods to assign an IPv6 address to an interface: tow are done statically and two dynamically.

### Static Address Assignment

One option you have is to statically assign a unicast address to a device's interface using either of these two approaches:

* Specify all 128 bits manually.
* Specify the first 64 bits manually and use EUI-64 to acquire the last 64 bits.

You can manually specify the entire 128-bit address, or you can specify the subnet ID and have the device use the EUI-64 method to create the interface ID part of the address.

If you manually entering the entire address, remember that sets of fields that have 0s in them can be abbreviated with a double colon (::).
The EUI-64 method is the approach more commonly used by most network administrators.

### DHCPv6

DHCPv6 is an update DHCP in IPv4 and works similarly to the previous version, with a few differences.

In IPv6, DHCPv6 is referred to as *stateful autoconfiguration*.
Before the client can begin, it must first detect a router on the link via a neighbor discovery process. If the client detects a router, the client examines the router advertisement messages to determine whether DHCPv6 has been set up. If the router specifies that DHCPv6 is supported, or no router advertisement messages are seen, the client will begin to find a DHCPv6 server by generating a DHCP solicit message.
This message is sent to the ALL-DHCP-Agents multicast address, using the link-local scope to ensure that the message isn't forwarded, by default, beyond the local link. An agent is either DHCPv6 server or relay, such as a router.

In DHCPv4 (IPv4 addressing), you configured the IP Helper feature on Cisco routers when the DHCP server was not on the same segment as the requesting clients.
IP Helper has the router redirect a DHCP request either to a particular server or a directed broadcast address of the segment that had one or more DHCP servers.
This is no longer necessary in DHCPv6: if no server is on the link, a relay can forward the request to the ALL-DHCP-Agents multicast address with the site-local scope. You still have the option of doing this statically, and this is necessary if you want to control which DHCPv6 server or servers should process the request

### Stateless Autoconfiguration

*Stateless* autoconfiguration is an extension of DHCPv6.

As with DHCPv6, clients can acquire their addressing dynamically; however, with stateless autoconfiguration, no DHCP server is necessary to assign IPv6 addressing information to the clients.
Instead, the client uses information in router advertisement messages to configure an IPv6 address for the interface.

This is accomplished by taking the first 64 bits in the router advertisement source address (the prefix of the router's address) and using the EUI-64 process to create the 64-bit interface ID.

Stateless autoconfiguration was designed primarily for cell phones and home network and appliance equipment to assign addresses automatically without having to manage a DHCP server infrastructure.
Devices will verify that their address is unique before using it via neighbor query messages using ICMPv6.

> Stateless configuration assigns addresses dynamically without needing a DHCP server.
> The device learns the IPv6 prefix from a router advertisement and uses EUI-64 to create the interface ID part of the address dynamically.

Normally, routers generate periodic router advertisement (RA) messages the client can listen to and then use to generate its link address automatically; however, when the client is booting up, waiting for the RA may take awhile.
In this situation, the client will generate a router solicitation message, asking the router to reply with an RA so the client can generate its interface address.

Information that can obtained via stateless autoconfiguration include:
* The network numbers (prefixes)
* The lifetime of the prefixes
* A flag that indicates the kind of autoconfiguration the end stations can perform (stateless or stateful)
* The default router for the prefix(es) and the lifetime for this value
* The default maximum transmission unit (MTU) size for the segment
* The maximum hop count allowed

Other information can also be obtained, but this list comprises the most common parameters.

---

## Routing and IPv6

As in IPv4, routers in IPv6 find best paths to destinations based on metrics and administrative distances; and like IPv4, IPv6 routers look for the longest matching prefix in the IPv6 routing table to forward a packet to its destination.

The main difference is that the IPv6 router is looking at 128 bits when making a routing decision instead of 32 bits.

> RFC 2461 requires a router must be able to identify the link-local address of each neighboring router, which is used in the routing process. Because of this, the use of global unicast addresses as a next-hop address is not recommended by the RFC.

### Supported Routing Protocols

IPv6 supports both static and dynamic routing protocols. IPv6 supports these routing protocols:
* static
* Routing Information Protocol next generation (RIPng)
* Open Shortest Path First (OSPFv3)
* Intermediate System-Intermediate System (IS-IS) for IPv6
* Multiprotocol Border Gateway Protocol (MP-BGP4)
* Enhanced Interior Gateway Routing Protocol (EIGRP) for IPv6

#### RIPng

RIPng is defined in RFC 2080. It is actually similar to RIP for IPv4, with these characteristics:
* It's a distance vector protocol
* The hop-count limit is 15
* Split horizon and poison reverse are used to prevent routing loops
* It is based on RIPv2

**Enhancements in RIPng**

* An IPv6 packet is used to transport the routing update.
* The all RIP routers multicast address (FF02::9) is used as the destination address in routing advertisements and is delivered to UDP port 521.
* Routing updates contain the IPv6 prefix of the router and the net-hop IPv6 address.

#### OSPFv3

OSPFv3 is the version of OSPF to support IPv6 and has been enhanced with many features, making it just as scaleable as other interior gateway protocols.

The protocol number for OSPFv3 is 89.

**Enhancements**

* The OSPFv3 process requires a router ID, just as in OSPFv2 (IPv4). This is a 32-bit number that must statically be configured; it cannot be acquired by an IPv4 address on the routing device, since you may not even be using IPv4 on the routing device.
* When forming adjacencies, the routers use their link-local addresses as their source. The link-local addresses appear in the link state database and routing table for next-hop addresses.
* Because link-local addresses are used, conflicting global addresses on the interfaces will not prevent adjacencies from being formed: in other words, the global addressing structure has been abstracted from the interface. In OSPFv2, this would cause routers to fail building an adjacency, but it doesn't cause a problem in OSPFv3
* Any router within an area can perform summarization or filtering. This was one of the biggest weaknesses of OSPFv2 compared to EIGRP. In OSPFv2, only area boundary routers (ABRs) and autonomous system boundary routers (ASBRs) could do summarization or filtering, whereas EIGRP router could do this. This greatly limited the scalability of OSPFv2.

#### EIGRP for IPv6

EIGRP has been updated to support IPv6 routing and is now referred to as EIGRP for IPv6.

EIGRP for IPv6 is a stand-alone process and not part of the EIGRP for IPv4 configuration.
It supports the same features as its older EIGRP implementation for IPv4: diffusing update algorithm (DUAL), rich metric structure, load balancing, and many others.

#### Implementation Strategies

One nice feature of moving your network to IPv6 is that you don't have to it all in one step.
Various migration strategies support both IPv4 and IPv6 as you migrate from the former to the latter

| method                                                             | desc                                                                                                                                                                                                                                                                        |
| ------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Dual stacking                                                      | Devices such as PCs and routers run both IPv4 and IPv6, and thus have two sets of addresses.                                                                                                                                                                                |
| Manual IPv6-over-IPv4 (6to4) tunneling                             | IPv6 packets are tunneled across an IPv4 network by encapsulating them in IPv4 packets. This requires routers configured with dual stacks.                                                                                                                                  |
| Dynamic 6to4 tunneling                                             | Enables IPv6 localities to connect to other IPv6 localities across an IPv4 backbone, such as the Internet, automatically. This method applies a unique IPv6 prefix to each locality without having to retrieve IPv6 addressing information from address registries or ISPs. |
| Intra-Site Automatic Tunnel Addressing Protocol (ISATAP) tunneling | Uses virtual links to connect IPv6 localities together within a site that is primary using IPv4. Boundary routers between the two addressing types must be configured with dual stacks.                                                                                     |
| Teredo tunneling                                                   | Instead of using routers to tunnel packets, the hosts perform the tunneling. This requires the hosts to be configured with dual stacks. It is commonly used to move packets through an IPv4 address translation device.                                                     |
| NAT Proxying and Translation(NAT-PT)                               | Has an address translation device translate between an IPv6 and IPv4 network, and vice versa                                                                                                                                                                                |

> Routers running both IPv6 and IPv4 are referred to as being "dual stacked".
> Connecting IPv6 networks by tunneling IPv6 packets within IPv4 packets is referred to as "6to4 tunneling".

#### Dual Stacking

In dual stacking, a device runs both protocol stacks: IPv4 and IPv6. Of all the transition methods, this is the most common one.

Dual stacking can be accomplished on the same interface or different interfaces of the device.

**Dual stacking on a router**
![[Pasted image 20250909120427.png]]

NetworkA has mixture of devices configured for the two different protocols, and the router is configured in dual stack mode.
Older IPv4-only applications ca still work while they are migrated to IPv6 by supporting newer APIs to handle IPv6 addresses and DNS lookups with IPv6 addresses.

> The main disadvantage of dual stacking on a segment is that devices configured using only one stack must forward their traffic to a dual stacked device, such as a router. Which must then forward the traffic back to the same segment using the other stack. This is an inefficient use of bandwidth, but it does enable devices using both protocol stacks to coexist on the same network segment.

#### IPv6 Tunneling

IPv6 Tunneling enables you to tunnel IPv6 packets by carrying them as payloads in an IPv4 packet.
![[Pasted image 20250909120817.png]]

Using tunneling, you can connect IPv6 networks together across an intermediate IPv4 network.
When tunneling IPv6 packets in an IPv4 payload, the IPv4 Protocol field contains a value of 41, indicating that IPv6 tunneling is occurring.

The two routers performing the tunneling must be configured using dual stacking, since they need to communicate with both IPv6 and IPv4 devices on different segments.

If you are configuring the tunnel manually, you'll need to configure both the IPv4 and IPv6 addresses statically. You'll also need to ensure that routing is performing normally to tunnel the IPv6 packets across the IPv4 network, as well as allowing the two IPv6 networks, to see each other's routes.

---

## IPv6 Configuration

### Enabling IPv6 and Assigning Addresses

To use IPv6 on your router, you must, at a minimum, enable the protocol and assign IPv6 addresses to your interfaces,
```
IOS(config)# ipv6 unicast-routing
IOS(config)# interface TYPE [SLOT_#/]PORT_#
IOS(config-if)# ipv6 address IPV6_ADDR_PREFIX/PREFIX_LENGTH [eui-64]
```

The **`ipv6 unicast-routing`** command globally enables IPv6 and must be the first IPv6 command executed on the router.
The **`ipv6 address`** command assigns the prefix, the length, and the use of EUI-64 to assign the interface ID. Optionally, you can omit the `eui-64` parameter and configure the entire IPv6 address.

To use stateless autoconfiguration:
```
IOS(config)# interface TYPE [SLOT_#/]PORT_#
IOS(config-if)# ipv6 address autoconfig [default]
```

If a default router is selected on this interface, the `default` parameter causes a default route to be installed using that default router.
The `default` parameter can be specified only on one interface.

You can use the `show ipv6 interface` command to verify an interface's configuration.

```
IOS(config)# ipv6 unicast-routing
IOS(config)# interface fastehternet0/0
IOS(config-if)# ipv6 address 2001:1cc1:dddd:2::/64 eui-64

Router# show ipv6 interface fastethernet0/0
FastEhternet0/0 is up, line protocol is up
  IPv6 is enabled, link-local address is FE80::207:EFF:FE46:4070
    [TEN]
  No Virtual link-local address(es):
  Global unicast address(es):
    2001:1CC1:DDDD:2:207:EFF:FE46:4070, subnet is
      2001:1CC1:DDDD:2::/64 [EUI/TEN]
    Joined group address(es):
      FF02::1
      FF02::2
```

In this example, notice that the link-local address is `FE80:207:EFF:FE46:4070`. Also notice the global address: `2001:1CC1:DDDD:2:207:EFF:FE46:4070`.

You can use the `ping` and `traceroute` commands to test connectivity with IPv6
```
IOS# ping 2001:DB8:D1A5:C800::5
```

You can test connectivity to link-local addresses only in the same VLAN; however, you can test access to global addresses in the same or different VLANs.

### IPv6 Static Routing

Configuring an IPv6 static route is similar to configuring an IPv4 static route.

```
IOS(config)# ipv6 route PREFIX/BITS IPv6_NEXT_HOP_ADDR ADMINISTRATIVE_DIST
```

The *prefix* is the network number, with the corresponding number of bits of the network number, you want to reach.
For a default route, use ::/0 as the prefix.

To view the IPv6 routes in the routing device's routing table, use the `show ipv6 route` command.

### RIPng

You enable RIPng a little differently than RIP for IPv4, First, you use the `ipv6 router rip tag` command to enable RIPng globally:
```
IOS(config)# ipv6 unicast-routing
IOS(config)# ipv6 router rip TAG
```

If you haven't enabled IPv6 unicast routing, you must do this first.
When executing the `ipv6 router rip` command, this takes you into subcommand mode, where you can change some of the global values for RIPng, such as disabling split horizon, changing the administrative distance, and adjusting timers.

The `TAG` is a locally significant identifier used to differentiate between multiple RIP processes running on the router.

Unlike RIP for IPv6, RIPng has no *network* command to include interfaces. Instead, you must enable RIPng on a per-interface basis with the `ipv6 rip TAG enable` command:
```
IOS(config)# interface TYPE [SLOT_#/]PORT_#
IOS(config-if)# ipv6 rip TAG enable
```

The `TAG` parameter associates the interface with the correct RIPng routing process.

To view the routing protocol configuration, use the `show ipv6 rip` command.

### OSPFv3

Enabling OSPFv3 for IPv6 is a little different from enabling OSPFv2 for IPv4.

#### OSPFv3 Global Configuration

As in OSPFv2, in OSPFv3 you enable a process globally and can perform certain functions within the process, such as assigning the router ID and defining the areas:

```
IOS(config)# ipv6 router PROCESS_ID
IOS(config-router)# router-id ROUTER_ID
IOS(config-router)# area AREA_NUMBER
```

The process ID, as in OSPFv2, uniquely identifies the OSPF process locally running on the routing device (it is locally significant and is not shared with other OSPFv3 routeing devices).
The router ID is a 32-bit number typically represented using a dotted-decimal format.
The area number is also a 32-bit number, which can be represented by a decimal (12) or a dotted-decimal (0.0.0.12) format.

#### OSPFv3 Interface Configuration

Once you set up the global properties for OSPFv3, you must place interfaces into the local process. Unlike OSPFv2, where you used the `network` command within the OSPFv2 routing process configuration, IPv6's configuration is like RIPng, where you perform the configuration under an interface:
```
IOS(config)# interface TYPE [SLOT_#/]PORT_#
IOS(config-if)# ipv6 ospf PROCESS_ID area AREA_NUMBER
```

#### Simple OSPFv3 Configuration Example

placing two interfaces in area 0:
```
IOS(config)# ipv6 unicast-routing
IOS(config)# ipv6 router ospf 1
IOS(config-router)# router-id 0.0.0.1
IOS(config-router)# exit
IOS(config)# interface g1/0/1
IOS(config-if)# ipv6 ospf 1 area 0
IOS(config-if)# exit
IOS(config)# interface g1/0/2
IOS(config-if)# ipv6 opsf 1 area 0
```

Your cisco device does not need a global ipv6 address on an interface in order to participate in OSPFv3 (it needs only a link-local address, which it will automatically acquire, assumming IPv6 is globally enabled and the interface is enabled).

#### OSPFv3 Verification

=> `show ipv6 ospf`

To display IPv6 neighbor discovery (ND) cache information (the actual neighbors), use the `show ipv6 neighbors` command

You can also use the show `ipv6 ospf neighbor` command to show neighbor information for OSPFv3 specifically

Use the `show ipv6 route` command to view routing table. To vie only the OSPF routes, add the `ospf` parameter: `show ipv6 route ospf`

### EIGRP for IPv6

The scalability features available in EIGRP for IPv4, neighbor discovory, the DUAL algorithm, metrics, load balancing, multicast, and incremental updates, are also available in EIGRP for IPv6.

Like EIGRP for IPv4, EIGRP for IPv6 uses hello packets to discover and become neighbors with other local EIGRP for IPv6 routers. Also like EIGRP for IPv4, EIGRP for IPv6 uses multicasts, but the FF02::A IPv6 multicast link-local address is used.

#### EIGRP for IPv6 Global Configuraiton

```
IOS(config)# ipv6 unicast-routing
IOS(config)# ipv6 rotue eigrp AUTONOMOUS_SYSTEM
IOS(config-rtr)# eigrp router-id ROUTER_ID
IOS(config-rtr)# [no] shutdown
```

The first command enables IPv6 on the routing devices.
The second command specifies the autonomous system that the routing device is associated with.

As with EIGRP for IPv4, the autonomous system number must match between two routers or they will not form a neighbor relationship.

The `eigrp router-id` command defines the router's 32-bit ID.
You can represent this as a decimal or dotted-decimal number.
The `shutdown` command disables or enables the EIGRP process.

#### EIGRP for IPv6 Interface Configuration

Once you set up the global properties for EIGRP for IPv6, you must place interfaces into the local process.

Unlike EIGRP for IPv4, where you use the `network` command within the EIGRP routing process configuration, IPv6's configuration is similar to that of RIPng and OSPFv3, where you perform the configuration under and interface:
```
IOS(config)# interface TYPE [SLOT_#/]PORT_#
IOS(config-if)# ipv6 eigrp AUTONOMOUS_SYSTEM
```

#### EIGRP for IPv6 Simple Configuration

```
IOS(config)# ipv6 unicast-routing
IOS(config)# ipv6 router eigrp 100
IOS(config-router)# eigrp router-id 100.1.1.1
IOS(config-router)# no shutdown
IOS(config)# interface g1/0/1
IOS(config-if)# ipv6 eigrp 100
IOS(config-if)# exit
IOS(config)# interface g1/0/2
IOS(config-if)# ipv6 eigrp 100
```

#### EIGRP for IPv6 Verification

To verify the neighbor relationships for EIGRP for IPv6, use the `show ipv6 eigrp neighbors` command.

To display entries in the EIGRP IPv6 topology table, use the `show ipv6 eigrp topology` command.

### Exercise 14-1: Configuring IPv6 Static Routing

### Exercise 14-2: Configuring OSPFv3 Routing

---

## Chapter Review

---

## Quick Review