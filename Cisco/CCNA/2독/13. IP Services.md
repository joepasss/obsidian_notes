
## Understanding Network Services

### Hostname Resolution

To reference the devices on the network by their names, you can create a hostname table of names and matching IP address that are local to the device.
To create a hostname entry in the hostname table you use the `ip host <name> <ip address>` command.

For example, if you are connected to VAN-R1 and want to reference LA-R1 by name using ping or telnet, you would use the following commands to configure LA-R1 as a resolvable name:

```
VAN-R1> enable
VAN-R1#config t
VAN-R1(config)#ip host LA-R1 13.0.0.2
```

You can create multiple entries by executing the `ip host` command multiple times with a different name and IP address each time.
Once you have created the entries in the table, you can view the entries with the `show hosts` command:

```

VAN-R1#show hosts
Default domain is not set
Name/address lookup uses static mappings

Codes: UN - unknown, EX - expired, OK - OK, ?? - revalidate
       temp - temporary, perm - permanent
       NA - Not Applicable None - Not defined

Host                      Port  Flags      Age Type   Address(es)
LA-R1                     None  (perm, OK)  0   IP    13.0.0.2
```

Notice the LA-R1 entry and the IP address of 13.0.0.2. Also notice that this is a permanent entry with an age of 0 (it will not time out).

After you've created the hostname entry, you can use that hostname with other commands, such as `ping`, `telnet`, or `traceroute`.

```
VAN-R1#ping LA-R1
Type escape sequence to abort.
Sending 5, 100-byte ICMP Echos to 13.0.0.2, timeout is 2 seconds:
!!!!!
Success rate is 100 percent (5/5), round-trip min/avg/max = 16/24/44 ms
VAN-R1#
```

If you wanted remove an entry from the hostname table, you would use the `no ip host` command.
In this example, this would be `no ip host LA-R1`.

#### Understanding DNS

Domain Name System is a common network service that enables system names to be translated into their IP addresses; this enables us to communicate using friendly names.
DNS is a hierarchy of servers that are designed to resolve *fully qualified domain names (FQDNs)* to IP addresses.

**DNS resolves FQDNs to IP addresses**
![[Pasted image 20251025151616.png]]

If you try to connect `www.gleneclarke.com`, your system first sends a query to the DNS server on your network asking for the IP address of `www.glenclarke.com`.
If your local DNS server does not know the IP address of the site, it then sends the query to the DNS root servers on the Internet.
They then forward the request on the .com name servers, and then on the my DNS server.
My DNS server has the IP address of my web site in its database, so my server sends that back to your DNS server in your office.
Your DNS server then sends the IP address to your client system that wants to visit the web site.

#### Configure DNS Lookups

If you want your Cisco device to perform DNS lookups on entries you type that are not commands, such as `server1.gleneclarke.com`, you can configure DNS lookups with the `ip domain-lookup` command.
DNS lookup is actually enabled by default, but many administrators disable it using the `no ip domain-lookup` command, because if typos appear in a command, the device thinks it is a name and tries to resolve it (which takes extra time).

After ensuring that doamin lookups are enabled, you then specify the DNS server where the lookup will be performed using the `ip name-server <ip_dns_server>` command.
You can also configure the optional setting of the domain name if you like, which is then automatically appended to any hostnames that are used to create an FQDN.

```
### Configure DNS lookups
VAN-R1(config)#ip domain-lookup
VAN-R1(config)#ip name-server 12.0.0.100
VAN-R1(config)#ip domain-name glenclarke.com
```

```

VAN-R1(config)#do show hosts
Default domain is glenclarke.com
Name/address lookup uses domain service
Name servers are 12.0.0.100

Codes: UN - unknown, EX - expired, OK - OK, ?? - revalidate
       temp - temporary, perm - permanent
       NA - Not Applicable None - Not defined

Host                      Port  Flags      Age Type   Address(es)
LA-R1                     None  (perm, OK)  0   IP    13.0.0.2
```

### Network Time Protocol

The date and time on your router are important for a multiple of reasons.
The two most comman ones are:

* Logging of messages
* Using digital certificates for authentication

Obviously, having the correct timestamp on a log message will help you in forensics when examining logging messages regarding security.
Digital certificates are used for authentication, and one of the components validated on a device's certificate is whether it is current: the certificate includes beginning and ending dates and times. A peer that receives the certificate will compare its current time and make sure that it falls between the beginning and ending dates and times on the certificate.

As you can see, the date and time on your router is also important. You can set the date and time on your device in two ways:

* Manually configure the date and time using the `clock set` command
* Use NTP

NTP is an open standard that enables you to synchronize your router's time with a centralized time server, where your device periodically polls the NTP server for the current date and time.
NTP uses the User Datagram Protocol (UDP) on port 123. NTP running on your device can get the correct time from an internal or external server.
The reliability of the server referes to the stratum level of the clock source.
The most accurate source is an atomic clock, but most networks typically don't need that kind of precision and instead obtain time from a global positioning system (GPS) source.

You can also synchronized your devices' times by using global time server available on the Internet, such as the Google public time service, to synchronize time with Google's atomic clocks. In this case, you can configure the NTP settings on your deivces to refer to `time.google.com`.

NTP has three basic methods of delivering time messages between the time server and the NTP client:

* **Broadcast**
	* The NTP server periodically announces the time using a broadcast message.
	* This method assumes that all clients are in a local subnet.
* **Multicast**
	* The NTP server periodically announces the time using a mutlicast message.
	* In most cases, multicast routing must be set up to disseminate the time across the network.
* **Unicast**
	* The NTP client periodically (commonly, every 10 minutes) queries the NTP server for the correct time.

> Most administrators will implement a multicast solution, because it scales the best: the server sends out only one message, which, if multicast routing is configured correctly, will appear on all network segment that have NTP clients.
> The unicast approach is commonly used in smaller networks because it is easier to set up.

Cisco IOS deivces support two versions of NTP:

* NTPv3/v4
* SNTP (Simple NTP)

NTPv3/v4 supports MD5 for authentication. A shared key is preconfigured on the time server and your networking device.
This key is commonly referred to as a *pre-shared key (PSK)*, because it must exist on both devices before it can be used for authentication purposes.

The time server hashes the current date and time message with the PSK using MD5 and adds this signature to the time message. Your router repeats this process with the received date and time and its locally configured PSK, and it then compares the two has values; this is commonly referred to as a *message digest* or *digital signature*, and it verifies that the message is valid (the same key was used).

SNTP, as its name implies, is a simpler method of acquiring time. Unlike NTPv3 or NTPv4, Cisco's IOS implementation of SNTP (as well as that of most vendors) doesn't support authentication of time messages.

> You should set up your own time server, called a *local master clock* (don't use one on the Internet, however, since it typically won't support authentication of messages), and implement MD5 authentication with NTP.
> SNTP is simpler form of NTP that doesn't support any authentication and therefore is not recommended for use in a production network.

NTP is a critical component for network management on networking devices, including logging and authentication functions.
NTP ensures that all your devices are synchronized with the same time source.
However, NTP doesn't require authentication with a time source. Because of this, a hacker could send NTP packets to your devices, changing their time, and as a result affecting logging and authentication functions.
There are three solutions to this problem:

* Use NTP or virtual private network (VPN) to connect to the time source.
* Use access control lists (ACLs) to filter timing information from only valid time sources
* Set up your own master time source instead of using an untrusted one on the Internet.

#### NTP Configuration

IOS devices can be configured as NTP servers and/or clients. They are typically configured as time servers to relay time from a reliable local master clock.

> You should not use an IOS device as a local master clock, because IOS doesn't support a method of connecting to an externally reliable time source, such as GPS.
> However, many operating systems, support NTP server applications that support external clock connections such as GPS.

Here is the router command to define NTP servers on an IOS device:

```
IOS(config)# ntp server IP_ADDR [version NUMBER]
					[key KEYID] [source INTERFACE] [prefer]
```

You first need to define the IP address of the remote NTP server. If you don't specify the version number for NTP, it defaults to 3 (NTPv3).
The optional **`key`** parameter references authentication information to be used to verify the server's on peer's timing communications: this must match what the server is uding when NTPv3 authentication is performed.
The **`source`** parameter specifies what IP address on the IOS device to use as the source address in the IP packet header when sending communications to the remote NTP server (note that you identify the layer 3 interface on the IOS device to reference the IP address to use). If you omit this parameter, it defaults to the address of the outgoing layer 3 interface.
When you entering multiple NTP servers, you can use the **`prefer`** parameter, which specifies that this NTP server is preferred over other servers for synchonization pursposes; otherwise, the first server configured is the first one that the IOS device will query.

You need to configure three commands to set up authentication:

```
IOS(config)# ntp authenticate
IOS(config)# ntp authentication-key KEY_# md5 KEY_VALUE
IOS(config)# ntp trusted KEY_#
```

The `ntp authenticate` command enables NTP authentication.
The `ntp authentication-key` command defines a reference number for the key (key_#) as well as the authentication key. (The same key_# and key_value must be configured on the remote NTP server.)
Last, the `ntp trusted-key` command specifies which NTP devices should be trusted with autentication, which prevents an accidental synchronization to a system that is not trusted.
Notice that a reference number is used. This reference number must match that used in the `ntp authentication-key` command.

By using a key number, you can create multiple keys, enabling you to update keys more easily and to use different keys for different peers.

Once you have defined authentication, you need to reference the key number in the corresponding `ntp server` command, which tells the IOS device which key to use when sending messages to specific peers.

#### NTP Verification

Once you have configured NTP on your IOS device, you can use various `show` commands to examine your configuration and troubleshoot problems.
To see the current time on the router's software clock, use the `show clock` command.

You'll use two basic commands to examine NTP information:

* `show ntp associations`
* `show ntp status`

The `show ntp associations` command displays associations with the NTP server(s).

```
IOS> show ntp associations
  address       ref clock     st  when  poll  reach  delay  offset  disp
*~192.168.1.11  192.168.1.11  2   31    1024  377    4.1    -8.38   1.5
* master (synced), # master (unsynced), + selected, - candidate, 
    ~ configured
```

The first set of leading characters displays synchronization information:

| char | desc                                                    |
| ---- | ------------------------------------------------------- |
| *    | This router is synchronized to this peer                |
| #    | This router is almost synchronized to this peer         |
| +    | The peer has been selected for possible synchronization |
| -    | The peer is a candidate for synchronization             |
| ~    | The peer has been statically configured                 |

Each column contains the following information:

* **address**
	* Lists the addresses of the NTP peer devices
* **ref clock**
	* Lists the addresses of where peers in the address column are getting their time
* **st**
	* Indicates the stratum level of the peer
* **when**
	* Indicates the time since the last NTP message was received from this peer
* **poll**
	* Indicates the polling interval, in seconds, that this router is using to contact the specified peer
* **reach**
	* Indicates the peer's reachability, in octal
* **delay**
	* Displays the round-trip delay, in milliseconds, to the peer
* **offset**
	* Displays the relative time of the peer's clock to the local router's clock, in miliseconds
* **disp**
	* Dispersion is a value reported in seconds.
	* It represents the maximum clock difference ever reported between the server and the local clock.

The `show ntp status` command displays the status of NTP on the router.

```
IOS#show ntp status
Clock is synchronized, stratum 2, reference is 192.168.1.11
nominal freq is 250.0000 Hz, actual freq is 249.9990 Hz, precision is 2**19
reference time is AFE2525E.70597C87 (00:10:39.511 EDT Thu Jan 1 2004)
clock offset is 6.21 msec, root delay is 83.98 msec
root dispersion is 81.96 msec, peer dispersion is 2.02 msec
```

In this example, IOS is synchronized to the NTP server at 192.168.1.11, which provides a startum level 2 service.

#### NTP Configuration Example

![[Pasted image 20251026185957.png]]

```
Router(config)# ntp server 192.168.1.11 key 99 source ethernet0
Router(config)# ntp authenticate
Router(config)# ntp authentication-key 99 md5 55ab8972G
Router(config)# ntp trusted-key 99
Router(config)# interface ethernet 1
Router(config-if)# ntp disable
Router(config)# interface ethernet 2
Router(config-if)# ntp disable
```

In this example, the NTP server is 192.168.1.11, which is specified in the first command.
The next three commands set up an authentication, and refer back to the first command with the key reference number of 99.

Notice that the hash key is 55ab8972G, which must *also* be configured on the NTP server.
Last, NTP is disabled on two interfaces that it doesn't expect to receive time messages from.

### Simple Network Management Protocol

Some management of network devices requires the use of SNMP, which is commonly used to manage (configure and/or monitor) a remote networking device.

#### SNMP Overview

SNMP comprises three components:

* **Network management station (NMS)**
	* This device accesses and manages agents and is sometimes referred to as the *manager*.
* **Agent**
	* This is a device managed by an NMS
* **Management information base (MIB)**
	* This database defined how information (configuration, operational, and statistical) is stored on an agent.

The interaction is between the NMS and the agent, which can involve two types of connections:

* NMS sends `get` or `set` commands to the agent:
	* get commands are used for retrieving MIB information
	* set commands are used to change MIB information.
* The agents sends *traps*, or *informs*, to the NMS, which are a form of log message, indicating an important condition on the device.

Information stored on an agent is located in an MIB. Each MIB is quniquely identified with an object identifier (OID). Get, send, and trap messages are based on the MIB information identified by a particular OID.

#### SNMP Versions

There are three main versions of SNMP. SNMPv1 and v2 use community strings for security: read-only and read-write.

The read-only community string is used to restrict the reading MIB information. The main problem with community strings, however, is that they are sent in clear text and the support of inform requests, which allows for acknowledged notifications, and get bulk requests, which enables a mangement station to access ultiple MIBs in one request.

SNMPv3 is enhancement of SNMPv2. In addition to supporting the same MIB structure and gets, sets, and traps, SNMPv3 supports authentication, message integrity, and payload incryption. Message integirty is used to ensure that SNMP messages have not been tampered with and are comming from a legitimate source; this is accomplished with the MD5 or Secure Hashing Algorithm v1 (SHA-1) hashed message authentication code (HMAC) functions.

Payload encryption is used so that a man-in-the-middle (MITM) attack cannot examine the get, set, and trap command information.
In an MITM attack, an attacker's device sees traffic flowing between the source and destination.
Encryption can be used to defeat MITM attacks: the attacker can still see the packets, but the content is encrypted from eavesdropping. Encryption is accomplished with the Data Encryption Algorithm (DES), Triple DES (3DES), or Advanced Encryption Standard (AES) encryption algorithms.

**SNMP Security Models**

| SNMP version | Level        | Authentication   | Encryption     | What happens                                                         |
| ------------ | ------------ | ---------------- | -------------- | -------------------------------------------------------------------- |
| 1            | NoAuthNoPriv | Community string | no             | Authenticates with a community string match                          |
| 2c           | NoAutoNoPriv | Community string | No             | Authenticates with a community string match                          |
| 3            | NoAuthNoPriv | Username         | No             | Authenticates with a username                                        |
| 3            | AuthNoPriv   | MD5 or SHA       | No             | Provides MD5/SHA for authentication                                  |
| 4            | AuthPriv     | MD5 or SHA       | DES, 3DES, AES | Provides MD5/SHA for authentication, and encryption via DES/3DES/AES |

#### SNMP Configuration

Configuring SNMPv2c is simpler, but less secure. With v3 and v2c version, the following commands define the location and contact information of the SNMP device:

```
IOS(config)# snmp-server location LOCATION_INFORMAITON
IOS(config)# snmp-server contact CONTACT_NAME
```

The first command identifies the location of the device, such as the building floor, and wiring closet in which the Cisco device resides.
The second command identifies the administrator contact information.

Both of these can pulled from the NMS.

#### SNMPv2c Configuration

```
IOS(config)# snmp-server community STRING ro
IOS(config)# snmp-server community STRING rw
IOS(config)# snmp-server host NMS_IP_ADDR traps STRING
IOS(config)# snmp-server enable traps
```

The first command defines the community string used to enable read-only access.
The second command defines the community string for read-write access.

Note that the community string is sent, in clear text, in the SNMP packet to restrict access.

The last two commands enable the sending of SNMP traps to an SNMP management station (you also have to match the community string on the IOS device to what the NMS has configured).

#### SNMPv3 Configuration

The configuration of SNMPv3 is much more complicated.

```
IOS(config)# snmp-server view VIEW_NAME OID_MIB
				{included | excluded}
IOS(config)# snmp-server group GROUP_NAME {v1 | v2c | v3}
				{auth | noauth | priv} [read READ_VIEW]
				[write WRITE_VIEW] [notify NOTIFY_VIEW]
				[accss-list ACL_ID]
IOS(config)# snmp-server user USER_NAME GROUP_NAME {v1 | v2c | v3}
				[auth {md5 | sha} AUTH_PASSWORD] [priv {des | 
				3des | aes {128 | 192 | 256}} ENCR_PASSWORD]
				[access ACL_ID]
IOS(config)# snmp-server host HOST_NAME_OR_IP [traps | informs]
				[version {1 | 2c | 3}] [auth USER_NAME]
IOS(config)# snmp-server enable traps
```

SNMP views (`snmp-server view`) control which OIDs can or can't be accessed.
Using views is optinoal, but by default there's no restriction to accessing the OIDs if you have SNMP access to the IOS device.

Groups (`snmp-server group`) defined the level of access.
With groups, you can specify which version of SNMP is used, the required authentication type, which views can be accessed via gets, sets, and traps, and which NMS can access them (via and ACL).

Users define the actual NMS. The authentication credentials define the HMAC signature function and key used to create signatrues, and the privilege credentials define the encryption algorithm and key to use.

```
IOS(config)# access-list 10 permit host 10.0.1.12
IOS(config)# snmp-server view myview interfaces included
IOS(config)# snmp-server group mygroup v3 priv read myview access 10
IOS(config)# snmp-server user myuser mygroup v3 auth sha a3fh95t11a priv
				aes 128 dkfjiewokd892a
IOS(config)# snmp-server host 10.0.1.12 traps version 3 auth myuser
IOS(config)# snmp-server enable traps
```

In this example, an SNMP view was created that includes ths "interfaces" MIB/OID.
An SNMP group for v3 was created, limiting the view to read access.
The group references the view and the ACL to restrict SNMPv3 accesss.
The SNMP user specifies the accesss credentials (protection) and references the group to use. The SNMP server is defined with traps being sent to the server, and the SNMP user configuration is refernced so the router knows the access method to enforce.

Finally, SNMP traps are enabled so the router can send events to the SNMP management station.

### Other Network Services

#### TFTP and FTP

* TFTP does not support authentication, while FTP does.
* TFTP uses UDP, while FTP is TCP based
* TFTP runs on UDP port 69 by default, while FTP uses TCP port 21 by default.

| TFTP    | FTP          |
| ------- | ------------ |
| no auth | support auth |
| UDP 69  | TCP 21       |

Typically use TFTP to back up their device configuration and their IOS. The `copy` command in Cisco supports TFTP as both a source and a destination, so you can copy to the TFTP server or copy from the TFTP server.
For example, to back up your IOS to the TFTP server, you can use the `copy flash: tftp:` command and answer the questions, such as what is the filename to copy, what is the IP address of the remote host (the TFTP server), and what is the filename to be created at the destination.

You can also use FTP to back up files from the Cisco device. A bit more configuration is needed to use FTP, such as the username and password that needs to be configured before using the FTP feature.

#### Telnet and SSH

Cisco administrators will want to administer their devices remotely either by using telent as the protocol or using SSH.

Telent has been a remote administration protocol for many years but has a major drawback in that it is a protocol that sends all data, including username and passwords, in clear text.
This means anyone who can intercept the telnet traffic can see what you are doing and also discover your cerdentials to log on to the device.

This is where SSH comes in. SSH is a protocol that also enables remote administration of your devices, but it encrypts all the traffic from your administration computer to the device you are managing.
This means that if someone intercepts the traffic, it is encrypted, so the attacker will not be able to view the details of what you are doing.
It is important to note that SSH also encrypts the username and password that is used during logon.

| Telnet                                   | SSH                                        |
| ---------------------------------------- | ------------------------------------------ |
| unencrypted (send traffic in clear text) | encrypted (send traffic in encrypted text) |

### Exercise 13-1: Configuring Hostname Resoultion

* Configure hostname tables on VAN-R1 and LA-R1.
* Configure each system for DNS name resolution using a DNS server.

![[Pasted image 20251027171648.png]]

**Connections**

* VAN-R1 (S1/0) - LA-R1 (S1/0)

* VAN-R1 (F0/0) - IOU1 (E0/0)
* LA-R1 (F0/0) - IOU2 (E0/0)

* IOU1 (E1/0) - PC-A
* IOU1 (E1/1) - PC-B
* IOU1 (E1/2) - TFTP

* IOU2 (E1/0) - PC-C
* IOU2 (E1/1) - PC-D

* VAN-R1 is at port 2011
* LA-R1 is at port 2012

* IOU1 is at port 2013
* IOU2 is at port 2014

* PC-A is at port 2015
* PC-B is at port 2017
* PC-C is at port 2019
* PC-D is at port 2021

* TFTP is at port 2023

**VAN-R1 Configuration**

```
VAN-R1#config t
Enter configuration commands, one per line.  End with CNTL/Z.

### F0/0 configuration
VAN-R1(config)#interface F0/0
VAN-R1(config-if)#ip addr 12.0.0.1 255.0.0.0
VAN-R1(config-if)#no shutdown

### S1/0 configuration
VAN-R1(config-if)#interface S1/0
VAN-R1(config-if)#ip addr 13.0.0.1 255.0.0.0
VAN-R1(config-if)#no shutdown

### verify
VAN-R1(config-if)#do show ip interface brief
Interface                  IP-Address      OK? Method Status                Protocol
FastEthernet0/0            12.0.0.1        YES manual up                    up
Serial1/0                  13.0.0.1        YES manual up                    up
Serial1/1                  unassigned      YES unset  administratively down down
Serial1/2                  unassigned      YES unset  administratively down down
Serial1/3                  unassigned      YES unset  administratively down down
FastEthernet2/0            unassigned      YES unset  administratively down down
FastEthernet2/1            unassigned      YES unset  administratively down down
GigabitEthernet3/0         unassigned      YES unset  administratively down down

### Save configuration
VAN-R1(config-if)#do copy running-config startup-config
*Oct 27 17:26:43.395: %LINEPROTO-5-UPDOWN: Line protocol on Interface Serial1/0, changed state to down
VAN-R1(config-if)#do copy running-config startup-config
Destination filename [startup-config]?
Warning: Attempting to overwrite an NVRAM configuration previously written
by a different version of the system image.
Overwrite the previous NVRAM configuration?[confirm]
Building configuration...
[OK]
```

**LA-R1 configuration**

```
LA-R1#config t
Enter configuration commands, one per line.  End with CNTL/Z.

### F0/0 configuration
LA-R1(config)#interface F0/0
LA-R1(config-if)#ip addr 14.0.0.1 255.0.0.0
LA-R1(config-if)#no shutdown

### S1/0 configuration
LA-R1(config-if)#interface S1/0
LA-R1(config-if)#ip addr 13.0.0.2 255.0.0.0
LA-R1(config-if)#no shutdown

### verify
LA-R1(config-if)#do show ip interface brief
Interface                  IP-Address      OK? Method Status                Protocol
FastEthernet0/0            14.0.0.1        YES manual up                    up
Serial1/0                  13.0.0.2        YES manual up                    up
Serial1/1                  unassigned      YES unset  administratively down down
Serial1/2                  unassigned      YES unset  administratively down down
Serial1/3                  unassigned      YES unset  administratively down down
FastEthernet2/0            unassigned      YES unset  administratively down down
FastEthernet2/1            unassigned      YES unset  administratively down down
GigabitEthernet3/0         unassigned      YES unset  administratively down down

### save configuration
LA-R1(config-if)#do copy running-config startup-config
Destination filename [startup-config]?
Warning: Attempting to overwrite an NVRAM configuration previously written
by a different version of the system image.
Overwrite the previous NVRAM configuration?[confirm]
Building configuration...
[OK]
```

**ping test between routers**

```
### ping to LA-R1 from VAN-R1
VAN-R1#ping 13.0.0.2
Type escape sequence to abort.
Sending 5, 100-byte ICMP Echos to 13.0.0.2, timeout is 2 seconds:
!!!!!
Success rate is 100 percent (5/5), round-trip min/avg/max = 8/22/56 ms

### ping to VAN-R1 from LA-R1
LA-R1#ping 13.0.0.1
Type escape sequence to abort.
Sending 5, 100-byte ICMP Echos to 13.0.0.1, timeout is 2 seconds:
!!!!!
Success rate is 100 percent (5/5), round-trip min/avg/max = 8/11/16 ms
```

**OSPF**

```
### VAN-R1 ospf
VAN-R1#config t
Enter configuration commands, one per line.  End with CNTL/Z.
VAN-R1(config)#router ospf 1
VAN-R1(config-router)#network 12.0.0.0 0.255.255.255 area 0
VAN-R1(config-router)#network 13.0.0.0 0.255.255.255 area 0
VAN-R1(config-router)#end

### VAN-R1 verification
VAN-R1#show ip route
Codes: L - local, C - connected, S - static, R - RIP, M - mobile, B - BGP
       D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area
       N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2
       E1 - OSPF external type 1, E2 - OSPF external type 2
       i - IS-IS, su - IS-IS summary, L1 - IS-IS level-1, L2 - IS-IS level-2
       ia - IS-IS inter area, * - candidate default, U - per-user static route
       o - ODR, P - periodic downloaded static route, H - NHRP, l - LISP
       a - application route
       + - replicated route, % - next hop override

Gateway of last resort is not set

      12.0.0.0/8 is variably subnetted, 2 subnets, 2 masks
C        12.0.0.0/8 is directly connected, FastEthernet0/0
L        12.0.0.1/32 is directly connected, FastEthernet0/0
      13.0.0.0/8 is variably subnetted, 2 subnets, 2 masks
C        13.0.0.0/8 is directly connected, Serial1/0
L        13.0.0.1/32 is directly connected, Serial1/0
O     14.0.0.0/8 [110/65] via 13.0.0.2, 00:01:29, Serial1/0

### LA-R1 ospf
LA-R1#config t
Enter configuration commands, one per line.  End with CNTL/Z.
LA-R1(config)#router ospf 1
LA-R1(config-router)#network 13.0.0.0 0.255.255.255 area 0
LA-R1(config-router)#network 14.0.0.0 0.255.255.255 area 0
LA-R1(config-router)#end

### Save configuration
VAN-R1#copy running-config startup-config
Destination filename [startup-config]?
Building configuration...
[OK]
VAN-R1#

### LA-R1 OSPF verification
LA-R1#show ip route
Codes: L - local, C - connected, S - static, R - RIP, M - mobile, B - BGP
       D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area
       N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2
       E1 - OSPF external type 1, E2 - OSPF external type 2
       i - IS-IS, su - IS-IS summary, L1 - IS-IS level-1, L2 - IS-IS level-2
       ia - IS-IS inter area, * - candidate default, U - per-user static route
       o - ODR, P - periodic downloaded static route, H - NHRP, l - LISP
       a - application route
       + - replicated route, % - next hop override

Gateway of last resort is not set

O     12.0.0.0/8 [110/65] via 13.0.0.1, 00:01:56, Serial1/0
      13.0.0.0/8 is variably subnetted, 2 subnets, 2 masks
C        13.0.0.0/8 is directly connected, Serial1/0
L        13.0.0.2/32 is directly connected, Serial1/0
      14.0.0.0/8 is variably subnetted, 2 subnets, 2 masks
C        14.0.0.0/8 is directly connected, FastEthernet0/0
L        14.0.0.1/32 is directly connected, FastEthernet0/0

### save configuration
LA-R1#copy running-config startup-config
Destination filename [startup-config]?
Building configuration...
[OK]
LA-R1#
```



---

## Configuring DHCP Services

DHCP enables devices to acquire their IP addressing information dynamically, without the administrator needing to configure IP address information on each host on the network.
DHCP is built on a client/server model and defines two components:

* **Server**
	* Delivers IP configuration information to the DHCP client (hosts)
* **Client**
	* Requests and acquires host configuration information from the DHCP server

Using a DHCP server to assign addressing information provides these three networking advantages over manually configuring addressing information on devices:

* Reduces the amount of time it takes to address a network
* Reduces the likelihood of IP addressing errors on devices
* Privdes mobility for employees to move around the network, connect and obtain the correct IP addressing information based on their location.

### Understanding DHCP

DHCP is an application-layer protocol that can automatically configure each system on the network with IP address information.
Your first step to configuring a DHCP server on your Cisco router is to enable the service; then you can configure a pool.

A *pool* is the range of IP addresses that DHCP gives out on the network, as well as any additional settings such as the router address (the *default gateway*), the DNS server, and how long the system is to have the IP address.

**DHCP phases**
![[Pasted image 20251027175412.png]]

* **DHCP Discover**
	* The DHCP discover message is sent by a client to all systems on the network using the destination broadcast address (FF-FF-FF-FF-FF-FF).
	* This message is basically saying, "If you are a DHCP server, I need an IP address." Note that all phases use this broadcast address for communication because the client does not have an IP address yet.
* **DHCP Offer**
	* Any DHCP servers on the network that receive the discover message will send an offer to the client basically stating, "I am a DHCP server and you can have this IP address."
	* If a system is not a DHCP server, it discards the DHCP discover message when it receives it.
* **DHCP Request**
	* After receiving an offer, the client sends out a DHCP request message starting which offer (IP address) it wants to receive.
	* Keep in mind that the client may receive many offers, so when the client sends out the DHCP request message confirming which offer it is taking, all other DHCP servers retract their offers.
* **DHCP Acknowledgement (ACK)**
	* After the DHCP server receives the DHCP request message from the client requesting to have the IP address that was offered, the DHCP server sends a final acknowledgement message indicating how long the server will have the address (lease time).
	* The DHCP acknowledgement message also conatins any additional IP address options for the client, such as the router address and the DNS server address.

When configuring DHCP, you will need to create a DHCP *scope*, which is a group of addresses, known as a *pool*, that the DHCP server is allowed to give out to clients.
When configuring the scope, you also specify the DHCP lease time, or how long a client is to have the IP address assigned to it.

Configuring shorter lease times such as one day means that more traffic is generated, because the client needs to renew the address sonner than it would if the lease time were set to seven days, for example.

### DHCP Server Configuration

```
IOS(config)# service dhcp
IOS(config)# ip dhcp pool POOL_NAME
IOS(dhcp-config)# network NETWORK_NUMBER [mask | /prefix-length]
IOS(dhcp-config)# domain-name DOMAIN
IOS(dhcp-config)# dns-server ADDRESS [ADDR2, ..... address 8]
IOS(dhcp-config)# default-router ADDR
IOS(dhcp-config)# lease {days [hours] [minutes] | infinite}
IOS(dhcp-config)# exit
IOS(config)# ip dhcp excluded-address low-address [high-address]
```

In this example,

* **`service dhcp`**
	* Enables the DHCP server and/or relay features on your IOS device.
	* Without this command, the IOS device will not act as a server or relay agent.
	* As of IOS 12.2, this command is enabled by default.
* **`ip dhcp pool`**
	* Creates a name for the DHCP server address pool and places you in DHCP pool subcommand mode.
* **`network`**
	* Specifies the subnet network number and mask of the DHCP address pool.
	* Also *prefix-length* specifies the number of bits that make up the address prefix.
	* The prifix is an alternative way of specifing the network mask of the client.
	* The prefix length must be preceded by a forward slash (/).
* **`domain-name`**
	* Specifies the domain name to be assigned to the client.
* **`dns-server`**
	* Specifies the IP address of a DNS server that is available to a DHCP client.
	* One IP address is required; however, you can specify up to eight IP addresses in one command line.
* **`default router`**
	* Specifies the IP address of the default gateway to be assigned to the DHCP client
* **`lease`**
	* Specifies the duration of the lease
	* IP addresses are leased to hosts, typically on a temporary basis.
	* When a client's address lease time reaches half the life of the lease, it will attempt to renew the existing addressing information it obtained previously. If unsuccessful in its renewal attempt, the device will continue to attempt renewal at periodic intervals.
	* The default lease duration is one day, but other parameters can be configured for the pool, such as an TFTP server address for VoIP phones.
	* You can set the lease to infinite, which would mean the lease does not expire.
* **`ip dhcp excluded-address`**
	* Specifies the IP address that the DHCP server should not assign to DHCP clients based on the network numbers you've defined for the DHCP pool or pools.
	* These addresses are already used in the subnet, such as static address assigned to the switches and routing device.
	* If you are defining network numbers for your pool, make sure you exclude the network number and the directed broadcast address from the pool.
	* Notice this command is not part of the pool configuration, but is a Global Configuration command.

> Typically, Cisco routers are configured as DHCP servers for small networks, such as branch offices.
> In large corporate or campus networks, a dedicated DHCP server or servers are usally set up in the data center and/or distribution layers of the network.

To view the DHCP pool information, use the `show ip dhcp pool` command.
With this command, you can view the total number of available addresses, the configured address range, and the number of currently leased addresses.

```
VAN-R1(config)#do show ip dhcp pool

Pool pool_12 :
 Utilization mark (high/low)    : 100 / 0
 Subnet size (first/next)       : 0 / 0
 Total addresses                : 16777214
 Leased addresses               : 0
 Pending event                  : none
 1 subnet is currently in the pool :
 Current index        IP address range                    Leased addresses
 12.0.0.1             12.0.0.1         - 12.255.255.254    0
```

To view the current IP addresses assigned to DHCP clients, use the `show ip dhcp binding` command.

```
VAN-R1(config)#do show ip dhcp binding
Bindings from all pools not associated with VRF:
IP address          Client-ID/              Lease expiration        Type
                    Hardware address/
                    User name
12.0.0.3            0100.5079.6668.03       Oct 28 2025 07:35 PM    Automatic
VAN-R1(config)#
```

This command lists the IP addresses assigned to the clients: the IP-to-MAC address bindings.

When assigning IP addresses to clients, IOS will first ping the IP address to ensure that it hasen't been assigned to anyone else; additionally, IOS will examine its ARP table to ensure that the IP address isn't in use by any other device.
To view these conflicts, use the `show ip dhcp conflict` command:

```
VAN-R1(config)#do show ip dhcp conflict
IP address        Detection method   Detection time          VRF
VAN-R1(config)#
```

If an address conflict is detected, the address is removed from the DHCP pool and an administrator must maually resolve the problem.
Use the `clear ip dhcp conflict` command to clear a conflicted address from the list.

Optanally, you can use the `debug ip dhcp server` command to troubleshoot problems with the operation of DHCP on an IOS device.

### DHCP Relay Configuration

In larger networks, networking devices that need addresses via DHCP may not reside on the same broadcast domain as the DHCP server and therefore are unable to reach a DHCP server.

In most companies, the DHCP servers are centralized at the distribuiokn layer or in the data center.
Therefore, by default, the DHCP servers will not see the DHCP requests that the clients are advertising; routers don't forward broadcast messages to solve this issue.

The solution to this problem is to use th IOS feature *DHCP relay*: the Cisco router acts as a relay agent with the DHCP REQUEST message.

![[Pasted image 20251027194309.png]]

In this figure, when the router recives the broadcasted addressing request from the client, it changes it to a unicast message, with the router as the source and the DHCP server as the destination.
The agent includes the network number to help the DHCP server choose the correct addressing pool.
All messages between the agegnt and the DHCP server are delivered using unicast.

From the client's perspective, it thinks it's actually communicating locally with the DHCP server.

To configure the router as a DHCP relay agent, use the following:

```
Router(config)# service dhcp
Router(config)# interface g0/0
Router(config-if)# ip helper-address DHCP_server_IP_ADDR
```

The `service dhcp` command is enabled by default, you need to execute this only if the DHCP service has been manually disabled.
You then navigate to the interface you want to configure to listen for DHCP messages.

The `ip helper-address` command is used to configure the router messages to.
You can configure this command multiple times if you have redundant DHCP servers.

If you want to verify that the DHCP relay operation is configured properly and identify the address of the DHCP server that the DHCP messages are forwarded to, you can use the `show ip interface` command:
```

FastEthernet0/0 is up, line protocol is up
  Internet address is 14.0.0.1/8
  Broadcast address is 255.255.255.255
  Address determined by setup command
  MTU is 1500 bytes
  Helper address is 13.0.0.1 

....

```

### Exerciese 13-2: Configuring DHCP Services

* Configure VAN-R1 as a DHCP server
* Provide IP address of 12.100.0.1 up to 12.100.0.50

```
VAN-R1(config)#ip dhcp pool VAN_pool
VAN-R1(dhcp-config)#network 12.0.0.0 /8
VAN-R1(dhcp-config)#default-router 12.0.0.1
VAN-R1(dhcp-config)#dns-server 12.0.0.100
VAN-R1(dhcp-config)#exit
VAN-R1(config)#ip dhcp excluded-address 12.0.0.1 12.0.0.120
```

---

## Network Address Translation

Address translation was originally developed to solve two problems: to handle shortage of IPv4 addressses and to hide network addressing schemes.

### Running Out of Addresses

A long-term solution was conceived to address this; it called for the enhancement of the TPC/IP protocol stack, including the addressing format. this new addressing format is called IPv6.

Whereas the current IPv4 addressing scheme uses 32 bits to represent addresses, IPv6 uses 128 bits for addressing, creating billions of extra addresses.

### Private Addresses

It took a while for IPv6 to become a standard, and on top of this, its adoption early on was quite slow, even with ISPs on the Internet backbone.

The main reason that this standard wasn't embraced for a long time is the success of the two short-term solutions to the address shortage problem: schemes to create additional addresses, called *private addresses*, and translation of these addresses to public adresses using address translation.

RFC 1918, by the Internet Enginerring Task Force (IETF), is a document that was created to address the shortage of address.
When devices want to communicate, each device needs a unique IP address.
RFC 1918 created a private address space that any company can use internally.

**RFC 1918 Private Addresses**

| Class | Range of Addresses            |
| ----- | ----------------------------- |
| A     | 10.0.0.0 - 10.255.255.255     |
| B     | 172.16.0.0 - 172.31.255.255   |
| C     | 192.168.0.0 - 192.168.255.255 |

As you can see from this table, you have 1 Class A, 16 class B, and 256 class C adresses at your disposal.

Just the single Class A address of 10.0.0.0 has more than 17 million IP addresses, which is more than enough to accommodate your company's needs.

> Private addresses are a scheme developed by IETF to overcome the limited number of available public IP addressses.
> However, private addresses cannot be placed in packets that will be routed to a public network; they must be translated first. Translation typically takes place on a perimeter device, such as a router or security appliance (such as the Cisco Adaptive Security Appliance [ASA]).

One of the main issues addressed in RFC 1918 is that private addresses can be used only internally within a company and cannot be used to communicate to devices in a public network, such as the Internet.
If you send packets with RFC 1918 addresses in them to your ISP, for instance, your ISP will either filter them or not be able to route this traffic back to your devices.

Obviously, this creates a connectivity problem, since many of your devices with private addresses need to send and receive traffic to and from public networks.

### Address Translation

A second standard, RFC 1631, was created to solve the connectivity problem of RFC 1918.
It defines Network Address Translation (NAT), which enables you to change an IP address in a packet to a different address.

When communicating to devices in a public network, your device needs to use a source adddress that is a public address. Address translation enables you to translate your internal private addresses to public addresses before these packets leave your network.

> Common devices that can perform address translation include firewalls, routers, and servers.
> Typically address translation is done at the perimeter of the network by either a router or (more commonly) a firewall.

Actually, RFC 1631 doesn't specify that the address you are changing has to be a private address, it can be *any* address.
This is useful if you randomly chose someone else's public address space but still want to connect to the Internet.
Obviously, you don't own this address space, but address translation enables you to keep your current addressing scheme and have those source addresses translated to your ISP-assigned addresses before your packets enter the Internet.

**common reasons for using address translation:**

* You have to use private addressing because your ISP didn't assign you enough public IPv4 addresses.
* You are using public addresses but have changed ISPs, and your new ISP won't support these public addresses.
* You are merging two companies and they are using the same address space, for instance 10.0.0.0, which creates routing and reachability issues.
* You want to assign the same IP address to multiple machines so that users on the Internet see this offered service as a single logial computer.

### Address Translation Types

Adress translation comes in a variety of types, such as NAT, Port Address Translation (PAT), dynamic address translation, and static address translation.

Because of the many terms used, the concept of address translation can be confusing, especially because many people use the address translation terms incorrectly.

#### Terms and Definitions

| Term                      | Def                                                          |
| ------------------------- | ------------------------------------------------------------ |
| inside                    | Addresses located inside your network                        |
| outside                   | Addresses located outside your network                       |
| local                     | IP address physically assigned to a device                   |
| global                    | Public IP address physicallor logically assigned to a device |
| inside local IP address   | Inside device with an assigned private IP address            |
| inside global IP address  | Inside device with a registered public IP address            |
| outside global IP address | Outside device with a resistered public IP address           |
| outside local IP address  | Outside device with an assigned private IP addrss            |

| Translation Type | Exp                                                                                                                                                   |
| ---------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------- |
| simple           | One IP address is translated to a different IP address                                                                                                |
| extended         | One IP address and one TCP/UDP port number are mapped to a different IP address and, possibly, port number.                                           |
| static           | A manual address translation is performed between two addresses and possibly port numbers.                                                            |
| dynamic          | An address translation device automatically performs address translation between two addresses and possibly port numbers                              |
| NAT              | Only IP addressses are translated (not port numbers)                                                                                                  |
| PAT              | Many inside IP addresses are translated to a single IP address, where each inside address is given a different TCP or UDP port number for uniqueness. |

### Implementing NAT

NAT translates one IP address to another. This can be a source address or a destination address.

Two basic implementation of NAT can be used: *static* and *dynamic*.

#### Static NAT

With static NAT, a manual translation is performed by an address translation device, translating one IP address to a different one.

Typically, static NAT is used to translate destination IP addresses in packets as they come into your network, but it's alos used to translate source addresses as they leave your network.

**static NAT example**
![[Pasted image 20251030055534.png]]

This shows simple example of outside users trying to access to inside web server.
In this example, you want to Internet users to access an internal web server, but this server is using a private address (10.1.1.1), If an outside user were to enter this private address in the destination IP address field, that would create a problem, because the user's ISP would drop the packet.
Therefore, the web server needs to be presented as having a public address.

The web server is assigned an inside global IP address of 200.200.200.1 on the router, and your DNS server advertises this address to outside users.
When outside users send packets to the 200.200.200.1 address, the router examines its translation table for a matching entry.
In this case, it sees that 200.200.200.1 maps to 10.1.1.1.
The router then changes the destination IP address to 10.1.1.1 and forwards the packet to the inside web server.

Note that if the router didn't do the translation to 10.1.1.1, the web server wouldn't know this information was meant for itself, since the outside user sent traffic originally to 200.200.200.1.
Likewise, when the web server sends traffic out to the public network, the router compares the *source* IP address to entries in its translation table, and if it finds a match, it changes the inside local IP address (private source address, 10.1.1.1) to the inside global IP address (public source address, 200.200.200.1).

Static translations are always present in the translation table.

#### Dynamic NAT

With static address translation, you need to build the translations manually.
Typically, static translation is done for inside resources that outside people want to access.
When inside users access outside resources, dynamic translation is typically used.

In this situation, the global address assigned to the internal user isn't that important, since outside devices don't directly connect to your internel users, they just return traffic to them that the inside user requested.

When dynamic NAT, you must manually define two sets of addresses on your address translation device: one set defines which inside addresses are allowed to be translated (the local addresses), and the other defines what these addresses are to be translated to (the global addresses).

When an inside user sends traffic through the address translation device, say a router, it examines the source IP address and compares it to the internal local address pool. If it finds a match, it determines which inside global address pool it should use for the translation. It then dynamically chooses an address in the global address pool that is not currently assigned to an inside device.
The router adds this entry in its address translation table, the packet is translated, and the packet is then sent to the outside world.
If no packet is translated, and the packet is then sent to the outside world.
If no matching entry is found in the local address pool, the address is not translated and is forwarded to the outside world in its original state.

When returning traffic enteres your network, the address translation device examines the destination IP address and checks it against the address translation table.
Upon finding a matching entry, the address translation device converts the global inside address to the local inside address in the destination IP address field of the packet header and forwards the packet to the inside network.

Dynamic NAT translations are added to the translation table when a source matches the dynamic NAT policy configuration and are removed once an idle timer is reached.
All traffic from a source is translated to the same destination, no matter how many connections are opened from the source.

### Port Address Translation

One problem with static or dynamic NAT is that it provides only a one-to-one address translation. Therefore, if you have 5000 internal devices with private addresses, and all 5000 devices try to reach the Internet simultaneously, you need 5000 public addresses in your inside global address pool.
If you have only 1000 public addresses, only the first 1000 devices are translated and the reamining 4000 won't be able to reach outside destinations.

To overcome this problem, you can use *address overloading*. Many other terms are used to describe this process, including Port Address Translation (PAT) and Network Address Port Translation (NAPT).

Dynamic PATs are added to the translation table when a new connection maches the dynamic PAT policy configuration and are removed once an idle timer is reached or the connection ends.
For example, with TCP, the connection ends when the FIN and FIN-ACK segment messages are seen, or a hard reset (RST) is performed.

Most translation devices are smart enough to use the same PAT address for multiple connections opened to the same destination.
For example, if you downloaded a web page from a web server, that typically takes dozens of connections. In this situation, most translation devices, including Cisco IOS devcies, will use the same source address for all these translations.
This ensures that the destination server is seeing all these connections from the same source.

> PAT, or dynamic NAT address overloading, enables you to use the same global IP address for all internal devices, where the source port in a TCP or UDP header is used (possibly changed) to differentiate among the different translated connections.
> Dynamic NAT with overload is used when more devices need to access the Internet than you have public IP addresses assigned by your ISP.

#### Same IP Address, Different Port Numbers

With PAT, all devices that go through the address translation device have the same global IP address assigned to them, so the source TCP or UDP port numbers are used to differentiate the different connections.
If two devices have the same source port number, the translation device changes on of them to ensure uniqueness.

When you look at the translation table in the address translation device, you'll see the following items when PAT is performed on a packet:

* Inside local IP address (original source private IP)
* Inside local port number (original source port number)
* Inside global IP address (translated public source IP)
* Inside global port number (new source port number)
* Outside global IP address (destination public address)
* Outside global port number (destination port number)

One main advantage of NAT over PAT is that NAT will basically work with most types of IP connections.
Since PAT relies on port numbers to differentiate connections, PAT works only with TCP and UDP; however, many vendors, also support Internet Control Message Protocol (ICMP) with PAT using a proprietary translation method.

#### Example Using PAT

![[Pasted image 20251101004141.png]]

Both PCs execute a telnet to 199.199.199.1, and both of these connections use a source port number of 50,000.
When these connections reach the address translation device, the device performs its PAT translation.

For the first connection, the source IP address (inside local) is changed to 200.200.200.7 (inside global).
Since this is the first connection and the source port is not found in the translation table, the source port number is left as is.

When PC-B makes a telnet connection to the remote device, since it is using a source port number (50,000) already in the table for a connection to the telnet server, the address translation device changes it from 50,000 to an unused number in the translation table.

Therefore, when traffic is sent from the telnet server to the inside PCs, the address translation device will be able to differentiate the two connections and undo the translation correctly by examining both the destination IP address *and* port number in the telent reply packets: the destination port of 50,000 will be redirected to PC-A and the destination port of 50,001 will be changed back to 50,000 and redirected to PC-B.
In both cases, the destination IP address is also changed to the inside local address of the device to which packet will be forwarded.

> PAT is typically used for inside-to-outside connections, while static NAT is used for outside-to-inside connections.

#### Port Address Redirection

The previous example showed PAT being carried out dynamically by the address translation device.
In some situations, however, this will not work. For instance, your ISP may assign you a single public IP address. You need to use this with PAT to enable inside users to access outside resources.
However, you'll have a problem if you want outside users access an internal service, such as a web server. Dynamic PAT, unfortunately, won't work in this situation.

Another solution to this problem is available: static PAT, often called *port address redirection (PAR)*.
Assume that your ISP has assigned you a single public IP address: 199.199.199.1. You need to use this address for inside users to access the outside world, but you still need the outside world to aaccess an internal web server.
With static PAT, you set up your address translation device to look not only at the destination IP address (199.199.199.1), but also at the destination port number (80 for a web server).
You create a static PAT entry such that when the address translation device sees this combination of address and port numbers, the device translates it to the inside local IP address and, possibly, the port number used for the service on this inside device.

For example, your ISP has assigned you a single IP address, 200.200.200.1, and this address must be configured on your router's S0 interface.
This presents a problem in this example, since you have an internal web server that you want external users to access. Port address redirection can be used to overcome this problem. You would set up a static PAT entry on your router that would take TCP traffic sent to 200.200.200.1 on port 808 and redirect it to 10.1.1.1 on port 80 (internal web server).
Without PAT, the router would try to process the web connection itself since this IP address is assigned to its own local interface.

> Port address redirection enables you to redirect application traffic directed to one address to a different address.

### Advantages of Address Translation

As mentioned, network address translation devices are typically used to give you an almost inexhaustible number of addresses as well as to hide your internal network addressing scheme.

Another advantage of address translation is that if you change ISPs or merge with another company, you can keep your current addressing scheme and make any necessary changes on your address translation device or devices, making your address management easier.

Another big advantage of address translation is that it gives you tighter control over traffic entering and leaving your network.
For example, if you are using private addresses internally, all traffic entering and leaving must pass through an address translation device.
Because this restriction, it is much easier to implement your security and business policies.

### Disadvantages of Address Translation

* Each connection has an added delay
* Troubleshooting is more difficult
* Not all applications work with address translation

Because address translation changes the contents of packets and possibly, segment headers, as well as computing any necessary new checksum values, extra processing is required on each packet. This extra processing, obviously, wll affect the throughput and speed of your connections.
The more packets that pass through your address translation device needing translation, the more likely your users will notice the delay.

Whenever problems arise with connections involving address translation, it can be difficult to troubleshoot them.
It is difficult to track down the real source and destination of a connection, you have to log into your address translation device and look at your translation tables. And if the packet is going through multiple layers of translation, possibly at both the source and destination sites, this can be a hair-pulling experience.
Also, even though one of the advantages of address translation is that it hides your internal addressing scheme, it also creates security issues, an external hacker can more easily hide his identity and IP address by sending his packets through a translation device or mutliple translation devices.

Probably the most difficult issue with address translation is that not all applications will work with it. For instance, some applications embed IP addressing or port information in the actual data payload (such as FTP), expecting the destination device to use this addressing information in the payload instead of what is in the packet and segment headers.
This can pose a problem with address translation, since address translation, by default, doesn't translate data payload information, only header information.
Multimedia and NetBIOS applications are notorious for embedding addressing information in data payloads.

### NAT Configuration

NAT can be static or dynamic. The configuration process is similar for both types. Probably the most difficult thing about configuring address translation is understanding the difference between the terms *inside* and *outside*.
These terms refer to where your devices are located (inside) and where the external network (the Internet) is.
This is important when it comes to the configuration of address translation.

On the IOS device, you must perform two basic configuration steps:

* Define the address translation type
* Define the location of devices

#### Configuring Static NAT

Static NAT is typically used when devices on the outside of your network want to access resources, such as web, DNS, and e-mail servers, on the inside.

```
Router(config)# ip nat inside source static
					inside_local_source_ip_addr
					inside_global_source_ip_addr
					
Router(config)# ip nat outside source static
					outside_global_destination_ip_addr
					outside_local_destination_ip_addr
```

The *inside* and *outside* parameters specify the direction in which translation will occur.

For instance, the `inside` keyword specifies that the inside source local IP addresses are translated to an inside global IP address when *leaving* the network; and the destiantion global IP addresses are translated to inside local IP addresses when *entering* your network.
The `outside` keyword changes the outside *destination* global IP address to an outside local address (the `ip nat outside source static` command is used when you are connecting two company networks together and their addresses overlap).

After you configure your translations, you must specify which interface on your router are considered to be on the inside and which are on the outside with the following configuration:

```
Router(config)# interface TYPE
Router(config-if)# ip nat {inside | outside}
```

Specify `inside` for interfaces connected to the inside of your network and `outside` for interfaces connected to external networks, such as your ISP.

**NAT example**
![[Pasted image 20251101065410.png]]

In this example, an internal web server (192.168.1.1) will be assigned a global IP address of 200.200.200.1.

```
Router(config)# ip nat inside source static
					192.168.1.1 200.200.200.1
Router(config)# interface E0
Router(config-if)# ip nat inside
Router(config-if)# interface S0
Router(config-if)# ip nat outside
```

The `ip nat inside source static` command defines the translation. The `ip nat inside` and `ip nat outside` commands specify what interfaces are on the inside (E0) and what interfaces on the outside (S0).

Note that any packets that don't match the address translation rule will pass between these two interfaces untranslated. If you want only translated packets to pass between these interfaces, you'll need to configure an appropriate ACL or ACLs.

#### Configuring Dynamic NAT

When you are configuring dynamic NAT, you'll need to configure three things: what inside addresses are to be translated, what global addresses will be used for the dynamic translation, and what interfaces are involved in the translation.
To specify what internal devices will have their source address translated, use the following command:
```
Router(config)# ip nat inside source
					list STANDARD_IP_ACL_NAME_OR_#
					pool NAT_POOL_NAME
```

The `ip nat inside source list` command requires you to configure a standard IP ACL that has a list of the inside souce addresses that will be translated, any addresses listed with a *permit* statement will be translated, and any addresses listed with a *deny*, or the implicit deny, statement will not be translated.

Following this is the name of the address pool: this ties together the address pool you'll use that contains your global source IP addresses.
To create the pool of source inside global IP addresses, you this command:

```
Router(config)# ip nat pool NAT_POOL_NAME
					beginning_inside_global_ip_addr
					ending_inside_global_ip_addr
					netmask subnet_mask_of_address
```

The pool name that you specify references the inside addresses that will be translated from the `ip nat inside source list` command.
Next, list the beginning and ending IP addresses in the pool, followed by the subnet mask for the addresses.
Once you have done this, the last thing you need to configure is which interfaces are considered to be on the inside and outside of your network.
Use the `ip nat inside` and `ip nat outside` Interface Subconfiguraiton mode commands.

> The `ip nat inside source list` command specifies which internal addreseses will be dynamically translated.
> Remeber that translation takes place only when a packet matches a *permit* statement in the ACL: matching a *deny* statement or the *implicit deny* exempts the packet from translation.
> The `ip nat pool` command specifies the global addresses to use when performing dynamic translation of local addresses.

```
### Two PCs will have dynamic NAT performed on them
Router(config)# ip nat inside source list 1 pool nat-pool

## ACL
Router(config)# access-list 1 permit host 192.168.1.10
Router(config)# access-list 1 permit host 192.168.1.11

## nat pool
Router(config)# ip nat pool nat-pool 200.200.200.2
						200.200.200.3 netmask 255.255.255.0

## determine where interface is outside or inside
Router(config)# interface E0
Router(config-if)# ip nat inside

Router(config)# interface S0
Router(config-if)# ip nat outside
```

The `ip nat inside source list` command specifies the inside source IP addresses that will be translated.
Notice that these are addresses in ACL 1, 192.168.1.10 and 192.168.1.11. They are associated with the global address pool called nat-pool.
The `ip nat pool` command specifies the global addresses that the inside source addresses will be translated to.
And finally, etherenet 0 is specified as being on the inside and serial 0 is on the outside.

### PAT Configuration

This configuration, which is very similar to configuring dynamic NAT, requires three basic translation commands.
The first thing you specify is which inside devices will have their source address translated.
You'll use the same command that you used in dynamic NAT, but you'll add the *overload* parameter to specify that PAT is to be performed:

```
Router(config)# ip nat inside source
					list STANDARD_IP_ACL_#
					pool NAT_POOL_NAME overload
```

Next, you specify the global pool to use.

```
Router(config)# ip nat pool NAT_POOL_NAME
						beginning_inside_global_ip_addr
						ending_inside_global_ip_addr
						netmask subnet_mask_of_addr
```

You can specify more than one address to use in PAT, or you can specify a single IP address (use the same address for the beginning and ending address).
And last, you have to tell the IOS which interfaces are inside and outside, respectively, in terms of the `ip nat inside` and `ip nat outside` commands.

```
### PAT
Router(config)# ip nat inside source list 1 pool
					nat-pool overload

### ACL
Router(config)# access-list 1 permit host 192.186.1.10
Router(config)# access-list 1 permit host 192.186.1.11

### nat-pool
Router(config)# ip nat pool nat-pool 200.200.200.2 200.200.200.2
					netmask 255.255.255.0

### inside, outside
Router(config)# interface E0
Router(config-if)# ip nat inside

Router(config)# interface S0
Router(config-if)# ip nat outside
```

### Address Translation Verification

Once you have configured address translation, you can use many different comands to verify and troubleshoot the operation of address translation on your router.

If you want to see the address translation table on your router, use the **`show ip nat translations`** command

```
Router#show ip nat translations
Pro  Inside global  Inside local  Outside local  Outside global
---  200.200.200.1  192.168.1.1   ---            ---
---  200.200.200.2  192.168.1.2   ---            ---
```

In this example, two addresses are being translated: 192.168.1.1 (inside local) to 200.200.200.1 (inside global) and 192.168.1.2 (inside local) to 200.200.200.2 (inside global).
Notice that no protocol is listed (Pro) or port numbers, indicating that these are NAT translations, not PAT.

```
Router#show ip nat translations
Pro  Inside global       Inside local       Outside local  Outside global
tcp  200.200.200.1:1080  192.168.1.1:1080   201.1.1.1:23   201.1.1.1:23
tcp  200.200.200.1:1081  192.168.1.2:1080   201.1.1.1:23   201.1.1.1:23
```

In this example, both 192.168.1.1 and 192.168.1.2 are accessing the same outside device (201.1.1.1) using telnet.
Notice that both also use the same source port number (1080 under the inside local column). The IOS has noticed this and changed the second connection's source port number from 1080 to 1081 to differentiate the two connections.

You can see address translations statistics on your router with **`show ip nat statistics`**

For dynamic entries in the translation table, you can clear all of the entries, or specific entries:
```
Router# clear ip nat translation *
Router# clear ip nat translation inside
					global_ip_addr local_ip_addr
Router# clear ip nat translation outside
					global_ip_addr local_ip_addr
Router# clear ip nat translation protocol inside
					global_ip_addr global_port
					local_ip_addr local_port
```

The first command clears all dynamic entries in the table. Note that to clear static entries, you need to delete your static NAT configuration commands from within configuration mode.

In addition to `show` commands, you can also use `debug` commands for troubleshooting.
The `debug ip nat` command, for instance, will show the translations the IOS is doing on every translated packet.

### Exercise 13-3: Configuring NAT Overloading

![[Pasted image 20251101074950.png]]

```
### ACL
VAN-R1(config)#access-list 1 permit 10.1.0.0 0.0.255.255

### enable nat
VAN-R1(config)#ip nat inside source list 1 interface g0/1 overload

### configure inside interface
VAN-R1(config)#interface g0/0
VAN-R1(config-if)#ip nat inside

### configure outside interface
VAN-R1(config)#interface G0/1
VAN-R1(config-if)#ip nat outside

### verify
VAN-R1#show ip nat translations
VAN-R1#show ip nat stat
```

### Address Translation Troubleshooting

1. Verify your NAT commands to ensure that your configuration is correct, including the ACL, with the **permit** statements that specify traffic that should be dynamically translated.
2. Check to see whether the router is actually translating the packets for the user with the `show ip nat translations` command.
3. Use the `show ip nat statistics` command to see whether translations are actually occurring, remeber that the output is static and you'll need to re-execute it multiple times to update the statistics.
	* For example, by sending five ICMP echos through the router that match a NAT translation rule, you should see the hit count increment by 5.
4. Use the `debug ip nat [detailed]` command to see if translation is occuring or not; make sure enough addresses are available in a corresponding global NAT pool when performing dynamic NAT.
5. Verify that you have correctly configured the router's interfaces for NAT as inside or outside with the `ip nat inside` or `ip nat outside` interface subconfiguration mode command.
6. Use the `show access-list` command to see if hit counts appear on the `permit` statements for packets that should be translated.
7. Make sure the router can route the packet to the destination by looking at the routing table with `show ip route`
8. If the packet is being translated, but you are not getting any replies for the user trarric, such as echo replies when using ping, examine any ACLs on the router to make sure that traffic can get back through the router with the `show access-lists` command: look for incrementing hit counts on **deny** statements.

---

## Quality of Service

*Quality of service (QoS)* has a set of mechanisms that enable network devices to make decisions related to bandwidth and performance in order to optimize network traffic.

**QoS scenario**
![[Pasted image 20251101095133.png]]

In this example, you can see a router with three Gigabit interfaces connected to LANs.
Let's assume there are many hosts on each of these LANs that need to send lots of traffic out to the Internet on the Fast Ethernet interface.

The problem is that you have all this traffic coming from three Gigabit interfaces trying to funnel through the lower bandwidth of the 100 Mbps connection going to the Internet.
As the administrator for this network you may need to optimize traffic to ensure that critical application data gets a higher priority over other traffic.

The general idea of QoS is that when a packet is received by a router, or a frame is received by a switch, it can be marked for a particular type of service that is read by networking devices in order to determine the level of priority to give to the packet or frame.

### Forwarding Per-Hop Behavior and QoS Terminology

Cisco uses differentiated services, or *DiffServ*, as a tool to achieve QoS on the network.
DiffServ as a technology uses *per-hop behavior (PHB)*, which is used to determine the priority assigned to a packet when traveling through a router (a hop).

You should be familiar with a number of terms and concepts when discussing DiffServ (and QoS).

#### Classification and Marking

The first step to implementing QoS is that packets or frames must be classified as a particular type of traffic and then marked so that the networking devices can perform QoS actions on those packets.

*Classification* of packets is done by the QoS features of a device analyzing the header of the packet to determine the type of traffic it its.
For example, QoS can use an ACL to identify packets coming from a specific network as being high priority traffic.

After the packet or frame has been classfied, it is then *marked* to achieve a type of service.
The packet or frame is marked by adding information to the header of the packet or frame. With IP packets, there is a *Type of Service (ToS)* field in the packet that is marked with a *Differentiated Service Code Point (DSCP)*.
DSCP codes are used by DiffServ to indicate what type of actions network devices should take with a packet.

**DiffServ DSCP codes**

* **Expedited Forwarding (EF)**
	* This code is applied to packets that require low latency and low packet loss.
	* For example, voice traffic would use EF and note that IP phones mark their VoIP packets with EF by default.
* **Assured Forwarding (AF)**
	* These codes are used to mark queues for a packet and their drop priority.
	* The format for the code is AFXY, where X is the queue (1 to 4) for the packet, and Y is the drop priority value of 1 to 3.
* **Class Selector (CS)**
	* This field applies the packet to a class.
	* The class is identified with a value of CS*n*, where *n* is a number from 0 to 7.

In a layer 2 frame, a field in the 802.1Q header, the *Class of Service (CoS)* field, is marked by a layer 2 device using trunking to indicate any actions that devices should take with the frame.
Note that wireless traffic is layer 2 traffic as well, but it uses a ToS field instead of CoS.

#### Queuing

When a device needs to deliver a message and the interface is busy, the device will need to place the message in a queue.
With QoS, each classification of traffic can be placed into different queues, with a scheduler determining when the traffic in a queue can be forwarded, typically based on priority.

#### Congestion

QoS offers feature that enables you to avoid congestion on a network link.
*Congestion* occurs, for example, when traffic coming from three Gigabit interfaces is trying to go out one Fast Ethernet interface at 100 Mbps.
To handle congestion on a link, such as a WAN link, you can use priority features and queueing features to ensure that delay-sensitive traffic is handled first on a congested link.

#### Policies

You can use policies to limit the bit rate of a link.

Using policies, you can monitor traffic and compare it against a traffic contract, typically referred to as the *committed information rate (CIR)*.
When traffic exceeds the contracted bit rate, you can drop the extra traffic. When monitoring the traffic bit rate, you can take a number of actions, such as enableing the packet to continue, dropping the packet, or marking the packet with a different DSCP value.

#### Shaping

Shaping is a QoS feature that enables administrators to enforce lower bit rates on an interface than what it is capable of handling.

Shaping can be used by administrators to limit bandwidth used by different departments. Shaping is similar to policies, except with shaping, you typically buffer to over-usage traffic for later delivery instead of dropping it.

---

## Logging and Syslog

An *event* is something that happens (such as someone logging in); an *incident* is an issue with what happened (an unauthorized login access was detected).

Logging plays a key role in your management an security solution. Even though SNMP supports traps, the number of traps you can use is limited: logging supports many more types and kinds of messages than SNMP traps.

Logging to a syslog server makes it easier for you to manage and keep a historical record of your logging information from a multitude of devices.
Syslog uses UDP and runs on port 514. Unfortunately, all logging information is sent in clear text, it has no packet integrity checking, and it is easy for a hacker to send false data to the syslog server.
Therefore, it is highly recommended that you encrypt information between your networking devices and the syslog server and that you set up a filter on the syslog server to accept only logging information from particular IP addresses.

By default, logging messages are sent to the router's console port; however, the following locations are also supported: terminal lines, internal memory buffer, SNMP traps, and a syslog server.
Common destinations used by administrators are the logging buffer (RAM), the console terminal, and syslog servers.
Syslog is the most comman, since it enables you to centralize (aggregate) logging messages easily on a server.

The advantage of using syslog is that messages can be stored on a hard drive on the syslog server instead of on the router itself, freeing up router resources.

### Logging Messages

All of Cisco's log messages can contain the following information:

* **528Timestamp**
	* The date and time of the occurrence (optional)
* **Log message name**
	* The name of the message
* **Severity level**
	* The severity level of the log message, embedded in the log name (such as %SYS-5-CONFIG_I, where 5 is the severity level)
* **Message text**
	* A very brief description of the event

```
Nov 19 12:30:00 EST: %SYS-5-CONFIG_I: Configured from console by vty0 (10.0.11.11)
```

In this example, the timestamps have been enabled (they are disabled by default).
This is followed by the category of logging (SYS indicates a system message), the severity level (5), and the subcategory (CONFIG indicates a change on the router). Last is the message text.

### Logging Severity Levels

**Logging Levels**

| Lev | Name          | Desc                                                                                               |
| --- | ------------- | -------------------------------------------------------------------------------------------------- |
| 0   | Emergency     | The router is unusable (IOS can't load)                                                            |
| 1   | Alerts        | The router needs immediate attention; for instance, the temperature is too high                    |
| 2   | Critical      | There is a critical condition; for instance, the router is running out of memory                   |
| 3   | Errors        | An error condition exists, such as an invalid memory size                                          |
| 4   | Warnings      | A warning condition exists; for instance, a crypto operation failed                                |
| 5   | Notifications | A normal event occurred; for instance, an interface changed state                                  |
| 6   | Informational | This is an informational message; for instance, a router dropped a packet because of an ACL filter |
| 7   | Debug         | This is the output of **debug** commands.                                                          |

### Logging Configuration

```
Router(config)# logging [host] {hostname | IP_ADDR}
Router(config)# logging trap LEVEL_NAME_OR_#
Router(config)# logging console LEVEL_NAME_OR_#
Router(config)# logging buffered LEVEL_NAME_OR_#
Router(config)# logging monitor LEVEL_NAME_OR_#
Router(config)# logging facility FACITITY_TYPE
Router(config)# logging source-interface INTERFACE_NAME
Router(config)# logging on
```

* **logging [host]**
	* Defines a syslog server to which log messages are sent
* **logging trap**
	* Defines the severity level at which to log messages.
	* This command must specify the name or number of the level.
	* The level indicates any message at that level or higher. For example, if you set the level to 3, messages from levels 1 to 3 would be logged.
* **logging console**
	* Defines the logging level for the console line
* **logging buffered**
	* Defines the logging level for the log messages stored in the router's RAM
* **logging monitor**
	* Defines the logging level for log messages sent to the router's other lines, such as virtual type terminals (VTYs).
* **logging facility**
	* Directs logging information to the appropriate file on the syslog server.
	* The default is local7, but this can be changes.
	* The facility type enables you to keep different log files for different devices on the same syslog server, making it easier to find log messages.
* **logging source-interface**
	* Specifies which interface on the router will be used to reach the syslog server.
	* By default, the router will use its routing table to determine what interface and thus what source IP address to use, when sending a log message.
	* You may want to configure this command if the router can use multiple interfaces to reach the log server, which the possibility that multiple source IP addresses could be used, but the syslog server is allowing log messages only from one of the router's IP addresses.
* **loggin on**
	* You must enable logging with this command.
	* However, this is not necessary for log messages sent to the console, which is enabled by default.

By default, Cisco IOS devices do not include the local timestamp (date and time) with the syslog messages sent to the syslog server: they rely on the server attaching its time to the message.

To have the IOS device include its own local time, configure the following commands:

```
Router(config)# service timestamps {log | debug} datetime [msec]
```

You can add timestamps to log messages or the output of **`debug`** commands.
The `msec` parameter specifies that the current milliesecond value should be included in the router's timestamped log message.

### Logging Verification

Use the `show logging` command to verify your configuration.

### Logging CLI Example

![[Pasted image 20251102063617.png]]

```
Router(config)# logging 10.0.0.1
Router(config)# logging trap 5
Router(config)# logging source-interface fa0/0
Router(config)# logging on
```

---

## Working with NetFlow

NetFlow is a Cisco-proprietary technology used to classify and identify traffic and to provide statistics for the traffic. Originally it was meant for QoS and traffic managemtn purposes, but it can be used to detect attacks by looking for anomalies in traffic sessions.

Common uses for NetFlow include
* Network traffic accounting
* Useage-based network billing
* Network capacity and planning
* Security
* Denial-of-service (DoS) monitoring capabilities
* Network monitoring and troubleshooting

> NetFlow enables administrators to identify applications causing network congestion, diagnose slow performance, and verify that an application receives the appropriate amount of bandwidth based on its class of service (CoS).

### NetFlow Architecture

A *flow* is basically a session between two devices: the parameters associated with a connection involving information in the layer 3 and layer 4 headers, as well as some other components, to identify a flow.

A flow may involve the following:

* Layer 3 protocol
* Source and destination IP addresses
* Source and destination port numbers
* CoS or ToS information
* Flow timestamp
* Next-hop IP address
* TCP flags

Minimally, a flow must conatain a source IP address, a destination IP address, and an ingress interface.

Cisco uses application-specific integrated circuits (ASICs) to capture the flow information. The technology used by the ASICs, Cisco Express Forwarding (CEF), implements many features to offload processing of the CPU to an interface or a card.
The most common feature of CEF is to offload forwarding of the traffic from the CPU to the ASIC.
Another function of CEF is to create flow information for NetFlow.

Even though ASICs capture the flow information, the IOS device's CPU must be involved in forwarding the flow information to a NetFlow collector: this can be very CPU-intensive.

Some NetFlow information can be examined locally on the IOS device; however, to gather and examine NetFlow information over long periods of time, you need a NetFlow collector (basically a logging server that understands NetFlow information).
The following version are supported by Cisco:

| version | Desc                                                                                                                                                   |
| ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 1       | Original Version of NetFlow                                                                                                                            |
| 5       | The standard and most common implemantation                                                                                                            |
| 7       | Specific to the 6500, 6800, and 7600 products                                                                                                          |
| 8       | Reduces resource useage (summarized flow information)                                                                                                  |
| 9       | Flexible file format to support additional fields and use for IPv6, multiprotocol label switching (MPLs), Border Gateway Protocol (BGP), and multicast |

The most common implementation of NetFlow is version 5, but the most flexible is version 9.
When sending NetFlow information to a collector, you must identify the version used on both the IOS device and collector so that both can understan the flow information.
The NetFlow information is sent using UDP as a transport protocol.

Many, many products in the marketplace can perform the function of a NetFlow collector.
NetFlow collector is a Cisco product that provides a GUI to examine flow information and statistics in a visual format, including bar charts, pie charts, and histograms, to name a few.
One concern with a collector is the number of devices and amount of flow information the collector will receive: you can quickly overburden a collector if you send too much informaiton to it.

### NetFlow Configuration

To configure NetFlow, you must perform the following four tasks:

1. Enable data captureing on an interface: ingress is incomming and egress is outgoing
2. Define the IP address and UDP port of the NetFlow collector.
3. Optionally identify the version of NetFlow to export the flow information
4. Verify the NetFlow configuration, operation, and statistics.

> Even though ASICs capture the flow information using CEF, the flow information must be stored in RAM.
> IOS enables you to define memory limits for NetFlow if you have limited memory on your IOS device. The default cache size depends on the particular Cisco product and platform.

```
## enable NetFlow from the CLI and how to export the information to a NetFlow collector
IOS(config)# ip cef
IOS(config)# interface TYPE
IOS(config-if)# ip flow {ingress | egress}
IOS(config-if)# exit
IOS(config)# ip flow-export version {1 | 5 | 9}
IOS(config)# ip flow-export destination MGMMT_IP UDP_PORT
```

NetFlow version vary based on device and code. As of IOS 12.4, for example, router support only versions 1, 5, and 9.

Most Cisco management stations, acting as collectors, listen on UDP port 9997, by default.
Flow monitors are NetFlow components that enables you to define global Netflow parameters, such as the cache size and the number of unique flow records to collect.
This configuration is then applied to a respective interface.

### NetFlow Verification

```
IOS# show ip interface g1/0/1

...

Input features: Ingress-NetFlow, MCI check
Output features: Egress-NetFlow

...
```

```
## Verify NetFlow configuration and overall status of the NetFlow operation
Router# show ip flow export

## To view a summary of the flow information captures by the IOS device
Router# show ip cache flow
```

---

## Chapter Reivew

The date and time on your router are important for message logging, digital certificates, and many other things, Common methods of accessing NTP information is via multicast messages from a server or unicast query messages from a client. NTPv3 supports authentication of messages using a digital signature created from MD5. It is recommended that you set up your own local master time source.

Many Cisco IOS device support DHCP server and relay agent features. When setting up a server, you create a DHCP pool, which has IP addresses, a DNS server(s), a domain name, a default gateway address, and a lease time.
An addresssing conflict occurs when a server checks to see if an unused address in the pool is being used and determines that it's currently in use by another device.
Conflicts must be manually cleard by an administrator on an IOS device.
DHCP relay is used when the clients and the DHCP server are in different subnets (VLANs); an IOS device can act as a relay between the two devices, interacting with the DHCP server using unicast messages.

SNMP is used to manage devices remotely. The three components of SNMP are the management station (NMS), the agent, and the MIBs. Get, send, and trap/inform messages are used between the NMS and the agent. SNMPv2c supports community strings for security, which are in clear text. SNMPv3 supports message validation, authentication, and encryption of messages, and is thus more secure than SNMPv2c.

Private addresses are defined in RFC 1918: 10.0.0.0/8, 172.16.0.0/16-172.30.0.0/16, and 192.168.0.0/24-192.168.255.0/24.
If you use private addresses, you must have them translated to a public address before packets reach a public network. Address translation is used when you don't have enough public addresses, you change ISPs but keep your existing addresses, you are merging campanies with overlapping address spaces, or you want to assign the same IP address to multiple machines.

| term                     | desc                                           |
| ------------------------ | ---------------------------------------------- |
| inside local IP address  | packets with a private or original IP address  |
| inside global IP address | packets with a public, or translated, address. |

NAT translates one IP address to another while PAT (address overloading) translates many IP addresses to the same global address, where the source port numbers are changed to ensure the translation device can differentiate the connections.
PAR redirects traffic destined to a port on one device to a different device.

Address translation provides access to an almost inexhaustible group of address and enables you to hide your internal network design from outsiders.
It also gives you tighter control over traffic entering and leaving your network.
However, address translation adds some delay to your traffic, makes troubleshooting more difficult, and won't work with all applications, especially multimedia applications.

The `ip nat inside source static` commands sets up static NAT.
The `ip nat inside source list` and `ip nat pool` (add `overload` to do PAT) commands set up dynamic translations.
The `ip nat inside | outside` interface Subconfiguraiton mode commands defines which interfaces are considered internal and external for address translation.

Use the `show ip nat translations` command to view the router's address translation table.
The `clear ip nat translation *` command clears all dynamic address translation entries in the router's translation table.
The `debug ip nat` command will show the translations the IOS is doing on every translated packet.

Logging is used to record events that occur on a device. Logging information can be viewed locally on a device or forwarded to a syslog server.
The logging level of a message indicates its severity, where logging levels range from 0 (emergency) to 7 (debugging).
Logging provides much more information that what is available with SNMP traps and informs.
By default, logging is enabled for the console of IOS device, but it must be manually enabled for other destinations.
Timestamps for logging and debug messages are disabled by default but can be enabled with the `service timestamps` command.

NetFlow, a proprietary Cisco techonology, captures information about flows that can be used for network traffic accounting, accounting/billing based on amount of traffic sent, network capacity planning, network monitoring, and many other network management functions.
A flow is basically a session between two devices and must minimally contain a source IP address, a destination IP address, and an ingress interface.
Cisco uses ASICs to capture the flow information. Cisco supports multiple versions of NetFlow, where version 5 is most common.
The `show ip cache flow` command displays a summary of the session flows, but to gather information historically, an external NetFlow collector is necessary.

---

## Quick Review

## Understanding Network Services

* NTP has three methods of delivering time messages: broadcast, unicast, and multicast.
* NTPv3 supports authentication of messages using MD5 signautres.
* You should set up your own time server, commonly referred to as a local master clock, and implement MD5 authentication with NTPv3
* The three components of SNMP are a manager, an agent, and MIBs.
* An SNMP trap/inform is an alert generated by an agent.
* SNMPv2c uses community strings and added the use of inform and get bulk requests. SNMPv3 adds message integrity, authentication, and encryption.

## Configuring DHCP Services

* A DHCP server assigns IP address parameters to a requesting host. On Cisco IOS DHCP servers, addresses are defined in a pool.
* If you are defining network numbers for your pool, make sure you exclude the network number and the directed broadcast address from the pool.
* IP addresses are leased to hosts, typically on a temporary basis. When a client's current address lifetime reaches the half-live of the lease time, it will attempt to renew the existing addressing information it obtained previously.
* If an address conflict is detected, the address is removed from the DHCP pool and an administrator must manually resolve the problem. Conflicts can be seen by executing the `show ip dhcp conflict` command.

## Network Address Translation

* Reasons to use address translation include not having enough public addresses, changing ISPs, merging networks with overlapping addresses, and representing multiple devices as a single logical device.
* An inside local IP address is a private address assigned to an inside device.
* NAT does one-to-one address translation. PAT translates multiple IP addresses to a single address, using the source TCP/UDE port number to differentiate connections.
* Port address redirection is a form of static PAT, where traffic sent to a specific address and port is redirected to another machine (and possiblity a different port).
* To define inside and outside, use the `ip nat inside | outside` Interface Subconfiguration mode command.
* To configure static NAT, use the `ip nat inside | outside source static` comamnd.
* To set up dynamic NAT, use the `ipo nat inside source list` command, with a standard ACL specifying the inside local address. Add `overload` to this command to do PAT. Use the `ip nat pool` command to specify the global addresses.
* Use the `show ip nat translations` command to view the static and dynamic address translations. Use the `clear ip nat translation *` command to clear the dynamic translations from the address translation table. Use the `debug ip nat` to see the actual translation process.
* When troubleshooting address translation problems, first verify your address translation configuration. Examine the translation table with the `show ip nat translations` command. Use the `show ip nat statistics` command to see whether translations are actually occuring
* Use the `debug ip nat [detailed]` command to see whether translation is occuring or not. Verify that you have correctly configured the router's interfaces for NAT as inside or outside. Use the `show access-lists` command to see whether hit counts appear on the permit statements for packets that should be translated.

## Logging and Syslog

* Common logging destinations used by administrators are the logging buffer (RAM), the console terminal, and syslog servers.
	* The advantage of using syslog is that messages can be stored on a hard drive on the syslog server instead of on the router itself, freeing up router resources.
	* Syslog enables you to centralize (aggregate) logging messages easily on a server.
* Even though SNMP supports traps, the number of traps is limited: logging supports many more types and kinds of messages than are supported by SNMP traps.
* Logging levels are emergency (0), alerts (1), critical (2), errors (3), warnings (4), notifications (5), informational (6), and debug (7).
	* The logging level indicates any message at that level or higher.
	* For example, if you set the level to 3, messages from level 1 to 3 would be logged.
* The default facility level is local7.
* The `service timestamps` commands enable the addition of the local date, time, and, optionally, milliseconds to the logging or debug records.

## Working with NetFlow

* NetFlow enables administrators to identify applications causing network congestion, diagnose slow performance, and verify that an application receives the appropriate amount of bandwidth based on its class of service (CoS).
* NetFlow benefits include network, application, and user monitoring; network planning; and accounting/billing.
* Minimally, a flow must contain a source IP address, a destination IP address, and an ingress interface. Traffic is considered in the same flow if the packets contain the same IP addressing, port numbers, and layer 3 protocol information.
* Sending flow information to a collector can be CPU-intensive.
* Once concern with a collector is the number of devices and amount of flow information the collector will receive.
* Flow monitors are NetFlow components that enable you to globally define NetFlow parameters, such as the cache size and the number of unique flow records to collect, which are then applied to a respective interface.
* The `show ip cache flow` command displays the general NetFlow data captured by an IOS device.

---

### Questions

1.  Which IOS command defines an NTP server?

**A. ip ntp server**
B. ntp server
C. ntp-server
D. 540ip ntp-server

2.  Which IP addresses should be excluded from a DHCP server pool? (Choose two.)

A. All the DHCP servers IP addresses
**B. The subnet number**
**C. The directed broadcast address**
D. DHCP client address

The network and directed broadcast addresses should be excluded as well as statically assigned IP addresses, including the default gateway address of the subnet/VLAN (the subnet number).

3.  The _______ IOS command must be executed to enable the DHCP server and/or relay agent features if they were previously disabled.

`service dhcp`

The `service dhcp` command must be executed to enable the DHCP server and/or relay agent features if they were previously disabled.

4. Which of the following are components of SNMP? (Choose three.)

**A. Agent**
**B. Manager**
C. NetFlow
D. Syslog
**E. MIB**

5.  Enter the IOS command to enable logging to destinations other than the console: `_________`. 

`logging on`

6. What are two of the common logging destinations used by administrators on Cisco devices? (Choose two.)

A. TFTP server
B. Terminal sessions
**C. Syslog servers**
**D. RAM**
E. Flash

Common logging destinations used by administrators are the logging buffer (RAM), the console terminal, and syslog servers.

7.  A NetFlow flow must minimally contain which items? (Choose two.)

**A. IP address**
B. Port numbers
**C. Ingress interface**
D. CoS

Minimally, a flow must contain a source IP address, a destination IP adree and an ingress interface

8.  Version ________ is the most common implementation of NetFlow. 

5

9. `__________` translates one (and only one) IP address to another.

**A. NAT**
B. PAT
C. PAR
D. NAT and PAT

10.  An `__________` is a public IP address associated with an inside device.

**A. Inside global IP address**
B. Inside local IP address
C. Outside global IP address
D. Outside local IP address

11.  Which command is used to define the local addresses that are statically translated to global addresses?

**A. ip nat inside source static**
B. ip nat inside
C. ip nat inside source list
D. ip nat pool

12.  You have 30 internal machines that need to access the Internet: 192.168.1.32/27. Youve been given six public IP addresses for this access: 199.1.1.41199.1.1.46. Interface fastethernet0/0 is connected to the inside and serial1/0 to the ISP on your router. Enter the commands to perform PAT with this information.

```
ip nat pool mypool 199.1.1.41 199.1.1.46 netmask 255.255.255.248
access-list 1 permit 192.168.1.32 0.0.0.31
ip nat inside source list pool mypool overload
interface F0/0
ip nat inside
interface serial1/0
ip nat outside
```

13.  When configuring the ip nat inside source command, which parameter must you specify to perform PAT?

A. pat
**B. overload**
C. load
D. port

12.  When working with QoS, which DiffServ value is placed in the DSCP field by the IP phone for VoIP traffic by default?

A. AF22
B. ToS
C. CS0
**D. EF**

### Performance-based Questions

1.  Using the following exhibit, write each characteristic listed on the left into the appropriate box on the right.

![[Pasted image 20251104192423.png]]

* **DHCP**
	* Used to automatically assign IP addresses to hosts
	* Uses UDP ports 67 and 68
* **DNS**
	* Resolves FQDNs to IP addresses
	* Uses UDP port 53

2.  Using the following exhibit, place the DHCP phases in the correct order.

![[Pasted image 20251104192440.png]]

1. DHCP Discover
2. DHCP Offer
3. DHCP Request
4. DHCP Acknowledge
