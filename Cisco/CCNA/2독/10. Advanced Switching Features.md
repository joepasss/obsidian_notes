
Most larger networks implement redundancy to protect data in case of failures; redundancy can involve multiple wide area network (WAN) connections, multiple paths in you layer 3 network, and/or multiple paths in your layer 2 network.

## VLAN Trunking Protocol

The VLAN Trunking Protocol (VTP) is a proprietary Cisco protocol used to share virtual local area network (VLAN) configuration information between Cisco switches on trunk connections.

VTP enables switches to share and synchronize their VLAN information, which ensures that your network has a consistent VLAN configuration.

Assume, for instance, that your network has two switches, and you need to add a new VLAN.
You could easily accomplish this by adding the VLAN manually on both switches.
However, this process becomes more difficult and tedious if you have 30 switches to deal with.
In this situation, you could make a mistake in configuring the new VLAN on one of the switches, such as giving it the wrong VLAN identifier, or you might forgot to add the new VLAN to one of the 30 switches.

VTP can take care of these issues. With VTP, you can add the VLAN on one switch and have this switch propagate the new VLAN, via VTP messages, to all other switches in your layer 2 network, causing them to add the new VLAN also.

This is also true if you modify a VLAN's configuration or delete a VLAN, VTP can verify that your VLAN configuration is consistent across all of your switches.
VTP can even perform consistency checks with your VLANs to make sure that all the VLANs are configured identically.

Components of a VLAN can include a VLAN number, name, and type. So, for example, if you have a VLAN number of 1 and a name of "admin" on one swithc, but the name "administrator" is used on a second switch for the same VLAN 1, VTP checks for and fixes the configuration mismatches.

VTP messages will propagate *only* across *trunk* connections, so you will need to set up trunking between your switches in order to share VLAN information via VTP.
VTP messages are propagated as layer 2 multicast frames by layer 2 devices.
Therefore, if a router separates two of your switches, the router will *not* forward the VTP messages from one of its interfaces to another because it is a layer 3 device.

For VTP to function correctly, you must associate your switch with a *VTP domain*.
A domain is a group of switches that have the same VLAN information applied to them.
Basically, a VTP domain is similar to an autonomous system, which is used by some routing protocols.

A switch can belong only to a single VTP domain. VTP domains are given names, and when switches generate VTP messages, they include the VTP domain name in their messages.
When VTP message is received by a switch, the VTP message is only processed if the VTP domain in the message is the same as the VTP domain name configured on the switch.
In other words, a switch in one VTP domain will ignore VTP messages from switches in other VTP domains.

### VTP Modes

When you are setting up VTP, you can choose fro three different modes for your switch's configuration:

* Client
* Server
* Transparent

| Desc                                 | Server | Client | Trans. |
| ------------------------------------ | ------ | ------ | ------ |
| Can add, modify, and delete VLANs    | Y      | N      | Y      |
| Can generate VTP messages            | Y      | N      | N      |
| Can propagate VTP messages           | Y      | Y      | Y      |
| Can accept changes in a VTP messages | Y      | Y      | N      |
| Default VTP mode                     | Y      | N      | N      |
| Saves VLANs to NVRAM                 | Y      | N      | Y      |

A switch configured in either VTP server or transparent mode can add, modify, and delete VLANs.

The main difference between these two modes is that the configuration changes made to a transparent switch affect only *that* switch and no other switch in the network.

A VTP server switch, however, will make the change and then propagate a VTP message concerning the change to all of its trunk ports.
If a server switch receives a VTP message, it will incorporate the update and forward the message out its remaining trunk ports.

A transparent switch, on the other hand, ignores VTP messages, it will accept them on trunk ports and forward them out its remaining trunk ports, but it will not incorporate the changes in the VTP message in its local VLAN configuration.

A VTP client switch cannot make changes to its VLAN configuration itself, it requires a server switch to tell it about the VLAN changes.
When a client switch receives a VTP message from a server switch, it incorporates the changes and then floods the VTP message out its remaining trunk ports.

Normally, you would set up one switch in server mode and all other switches in client mode.
Then you would control who could make changes on the server switch.
However, you should keep in mind that if you make a VLAN configuration mistake on the server switch, this mistake is *automatically propagated* to the all client switchs in your network.

Given this and similar problems, some administrators don't like to use VTP server and client modes; they prefer to configure all of their switches in transparent mode.
The problem with transparent mode, however, is that it isn't very scaleable; if you need to add a VLAN to your network and your network has 20 switches, you would have to add the VLAN manually to each individual switch, which is a time-consuming process.

You could also set up all of your switches in server mode, which is the default setting for VTP.
You could even mix and match these options, set up a couple of server switches, and have the remaining switches as clients, or set your switches initially as servers and clients, add all your VLANs on the server switche, allow the clients to acquire this information, and then change all the switches to transparent mode.
This process allows you to populate your switches' configuration easily with a consistent VLAN configuration during the setup process.

Note if you don't specify the VTP mode for your switch, it will default to *server*.

### VTP Messages

If you use a client/server configuration for VTP, these switches can generate three types of VTP messages:

* Advertisement request
* Subset advertisement
* Summary advertisement

*Advertisement request*
VTP message a client generates to acquire VLAN information, to which server will respond.
When the server respond to a client's request, it generates a *subset advertisement*. This subset advertisement contains detaild VLAN configuration information, including the VLAN members, names, types, and other information.
The client will then configure itself appropriately.

*Summary advertisement*
Generated by a switch in VTP server mode.
Summary advertisements are generated every 5 minutes (300 seconds) by default, or when a configuration change takes place on the server swithc.
Unlike a subset advertisement, a summary advertisement contains only summarized VLAN information.

When a server switch generates a VTP advertisement, it can include the following information:

* The number and name of the VLAN
* The maximum transmission unit (MTU) size used by the VLAN
* The frame format used by the VLAN
* The Security Association idetntifer (SAID) value for the VLAN (needed if it is an 802.10 VLAN, which is implemented in networks using Fiber Distributed Data Interface, FDDI)
* The configuration revision number
* The name of the VTP domain

This list includes a couple of important items that need further discussion. Switches in either server or client mode will process VTP messages if they are in the same VTP domain; however, some restrictions are placed on whether the switch should incorporate the changes or not.

For instance, one function of the VTP summary advertisements is to ensure that all of the switches have the most current changes.
If you didn't make a change on a server switch in the five-minute update interval, when the countdown timer expires, the server switch still sends out a summary advertisement with the same exact summary information.
If makes no sense to have other switche, which have the most up-to-date information, incorporate the same information in their configuration.

To make this process more efficient, the *configuration revision number* is used to keep track of what server switch has the most recent changes.
Initially this number is set to zero (0). If you make a change on a server switch, it increments its revision number and advertises this to the other switches across its trunk links.
When a client or server switch receives this information, it compares the revision number in the message to the last message it received.
If the newly arrived message has a higher number, this server switch must have made changes.
If the necessary VLAN information isn't in the VTP summary advertisement, all client and server switches will generate and advertisement request and the server will respond with the details in a subset advertisement.

If a server switch receives a VTP message from another server, and the advertising server has a lower revision number, the receiving server switch will respond to the advertising server with a VTP message with its current configuration revision number.
This will tell the advertising server switch that it dosen't have the most up-to-date VLAN information and should request it from the server that does.
In this sense, the revision number used in a VTP message is some what similar to the sequence number used in TCP.

Also, remember that transparent switches are not processing these VTP advertisements, they simply passively forward these messages to other switches on their trunk ports.

### VTP Pruning

VTP pruning is a Cisco feature that enables your switches to delete or add VLANs to trunk dynamically, creating a more effcient switching network.

By default, all VLANs are associated with a trunk connection.
This means that if a device in *any* VLAN generates a broadcast, a multicast, or an unknown unicast, the switch will flood this frame out all ports associated with the source VLAN port, including trunks.

In many situations, this flooding is necessary, especially if the VLAN spans multiple switches.
However, its dosen't make sense to flood a frame to a neighboring switch if that switch doesn't have any active ports in the source VLAN.

#### Trunking Without Pruning

**Trunking without VTP pruning**
![[Pasted image 20251015042825.png]]

In this example, VTP pruning is not enabled. PC-A, PC-B, PC-E, and PC-F are in the same VLAn.
If PC-A generates a broadcast, SwitchA will forward this to the access link to which PC-B is connected as well as the trunk (since a trunk is a member of all VLANs, default).

Second VLAN with two members: PC-C and PC-D. If PC-C generates a local broadcast, SwitchA will obviously send to this to PC-D's port.
What dosen't make sense is that SwitchA will flood this broadcast out its trunk port to SwitchB, considering that no devices on SwitchB are in this VLAN.

This is an example of wasting bandwidth and resources. A single broadcast isn't a big problem in this example; however, if a video multicast stream at 5 Mbps was comming from PC-A, the network could experience throughput problems on the trunk, since a switch treats a multicast just like a broadcast, it floods it out all ports associated with the source port's VLAN.

You could use one of two methods to fix this problem: static VLAN pruning or dynamic VLAN pruning.

With a static configuration, you would manually prune the incative VLAN off the trunk on both switches.
The problem with manual pruning is that if you add a dark VLAN (indicated by dotted lines) member to SwitchB, you will have to log into both switches and manually add the pruned VLAN back to the trunk.
This can become very confusing in a multiswitched network with multiple VLANs, where every VLAN is not necessarily active on every swtich.
It would be easy to prune a VLAN accidentally from a trunk that shouldn't have been pruned, thus creating connectivity problems.

#### Trunking with Pruning

The VTP pruning feature enables the switches to share additional VLAN information and to prune inactive VLANs dynamically from trunk connections.
In this instance, the switches share which VLANs are active.

For example, SwitchA tells SwitchB taht it has two active VLANs.
SwitchB, on the other hand, has only one active VLAN, and it shares the fact with SwtichA.
Given the shared information, both SwitchA and SwitchB realize that the dark VLAN is inactive across thier trunk connection, and therefore the dark VLAN should be dynamically removed from the trunk's configuration.

The nice thing about this feature is that if you happen to active the dark VLAN on SwitchB by connecting a device to a port on the switch and assigning that port to the dark VLAN, SwitchB will notify the newly active VLAN, and both switches will dynamiclly add the VLAN back to the trunk's configuration.

Only a VTP switch in *server* mode can enable VTP pruning, and the remaining switches in the domain must be either in VTP server or client mode.
If you have transparent mode switches, you'll have to prune VLANs off their thrunk lines manually.

### Management VLAN

Unlike Cisco routers, every Cisco switch comes with a default configuration.
For instance, some preconfigured VLANs are already on the switche, including VLAN 1.

During the configuration, all VLAN commands refer to the VLAN number, even though you can configure an optional namve for the VLAN.
Every port on your switch, by default, is associated with VLAN 1.
And all commnuications from the switche itself, VTP messages, Cisco Discovery Protocol (CDP) multicasts, and other traffic the switch originates occur in VLAN 1.
Cisco switch's IP configuration is based on the VLAN interface for which you configure your IP address.

VLAN 1 is sometimes called the *management VLAN*, even though you can use a different VLAN.
It is a common practice to put all of your management devices (switches, and managemet stations) in their own VLAN.

If you decide to put your switch in a different VLAN than VLAN 1, it is recommended that you change this configuration on all your management devices so that you can more easily secure them, since other VLANs would have to through a layer 3 device to access them; and on this layer 3 device, you can set up access control lists to filter unwanted traffic.

It is important that all your switches are in the same management VLAN, since many of the switches' management protocols, such as CDP, VTP, and the Dynamic Trunk Protocol (DTP), occur within the switch's management VLAN.
If one switch has its management VLAN set to 1 and another connected switch has its management VLAN set to 2, the two switches would lose a lot of interswitch functionality.

### Configuring VTP

If troubleshooting an existing network setup or configuring VTP yourself, it is important to understand the common VTP parameters and their values.

**default VTP configuration for Cisco Switches**

| VTP Component | Default value |
| ------------- | ------------- |
| Domain name   | None          |
| Mode          | Server        |
| Password      | None          |
| Purning       | Disabled      |
| Version       | 1             |

You configure VTP from Global configuration mode on the Cisco switch:
```
Switch(config)# vtp domain VTP_DOMAIN_NAME
Switch(config)# vtp mode server|client|transparent
Switch(config)# vtp password VTP_PASSWORD
Switch(config)# vtp pruning
```

The **`vtp domain`** command defines the domain name for your switche.
In order for switches to share VTP information, they must be in the same domain.
Messages received from other domains are ignored.

If you don't configure a domain name, the switch will learn this from a server advertisement.

The rest of commands in the configuration are optional.
The second `vtp` command defines the VTP mode of the switch. If you don't configure this command, the default mode is server mode.

You can configure a VTP MD5 password for your switches, which must match the password configured on every switch in the domain.
Switches will use this password to verify VTP messages from other switches; if the created hashed values placed in VTP messages (generated by running the VTP message and password through MD5 to create the hash signature) can'b be verified, the switches ignore the VTP messages.

On most switches, pruning is disabled by default, but you can disable or enable it with the `vtp pruning` command.
It is important to note that if pruning is enabled on a server switche, the server switch will propagate this to all other server and client switches in the same domain.

Once you are done configuring VTP, use the `show vtp status` command to check your configuration.
Use the `show vtp counters` command to display VTP statistics concerning VTP messages sent and received.

### Exercise 10-1: Working with VTP

![[Pasted image 20251016025213.png]]

**VAN-SW1**
```
### configure trunk port
VAN-SW1#config t
Enter configuration commands, one per line.  End with CNTL/Z.
VAN-SW1(config)#interface E0/0
VAN-SW1(config-if)#switchport trunk encap dot1q
VAN-SW1(config-if)#switchport mode trunk
VAN-SW1(config-if)#

### VAN-SW1 as VTP server
VAN-SW1(config)#vtp domain Lab101
Changing VTP domain name from NULL to Lab101
VAN-SW1(config)#vtp mode server
Device mode already VTP Server for VLANS.
VAN-SW1(config)#vtp password vtppass
Setting device VTP password to vtppass

### verify VTP settings
VAN-SW1(config)#do show vtp status
VTP Version capable             : 1 to 3
VTP version running             : 1
VTP Domain Name                 : Lab101
VTP Pruning Mode                : Disabled
VTP Traps Generation            : Disabled
Device ID                       : aabb.cc00.0300
Configuration last modified by 0.0.0.0 at 0-0-00 00:00:00
Local updater ID is 0.0.0.0 (no valid interface found)

Feature VLAN:
--------------
VTP Operating Mode                : Server
Maximum VLANs supported locally   : 1005
Number of existing VLANs          : 5
Configuration Revision            : 0
MD5 digest                        : 0xE8 0x62 0x51 0x4D 0xB3 0x28 0xC9 0x4E
                                    0x57 0x93 0x79 0x59 0xBA 0x80 0x27 0xBC

### show vlans
VAN-SW1(config)#do show vlan

VLAN Name                             Status    Ports
---- -------------------------------- --------- -------------------------------
1    default                          active    Et0/1, Et0/2, Et0/3, Et1/0
                                                Et1/1, Et1/2, Et1/3, Et2/0
                                                Et2/1, Et2/2, Et2/3, Et3/0
                                                Et3/1, Et3/2
1002 fddi-default                     act/unsup
1003 token-ring-default               act/unsup
1004 fddinet-default                  act/unsup
1005 trnet-default                    act/unsup

VLAN Type  SAID       MTU   Parent RingNo BridgeNo Stp  BrdgMode Trans1 Trans2
---- ----- ---------- ----- ------ ------ -------- ---- -------- ------ ------
1    enet  100001     1500  -      -      -        -    -        0      0
1002 fddi  101002     1500  -      -      -        -    -        0      0
1003 tr    101003     1500  -      -      -        -    -        0      0
1004 fdnet 101004     1500  -      -      -        ieee -        0      0
1005 trnet 101005     1500  -      -      -        ibm  -        0      0

Primary Secondary Type              Ports
------- --------- ----------------- ------------------------------------------

### create two vlans (vlan 2: Sales, vlan 3: Mkt)
VAN-SW1(config)#vlan 2
VAN-SW1(config-vlan)#name Sales
VAN-SW1(config-vlan)#vlan 3
VAN-SW1(config-vlan)#name Mkt
VAN-SW1(config-vlan)#exit

### verify
VAN-SW1(config)#do show vlan brief

VLAN Name                             Status    Ports
---- -------------------------------- --------- -------------------------------
1    default                          active    Et0/1, Et0/2, Et0/3, Et1/0
                                                Et1/1, Et1/2, Et1/3, Et2/0
                                                Et2/1, Et2/2, Et2/3, Et3/0
                                                Et3/1, Et3/2
2    Sales                            active
3    Mkt                              active
1002 fddi-default                     act/unsup
1003 token-ring-default               act/unsup
1004 fddinet-default                  act/unsup
1005 trnet-default                    act/unsup
VAN-SW1(config)#
```

**VAN-SW2**
```
### check vlan
VAN-SW2#show vlan brief

VLAN Name                             Status    Ports
---- -------------------------------- --------- -------------------------------
1    default                          active    Et0/1, Et0/2, Et0/3, Et1/0
                                                Et1/1, Et1/2, Et1/3, Et2/0
                                                Et2/1, Et2/2, Et2/3, Et3/0
                                                Et3/1, Et3/2
1002 fddi-default                     act/unsup
1003 token-ring-default               act/unsup
1004 fddinet-default                  act/unsup
1005 trnet-default                    act/unsup

### check vtp status
VAN-SW2#show vtp status
VTP Version capable             : 1 to 3
VTP version running             : 1
VTP Domain Name                 :
VTP Pruning Mode                : Disabled
VTP Traps Generation            : Disabled
Device ID                       : aabb.cc00.0400
Configuration last modified by 0.0.0.0 at 0-0-00 00:00:00
Local updater ID is 0.0.0.0 (no valid interface found)

Feature VLAN:
--------------
VTP Operating Mode                : Server
Maximum VLANs supported locally   : 1005
Number of existing VLANs          : 5
Configuration Revision            : 0
MD5 digest                        : 0x57 0xCD 0x40 0x65 0x63 0x59 0x47 0xBD
                                    0x56 0x9D 0x4A 0x3E 0xA5 0x69 0x35 0xBC
*** MD5 digest checksum mismatch on trunk: Et3/3 ***


### configure VTP as client
VAN-SW2#config t
Enter configuration commands, one per line.  End with CNTL/Z.
VAN-SW2(config)#vtp mode client
Setting device to VTP Client mode for VLANS.
VAN-SW2(config)#vtp password vtppass
Setting device VTP password to vtppass

### VLAN verify
VAN-SW2#show vlan

VLAN Name                             Status    Ports
---- -------------------------------- --------- -------------------------------
1    default                          active    Et0/1, Et0/2, Et0/3, Et1/0
                                                Et1/1, Et1/2, Et1/3, Et2/0
                                                Et2/1, Et2/2, Et2/3, Et3/0
                                                Et3/1, Et3/2, Et3/3
2    Sales                            active
3    Mkt                              active
1002 fddi-default                     act/unsup
1003 token-ring-default               act/unsup
1004 fddinet-default                  act/unsup
1005 trnet-default                    act/unsup

VLAN Type  SAID       MTU   Parent RingNo BridgeNo Stp  BrdgMode Trans1 Trans2
---- ----- ---------- ----- ------ ------ -------- ---- -------- ------ ------
1    enet  100001     1500  -      -      -        -    -        0      0
2    enet  100002     1500  -      -      -        -    -        0      0
3    enet  100003     1500  -      -      -        -    -        0      0
1002 fddi  101002     1500  -      -      -        -    -        0      0
1003 tr    101003     1500  -      -      -        -    srb      0      0
1004 fdnet 101004     1500  -      -      -        ieee -        0      0
1005 trnet 101005     1500  -      -      -        ibm  -        0      0

Primary Secondary Type              Ports
------- --------- ----------------- ------------------------------------------

### VTP status verify
VAN-SW2#show vtp status
VTP Version capable             : 1 to 3
VTP version running             : 1
VTP Domain Name                 : Lab101
VTP Pruning Mode                : Disabled
VTP Traps Generation            : Disabled
Device ID                       : aabb.cc00.0400
Configuration last modified by 0.0.0.0 at 10-16-25 03:25:55

Feature VLAN:
--------------
VTP Operating Mode                : Client
Maximum VLANs supported locally   : 1005
Number of existing VLANs          : 7
Configuration Revision            : 2
MD5 digest                        : 0x91 0x60 0xF6 0x3E 0xD4 0xFF 0x09 0x7F
                                    0x64 0x4C 0x00 0x0A 0xF6 0x04 0xC6 0x00
VAN-SW2#

```

---

## Spanning Tree Protocol

The main function of STP is to remove layer 2 loops from your topology, logically speaking, Digital Equipment Corporation (DEC), now a part of Hwelett-Packard (HP), originally developed STP.
The Institue of Electrical and Electronices Engineers (IEEE) enhanced the initial implementation of STP, giving us the IEEE 802.1d standard.

Because the two different implementations of STP, DEC STP and 802.1d, are not compatible with each other, you need to make sure that all your devices support either one or the other.

Additions were made to 802.1d, including Rapid STP (RSTP) and Multiple STP (MSTP).
Based on these inclusions, the IEEE implementation today is referred to as 802.1D.

All of Cisco's switches support the IEEE 802.1D protocol, which is enabled by default on their switches when sending out untagged frames (the native VLAN).
If you have a mixed-vendor environment where some devices are running 802.1D and others are running DEC's STP, you may run into layer 2 looping problems.

> Typically IEEE uses a lowercase letter, such as d, to indicate a draft or ongoing development state and uses an uppercase leeter, such as D, to indicate finalized standard.

### Bridge Protocol Data Units

For STP to function, the switches need to share information about themselves and their connections.
What they share are Bridge Protocol Data Units (BPDUs), which are sent out as *multicast* frames to which only other layer 2 switches or bridges are listening.

Switches will use BPDUs to learn the topology of the network: what switch is connected to other switches, and whether any layer 2 loops are based on this topolgy.

To prevent loops on the network, the switches will logically disable a port or ports in the topology to ensure that there are no loops.
Note that the switches don't actually shut down the port(s), but they place the por(s) in special disabled state for user traffic.

When the port is placed in this special disabled state, the loop on the network is prevented and data can only travel one pathway between the swtiches.
If any changes occur on the layer 2 network (a link goes down, a new link is added, a new switche is added, or a switche fails), the switches will share this information, causing the STP algorithm to be re-executed, and a new loop-free topology is then created.

By default, BPDUs are sent out every two seconds. This helps speed up convergence.
*Convergence* is a term used in networking to describe the amount of time it takes to deal with changes and get the network back up and running.
The shorter the time period to find and fix problems, the quicker your network is back online.
Setting the BPDU advertisement time to two seconds enables changes to be quickly shared with all the other switches in the network, reducing the amount of time any disruption would create.

BPDUs contain a lot of information to help the switches determine the topology and any loops that result from that topolgy.
For instance, each bridge has a unique identifier, called a *bridge* or *switch ID*. This is typically the priority of the switch and the MAC address of the switch itself.
When a switch advertise a BPDU, it places its switch ID in the BPDU so that a receiving switch can tell from which switch it is receiving topology information.

> STP is a layer 2 protocol that is used to prevent loops on the network.
> STP implements the IEEE 802.1d standard, which involves having switches exchange BPDUs to help detect loops on the network.
> *Bridge Protocol Data Unit (BPDU)* messages are special frames sent between switches to share information that is necessary to configure and maintain a loop-free network with spanning tree.
> BPDU messages are sent out as multicasts every two seconds.
> BPDU contains information about ports and switches on the network.

### Root Switch

STP is used to find and remove loops from a layer 2 network.

The STP algorithm works in a way that's similar to how link state routing protocols, such as Open Shortest Path First (OSPF), ensure that no layer 3 loops are created; of course, STP deals only with layer 2 loops.

A spanning tree is created first. Basically, a spanning tree is an inverted tree.
At the top of the tree is the root, or what is referred to in STP as the *root switch* or *bridge*.

From the root switch, branches (physical Ethernet connections) extened and connect to other switches, then branches from these switches connect to other switches, and so on.

**Physical layer 2 looped topology**
![[Pasted image 20251016034817.png]]

When STP is run, a logical tree structure is built.

**Logical layer 2 STP topology**
![[Pasted image 20251016034840.png]]

Switch A is the root switch and is at the top of the tree.

Underneath it are two branches connecting to Switch-B and Switch-C.
These two switches are connected to Switch-E, creating a loop.
Switch-B is also connected to Switch-D.

At this point, STP still running, and a loop stil exists. As STP runs, the switches will determine, out of the four switches which port on these switches will be logically disabled in order to remove the loop.
This ensures that from one device to any other device in the network, only one path will be used to connect the devices.

Actually, the very first step in STP is to elect the root switch.
BPDUs are used for the election process, when a device advertises a BPDU, the switch puts its switch ID in the BPDU.
The switch ID is used to elect the root switch. The switch with the *lowest* switch ID is chosen as root.

The switch ID is made up of two components:

* The switch's priority, which defaults to 32,768 on Cisco switches (2 bytes in length)
* The switch's MAC address (6 bytes in length)

With Cisco switches, the default priority is 32,768, which is defined by IEEE 802.1d. Assuming that all your switches are Cisco switches and you don't change the default priority, the switch with the *lowest* MAC address will be chosen as the root switch.

You can override the election process by changing the priority value assigned to a switch.
If you want one switch to be the root, assign it a priority value that is lower than 32,768.

Through the sharing of the BPDUs, the switches will figure out which switch has the lowest switch ID, and that switch is chosen as the root switch.
Note that this election process is taking place almost simultaneously on each switch, where each switch will come up with the same result.

For Cisco Catalyst switches that implement VLANs, the switches will have a different switch ID *per* VLAN and a *separate* instance of STP *per* VLAN. Each VLAN has its own root switch.
And within each VLAN, STP will run and remove loops in that particular VLAN.
Cisco calls this concept *per-VLAN STP (PVST)*.

The election process of the root switch takes place each time a topology change occurs in the network, such as the failure of a root switch or the addition of a new switch.

All the other switches in the layer 2 topology expect to see BPDUs from the root switch within the *maximum age time*, which defaults to 20 seconds.
If the switches don't see a BPDU message from root within this period, they assume that the root switch has failed and will begin a new election process to choose a new root switch.

### Root Port

After the root switch is elected, every other switch in the network need to choose a single port on itself that it will use to reach the root.
This port on each switch is called the *root port*.

For some switches, this is very easy. However, each of the other switches, may have two or more ports it can use to reach the root switch.
If a multiple port choices are available, an intelligent method needs to be used to choose the best port.

With STP, a few factors are taken into consideration when choosing a root port.
It is important to note that the root switch itself will never have a root port.

#### Port Costs and Priorities

First, each port is assigned a *port cost*. The lower the cost, the more preferable the port.

**Port Costs for STP**

| Connection Type | Cost Value |
| --------------- | ---------- |
| 10 Gbps         | 2          |
| 1 Gbps          | 4          |
| 100 Mbps        | 19         |
| 10 Mbps         | 100        |

The cost is an inverse reflection of the bandwidth of the port.
Switches always prefer lower cost ports over higher cost ones.

Each port also has a priority assigned to it, called *port priority* value, which defaults to 32.

#### Path Costs

*Path costs* are calculated from the root switch. A path cost is basically the accumulated port costs from the root switch to other switches in the topology.

When the root advertises BPDUs out its interfaces, the default path cost value in the BPDU frame is 0.
When a connected switche receives this BPDU, it increments the path cost by the cost of its local incomming port.

If the port was a Fast Ethernet port, then the path cost would be figured like this: 0 (the root's path cost) + 19 (the switch's port cost) = 19.
This switch, when it advertise BPDUs to switches behind it, will include the updated path cost.

As the BPDUs propagate farther and farther from the root switch, the accumulated path cost values become higher and higher.

#### Root Port Selection

If a switch has two or more choices of paths to reach the root, it needs to choose one path and thus have one root port.
A switch will go through the following STP steps when choosing a root port:

1. Choose the path with the *lowest* accumulated path cost to the root when it has a choice between two or more paths to reach the root.
2. If a multiple paths to the root are available with the same accumulated path cost, the switch will choose the neighboring switch (that the switch would go through to reach the root) with the *lowest* switch ID value.
3. If multiple path all go through the same neighboring switch, it will choose the local port with the lowest priority value.
4. If the priority values are the same between the ports, the switch will choose the physically lowest numbered port on the switch.

After going through this selection process, the switch will have one, and only one, port that will become its root port.

### Designated Port

You now know that each switch has a single port that it uses to reach the root switch.
In addition to each switch having a root port, each segment also has a single port that it uses to reach the root, and this port is called a *designated port*.

For example, that a segment has two switches connect to it. Either one or the other switch will forward traffic from this segment to the rest of the network.

The third step in running STP is to elect a desgnated port on a single switch for each segment in the network.
The switch (and its port) that is chosen should have the best path to the root switch.

Steps taken by switche in determining which port on which switch will be chosen as the designated port for a particular LAN segment:

1. The connected switch on the segment with the lower accumulated path cost to the root switch will be used
2. If there is a tie in accumulated path costs between two switches, the switch with the lowest switch ID will be chosen
3. If it happens that it is the same switch, but with two separate connections to the LAN segment, the switch port with the lowest priority is chosen
4. If there is still atie (the priorities of the ports on this switch are the same), the physically lowest numbered port on the switch is chosen.

After going through these steps for each segment, each segment will have a single designated port on a connected switch that it will use to reach the root switch.

Somethimes the switch that contains the designated port is called a *designated switch*. This term is misleading, through, since it is a port on the switch that is responsible for forwarding traffic.
A switch may be connnected two segments, but it may be the designated switch for only one of those segments; another switch may provide the designated port for the second segment.

*Every* active port on the root switch is a designated port.
This make sense, because the cost of the attached network segments to reach the root is 0, the lowest accumulated cost value.
In other words, each of these LAN segments is directly attached to the root switch, so in reality, it costs noting for the segment to reach the root switch itself.

### Port States

A port can be in one of five states when it is participating in STP:

* Blocking
* Listening
* Learning
* Forwarding
* Disabled

Of the five states, only the first four are used when the algorithm is running.

#### Blocking State

Ports will go into a *blocking* state under one of three conditions:

* During election of a root switch
* When a switch receives a BPDU on a port that indicates a better path to the root switch than the port which the switch is currently using to reach the root
* If a port is not a root port or a designated port

A port in a blocking state will remain there for 20 seconds by default (the maximum age timer). During this state, the port is listening to and processing only BPDUs on its interfaces.
Any other frames that the switch receives on a blocked port are dropped.

In a blocking state, the switch is attempting to figure out which port is going to be the root port, which ports on the switch need to be designated ports, and which ports will remain in a blocking state to break up any loops.

#### Listening State

After the 20-second timer expires, a root port or a designated port will move to a *listening* state. Any other port will remain in a blocking state.

During the listening state, the port is still listening for BPDUs and double-checking the layer 2 topology.
Again, the only traffic that is being processed on a port in this state consists of BPDUs; all other traffic is dropped.
A port will stay in this state for the length of the *forward delay timer*. The default for this value is 15 seconds.

#### Forwarding State

Finally, after the foward delay timer expires, ports that were in a learning state are placed in a *forwarding* state.

In a forwarding state, the port will process BPDUs, update its MAC address table with frames that it receives, *and* forward user traffic through the port.

#### Disabled State

The *disabled* state is a special port state. A port in a disabled state is not participating in STP.
This could be because the port has been manually shut down by an administrator, manually removed from STP, disabled because of security issues, or rendered nonfunctional because of a lack of a physical layer signal (such as the patch cable being unplugged).

> blocking (20 seconds), listening (15 seconds), learning (15 seconds), and forwarding.
> It can take 30 to 50 seconds for STP convergence to take place.
> STP must recalculate if a new root is discovered or a topology change occurs in the network (a new switch added or a change in the state of a port on a switch occurs).
> Also, in blocking and listening states, only BPDUs are processed. In a learning state, the MAC address table is being built. In a forwarding state, user frames are moved between ports.
> STP leaves ports in a blocking state to remove loops

### Layer 2 Convergence

As you should have noticed in the last section, STP goes through a staged process, which *slows down* convergence.

For switches, convergence occurs once STP has completed: a root switch is elected, root and designated ports have been chosen, the root and designated ports have been placed in a forarding state, and all other ports have been placed in a blocking state.

If a port has to go through all four states, convergence takes 50 seconds: 20 seconds in blocking, 15 seconds in listening, and 15 seconds in learning.

If a port doesn't have to go through the blocking state but starts at a listening state, convergence takes only 30 seconds.
This typically occurs when the root port is still valid but another topology change has occurred.

Remeber that during this time period (until the port reaches a forwarding state), no user traffic is forwarded through the port.
So, if a user was performing a telnet session, and STP was being reecalculated, the telent session, from user's perspective, would appear stalled or the connection would appear lost.

#### PortFast Overview

The faster that convergence takes place, the less disruption it will cause for your users.
You can reduce the two timers to speed up your convergence time, but this can create more problem if you aren't aware of what you are doing when you change them.

For user ports, you can use the *PortFast* feature to speed up convergence.
PortFast should be used only on ports that will not create layer 2 loops, such as ports connected to PCs, servers, and routers (sometimes referred to as user, or edge, ports).

A port with PortFast enabled is always placed in a forwarding state, this is true even when STP is running and the root and designated ports are going through their different states.
So when STP is running, PortFast ports on the same switch can still forward traffic among themselves, limiting your STP disruption somewhat.

However, if these devices wanted to talk to devices connected to other switches, they would have to wait until STP completed and the root designated ports had moved into a forwarding state.

PortFast is a great option to configure when you want to use Preboot Execution Environment (PXE) boot with your workstations, where the device booting is trying to contact a DHCP server right away at bootup.
If you are not using PortFast in this scenario, the workstation will not be able to contact the DHCP server before the 50-second timers of STP have expired.

> Ports connected to non-switch devices should be configured with PortFast, such as PCs, servers, and routers.
> However, make sure that you don't enable PortFast on a port connected to another layer 2 switch, because you may inadvertently be creating a layer 2 loop, which can bring down the network.

#### PortFast Configuration

PortFast works with all version of STP supported by Cisco switches.

Configuring the PortFast feature is simple, and you can enable it globally or on an interface-by-interface basis.

To enable globally:
```
Switch(config)# spanning-tree portfast default
```

To enable PortFast on an interface:
```
Switch(config-if)# spanning-tree portfsat [trunk]
```

The optional `trunk` parameter enables PortFast on trunk connections to non-switch devcices, such as a router or server with a trunk card.

#### BPDU Guard Feature

BPDU Guard is used on ports confiugred with the PortFast feature.
In this instance, if a PortFast port receives a BPDU, the switch immediately disalbes the port.

PortFast is used on non-switch ports to keep them in a forwarding state; the assumptioin is that a PortFast port is not connected to a switch and therefore shouldn't be receiving BPDUs.

To enable BPDU Guard:
```
Switch(config)#spanning-tree portfast bpduguard
```

Use the `show spanning-tree summary totals` command to verify your configuration:
```
VAN-SW1(config)#do show spanning-tree summary totals
Switch is in pvst mode
Root bridge for: VLAN0001-VLAN0003
Extended system ID           is enabled
Portfast Default             is disabled
PortFast BPDU Guard Default  is enabled
Portfast BPDU Filter Default is disabled
Loopguard Default            is disabled
EtherChannel misconfig guard is enabled
Configured Pathcost method used is short
UplinkFast                   is disabled
BackboneFast                 is disabled

Name                   Blocking Listening Learning Forwarding STP Active
---------------------- -------- --------- -------- ---------- ----------
3 vlans                      0         0        0         18         18
VAN-SW1(config)#
```

At the reception of BPDUs, the BPDU Guard operation disables the port that has PortFast configured.
The BPDU Guard transitions the port into an errdisable (error disabled) state, and a message appears on the console

When a port has been placed in an error disabled state, use the `errdisable recovery cause bpduguard` command to remove the error disabled state:

```
Switch(config)# errdisable recovery cause bpduguard
```

Optionally, you can hvae the switch periodically do this by configuring the command with an interval, specified in seconds:

```
Switch(config)# errdisable recovery interval SECONDS
```

This automatically clears all errdisable states, including BPDU violations, on all ports every x seconds.
However, if a BPDU violation occurs again, the port is back into an errdisable state.

### Per-VLAN Spanning Tree+ (PVST+)

STP doesn't guarantee an optimized, loop-free network.

![[Pasted image 20251016053008.png]]

In this example, the network has two VLANs, and the root switch is Switch-8.
The Xs are ports placed in a blocked state to remove any loops.

If you look at this configuraiton for VLAN 2, it definietly isn't optimized.
For instance, VLAN 2 devices on Switch-1, if they want to access VLAN 2 devices on Switch-4, have to go to switches-2, 3, 6, 9, 8 and then 4.
Likewise, VLAN 1 device on either Switch-5 or Switch-7 that want to access VLAN 1 devices on Switch-4 must forward their traffic first to Switch-8 and then to Switch-4.

When one instance of STP is running, this is referred to as a *Common Spanning Tree (CST)*.
Cisco also supports a process called *per-VLAN Spanning Tree Plus (PVST +)*.
With PVST+, *each* VLAN has its own instnace of STP, which ist own root switch, its  own set of priorities, and its own set of BPDUs.
In this scenario, the BPDUs have an additional field that is a component of the switch or bridge ID with three subfields: switch priority, extended system ID, and the switch's MAC address.
The extended system ID is a new field and carries the VLAN ID (VID) for the instance of STP.

With an addition of this field, it is possible to have different priorities on switches in different VLANs; thus you have the capability of having multiple foor switches (one per VLAN).

Each VLAN in PVST+, by default, will develop its own loop-free network; however, you can make STP changes in *each* VLAN to optimize traffic patterns for each VLAN to optimize it.

Another advantage that PVST+ has it that if STP changes are occuring in one VLAN, they do not affect other instances of STP for other VLANs, making for a more stable topology.

Given this, it is highly recommended that you implement VTP pruning to prune off VLANs from trunks of switches that are not using those VLANs.

The downside of PVST+ is that because each VLAN has its own instance of STP, more overhead is involved: more BPDUs and STP tables are required on each switch.
Plus, it makes no sense to use PVST+ unless you tune it for your network, which means more work and monitoring on your part.

### Simple STP Example

![[Pasted image 20251016055006.png]]

Assume that these switches do not support Rapid STP (RSPT), but only 802.1d STP.
And assume that there is only one VLAN.

The ports on each switch are labeled with a letter and a number.
The letter is the port designator, and the number is the cost of the port as a BPDU enters the port.

#### Electing the Root Switch

The first thing that occurs once all these switches are booted up is the election of the root switch.

The switches share BPDUs with one another to elect the root. In this example, all of the switches are using the default priority (32,768).
Since all of the switches have the same priority, the switch with the lowest MAC address, which is Switch-1, is chosen as the root switch.

![[Pasted image 20251016055452.png]]

#### Choosing Root Ports for Each Switch

After the root switch is elected, each non-root switch must choose a root port that it will use to reach the root.

With Switch-1, which is the root switch, there are no root ports.

Switch-2 has two ports to use to reach the root: E and F.
When Switch-1 generates its BPDUs on ports I and J, the original path cost is set to 0.
As these BPDUs are received by other switches, the receiving switch increments the path cost by the cost of the port on which the BPDU was received.
As the BPDU comes into port E, Switch-2 increments the path cost to 20, and for port F, a cost of 10.
The first check that Switch-2 makes is to compare the path costs. Port F has the best path cost and therefore is chosen as the root port, which is shown as RP.

Switch-3 also has two paths to reach the root: Via ports C and D.
Port C's acuumulated path cost is 10, while D's cost is 70. Therfore, port C is chosen as the root port.

Switch-4 to choose port H as the root port. Switch-5's two ports, A and B, have accumulated path cost of 30, while G has a cost of 50, causing Switch-4 to choose port H as the root port.

Switch-5's two ports, A and B, have accumulated path costs of 10 and 40, respectivley, causing Switch-5 to choose port A as the root port.

Note that all the switches in the network are simultaneously running STP and figuring out for themselves where the root switch is and which of their own ports should be the root port.
This is also true for choosing a designated port on a segment.

![[Pasted image 20251016060210.png]]

#### Choosing Designated Ports for Each Segment

After the root ports are chosen, each switch will figure out, on a segment-by-segment basis, whether its connected port to the segment should be a designated port or not.

Designated port on a segment is responsible for moving traffic back and forth between the segment and the rest of the layer 2 network.
The segment themselves, are completely unaware of this process of choosing a designated port, the switches are figuring this out.

When choosing a designated port, the first thing that is examined is the accumulated path cost for the switch (connected to the segment) to reach the root.
For two switches connected to the designated switch for that segment, and its port connected to that segment becomes a desginated port.

For Switch-1, the accumlated path cost for LAN Segment-B is 0, Switch-2 is 20, and Switch-5 is 10.
Since the root switch (Switch-1) has the lowest accumulated path cost, its local port (J) becomes the designated port for LAN Segment-B.

The root switch has the lowset accumulated path cost (0) in LAN Segment-C, making port I on Switch-1 the designated port for LAN Segment-C.

LAN Segment-A has two choices: Switch-3's port D and Switch-4's port H.
Switch-3 has the lower accumulated path cost: 10 versus Switch-4's 50.
Therefore, Switch-3's port D becomes the designated port for LAN Segment-A

LAN Segment-D also has two choices for a designated port: Switch-5's port B and Switch-4's port G.
Switch-5 has an accumulated path cost of 10, and Switch-4 has a cost of 30.
Therefore Switch-5's port B becomes the designated port for LAN Segment-D.

![[Pasted image 20251016061048.png]]

#### Changing Port States

After the designated ports are chosen, the switches will move their root and designated ports through the various state (blocking, listening, learning, and forwarding) whereas any other ports will remain in a blocking state.

![[Pasted image 20251016061154.png]]

On Switch-2, only port F (the root port) is in a forwarding state: port E will remain in a blocking state.
In this example, two ports are left blocking state.

> STP guarntees only a layer 2 loop-free topology, it does not guarantee an optimal topology

---

## Rapid Spanning Tree Protocol

The 802.1d standard was designed back when waiting for 30 to 50 seconds for layer 2 convergence wasn't a problem. However, in today's networks, this can cause serious performance problems for networks that use real-time applications.

To overcome this issues, Cisco developed proprietary bridging features called PortFast, UplinkFast, and BackboneFast.
The problem with these features, however, is that they are proprietary to Cisco.

RSTP is an IEEE standard, defined in 802.1w, which is interoperable with 802.1d and an extension to it.
With RSTP, there are only three port states:

* Discarding
* Learing
* Forwarding

A port in a discarding state is basically the grouping of 802.1d's blocking, listening, and disabled states.

> RSTP is backward compatible with 802.1d

### Addtional Port Roles

With RSTP, there is still a root switch and there are still root and designated ports, performing the same roles as those in 802.1d. However, RSTP addss two additional port types: *alternative* ports and *backup* ports.
These two ports are similar to the ports in a blocking state in 802.1d.

An alternative port has an alternative path or paths to the root but is currenlty in a discarding state.

A backup port is on a segment that could be used to reach the root switch, but an active port is already designated for the segment.

An alternative port is a secondary, unused root port, and a backup port is a secondary, unused designated port.

The third port role change in RSTP is that there is no longer a blocking state; this has been replaced by a *discarding* state.
All ports are either in a forwarding or a discarding state: the root ports and designated ports are in a forwarding state, all other ports are in a discarding state.

Given these new port roles, RSTP calculates the final spanning tree topology the same way as 802.1d.
Some of the nomenclature was changed and extended, and this is used to enhance convergence times.

### RSTP BPDUs

The 802.1w standard introduced a change with BPDUs. Some additional flags were added to the BPDUs, so that switches could share information about the role of the port the BPDU is exiting or leaving.
This can help a neighboring switch converge faster when changes occur in the network.

In 802.1d, if a switch didn't see a root BPDU within the maximum age time (20 seconds), STP would run, a new root  switch would be elected, and a new loop-free topology would be created.
With 802.1w, if BPDU is not received in three expected hello periods (6 seconds), STP information can be aged out instantly and the switch considers that its neighbor is lost and actions should be taken.
This is different from 802.1d, where the switch had to miss the BPDUs from the root.
In 802.1w, if the switch misses three consecutive hellos from a neighbor, actions are immediately taken.

### RSTP Convergence Features

The 802.1w standard includes new convergence features that are very similar to Cisco's proprietary UplinkFast and BackboneFast features.

The first feature, allows a switch to accept *inferior* BPDUs.

![[Pasted image 20251016081519.png]]

In this example, the root bridge is Switch-A. Both of the ports on Switch-B and Switch-C directly connected to the root are root ports.
For the segment between Switch-B and Switch-C, Switch-B provides designated port and Switch-C provides a backup port (a secondary way of reaching the root for the segment).
Switch-B also knows that its designated port is an alternative port (a secondary way for the switch to reach the root), via Switch-C from Switch-C's BPDUs.

The link between the root and Switch-B fails.

Switch-B can detect this by either missing three hellos from the root port or detecting a physical layer failure

If you were running 802.1d, Switch-B would see an inferior root BPDU (worst cost value) comming via Switch-C, and therefore all ports would have go through blocking, listeniing, and learning states, which would take 50 seconds, by default, to converge.
 
With the inferior BPDU feature, assuming that Switch-B knows that Switch-C has an alternative port for their directlry connected segement, Switch-B can notify Switch-C to take its alternative port and change it to a designated port, and Switch-B will change its designated port to a root port.

The second convergence feature introduces in 802.1w is *rapid transition*.

Rapid transition includes two new components: edge ports and link types.

An edge port is a port connected to a non-layer 2 device, such as a PC, server, or router.
RSTP with rapid transition of edge ports to a forwarding state is the same as PortFast.
Changes in the state of these ports do not affect RSTP to cause a recalculation, and changes in other port types will keep these ports in a forwarding state.

Rapid transition can take place in RSTP only for edge ports and links that are point-to-point (P2P).
The link type is automatically determined in terms of the duplexing of the connection.
Switches make the assumption that if the port is configured for full duplex between the two switches, the port can rapidly transition to a different state without having to wait for any timers to expire.
If they are half duplex, this feature won't work by default, but you can manually enable it for P2P half-duplex switch links.

**Rapid transition example**
![[Pasted image 20251016082614.png]]

The link between Switch-A (the root) and Switch-C fails. When this happens, Switch-C can no longer reach Switch-A on its root port.

However, looking at the BPDUs it has been receiving from Switch-A and Switch-B, Switch-C knows that the root is reachable via Switch-B and that Switch-B provides the designated port (which is in a forwarding state) for the segment between Switch-B and Switch-C.
Switch-C, knowing this, changes the state of the backup port to a root port and places it immediately into a forwarding state, notifying Switch-B of the change.

This update typically takes less than a second, assuming that the failure of the segment between the root and Switch-C is a physical link failure, instead of three missed consecutive hello BPDUs.

### RSTP Configuration

Cisco switches support three types of STP, The default configuraiton on Cisco switches is a separate instance of STP per VLAN, one root switch for all the VLANs, and no load sharing.

| STP                                   | DESC                                                                                   |
| ------------------------------------- | -------------------------------------------------------------------------------------- |
| PVST+                                 | 802.1d per VLAN with Cisco-proprietary extensions (PortFast, UplinkFast, BackboneFast) |
| PVRST+                                | 802.1w (RSTP) per VLAN                                                                 |
| Multiservice Transport Platform(MSTP) | 802.1s, referred to as multiple STP, combines Cisco's PVST+ with IEEE standards        |

To enable PVRST+:
```
Switch(config)#spanning-tree mode rapid-pvst
```

Once enabled, you can view the STP on a per-VLAN basis with:

```
Switch# show spanning-tree vlan VLAN_# [detail]

VAN-SW1#show spanning-tree vlan 1

VLAN0001
  Spanning tree enabled protocol rstp
  Root ID    Priority    32769
             Address     aabb.cc00.0300
             This bridge is the root
             Hello Time   2 sec  Max Age 20 sec  Forward Delay 15 sec

  Bridge ID  Priority    32769  (priority 32768 sys-id-ext 1)
             Address     aabb.cc00.0300
             Hello Time   2 sec  Max Age 20 sec  Forward Delay 15 sec
             Aging Time  300 sec

Interface           Role Sts Cost      Prio.Nbr Type
------------------- ---- --- --------- -------- --------------------------------
Et0/0               Desg FWD 100       128.1    Shr
Et0/1               Desg FWD 100       128.2    Shr Edge
Et0/2               Desg FWD 100       128.3    Shr Edge
Et0/3               Desg FWD 100       128.4    Shr
Et1/0               Desg FWD 100       128.5    Shr
Et1/1               Desg FWD 100       128.6    Shr
Et1/2               Desg FWD 100       128.7    Shr
Et1/3               Desg FWD 100       128.8    Shr
Et2/0               Desg FWD 100       128.9    Shr
Et2/1               Desg FWD 100       128.10   Shr
Et2/2               Desg FWD 100       128.11   Shr
Et2/3               Desg FWD 100       128.12   Shr
Et3/0               Desg FWD 100       128.13   Shr
Et3/1               Desg FWD 100       128.14   Shr
Et3/2               Desg FWD 100       128.15   Shr
Et3/3               Desg FWD 100       128.16   Shr
```

In this example, the switch is the root for VLAN 1 and RSTP is being used.
Notice that all of its ports are designated ports (Desg) and are in a forwarding state (FWD)

You can also verify STP on a per-port basis with the `show spanning-tree interface` command.

```
VAN-SW1#show spanning-tree interface E0/0

Vlan                Role Sts Cost      Prio.Nbr Type
------------------- ---- --- --------- -------- --------------------------------
VLAN0001            Desg FWD 100       128.1    Shr
VLAN0002            Desg FWD 100       128.1    Shr
VLAN0003            Desg FWD 100       128.1    Shr

VAN-SW2(config)#do show spanning-tree interface E0/0

Vlan                Role Sts Cost      Prio.Nbr Type
------------------- ---- --- --------- -------- --------------------------------
VLAN0001            Root FWD 100       128.1    Shr
VLAN0002            Root FWD 100       128.1    Shr
VLAN0003            Root FWD 100       128.1    Shr
```

> to troubleshoot problems with PVRST+, use the `debug spanning-tree pvst+` command; to troubleshoot problems with ports changing state within STP, use `debug spanning-tree switch state`.

### PVST+ and RSTP Optimization

![[Pasted image 20251016143533.png]]

This example shows two VLANs, numbered 1 and 2. The default behavior with Cisco's switches is that a single root switch is used for all VLANs, based on the switch with the lowest switch ID.
In this instance, this is Switch-A.

Notice that based on RSTP's calculation, Switch-C disabled its port to Switch-B for both its VLANs.
The downside of this design is that of the two connections to the distribution layer, only one is being utilized on the access switch.

![[Pasted image 20251016145350.png]]

To obtain this kind of topology, however, you must tune your network, making sure that Switch-A is the root for VLAN 1 and Switch-B is the root for VLAN 2.
With this kind of design, you can actually utilize both of your uplink connections on your access layer switch up to the distribution layer switches.
VLAN 1 will use the left-hand uplink connection and VLAN 2 the right-hand uplink connection.

You must manually change each switch's priority to create the desired topolgy.

```
Switch(config)# spanning tree vlan VLAN_# root primary
Switch(config)# spanning tree vlan VLAN_# root secondary
Switch(config)# spanning tree vlan VLAN_# root PRIORITY_#
```

Remeber that the default priority for a switch is 32,768. The first command changes the switch's priority to 4096 for the specified VLAN.
The second command changes the switch's priority to 8192 for the specified VLAN.
The third enables you to customize the priority for the specified VLAN.

**Switch-A's configuration**
```
Switch-A(config)#spanning-tree mode rapid-pvst
Switch-A(config)#spanning-tree vlan 1 root primary
Switch-A(config)#spanning-tree vlan 2 root secondary
```

**Switch-B's configuration**
```
Switch-B(config)#spanning-tree mode rapid-pvst
Switch-B(config)#spanning-tree vlan 2 root primary
Switch-B(config)#spanning-tree vlan 1 root secondary
```

The only difference between these two configuration is that the priorities for the primary and secondary are switched on the two VLANs to allow for the use of both uplinks from Switch-C, the access layer switch.

> Any STP configuration changes you make on your switches are affected immediately, which means that layer 2 will have to reconverge, causing a brief disruption in your layer 2 network.

### STP Troubleshooting

Before look at the different layer 2 loop problems, define a *broadcast storm*.
Switches send broadcast messages to all ports on the switch (except the port it was received on).
If you have a layer 2 loop, that means there are multiple pathways between the switches, and the broadcast message would be rebroadcasted from one switch to another, using up bandwidth and processing power on the switches, this is broadcast storm.

Broadcast storm is bad, because they will eventually bring the network down.

#### Loop Identification

One indication of a broadcast storm is very high CPU and port utilization on your switches.

You can examine a switch's or several switches' CPU utilization with the `show processes` and `show process cpu` commands.
A constantly high CPU utilization could indicate a loop. To verify that a layer 2 loop is causing the problem, capture and analyze traffic with a protocol analyzer to determine whether the same packet appears multiple times.
This is typically done by connecting your protocol analyzer to a switch and using the Switch Port Analyzer (SPAN) feature on your switch, which copies frames from an interface or VLAN to the SPAN port.
A goot protocol analyzer should be able to see that a loop exists and notify you of this problem.

Once a loop is identified, to restore connectivity quickly, you should start disabling ports that are part of the loop; then diagnose the problem to determine whether a configuration issue on your part or the addition of a new layer 2 device is causing the problem.
If you are having problems identifying what is causing the loop, turn on debug for STP (`debug spanning-tree events`).

#### Configuration Remedies

To simplify your troubleshooting process, disable as many features as necessary. For example, if you have EtherChannels enabled, disableing the channel will help determine whether the channel itself is not funcitoning correctly and possibly creating the layer 2 loop.

If you are not certain which switch is the root switch, log into the switch that logically should be the root and force it to become the root by changing its priority to 1 with the `spanning-tree vlan VLAN_# priority 1` command.

> A good step on your part should be to include the MAC addresses of each switch in your network topology diagram.
> Then, when troubleshooting loop problems, you'll find it much easier to determine whether a rogue switch was introduced into the topology that may be creating the loop.

Make sure that all your switches are running either 802.1d or 802.1w (RSTP), Use the `show spanning-tree` command to verify this as well as whether or not the switch is playing the role of root for a VLAN.

### Exercise 10-2: Monitoring STP

---

## EtherChannels

it is common to need higher bandwidth speeds for certain kinds of connections in your network, such as connections from the access layer to the distribution layer, between distribution layer switchs, and between certain servers or routers and their connected swithces.

![[Pasted image 20251016145350.png]]
You can see dual layer 2 connections between the two distribution layer switches as well as between the distribution and core layer switches.
The problem with this type of design, however, is that it creates layer 2 loops; and with STP running, STP will ensure that only one path  is active between two devices, limiting you to the bandwidth of one of possibly multiple connections.

### EtherChannel Overview

An EtherChannel is layer 2 solution that enables you to aggreate multiple layer 2 Ethernet-based connections between directly connected devices.
Basically, an EhterChannel bundles together multiple Ethernet ports between devices, providing what appears to be a single logical interface.
From STP's perspective, it sees the Etherchannel as a single logical connection between the connected devices, which means that you can actually use all of the individual connections, simultaneously, in the channel you've created.

EtherChannels provide these advantages:

* **Redundancy**
	* If one connection in the channel fails, you can use other connections in the channel.
* **More bandwidth**
	* Each connection can be used simultaneously to send frames.
* **Simplified management**
	* Configuration is done on the logical interface, not on each individual connection in the channel.

#### EtherChannel Restrictions

Interfaces in an EtherChannel must be configured identically: speed, duplexing, and VLAN settings (in the same VLAN if they are acceess ports, or the same trunk properties) must be the same.
When setting up EtherChannels, you can use up to eight interfaces bundled together:

* Up to eight Fast Ethernet connections, providing up to 800 Mbps
* Up to eight Gigabit Ethernet connections, providing up to 8 Gbps
* Up to eight 10-Gigabit Ethernet connections, providing up to 80 Gbps

Typically you can have a total of six EtherChannels on a switch, but this is larger on the higer-end IOS switches.

#### EtherChannel Operations

Channels can be formed dynamically between devices by using one of two protocols: Port Aggregation Protocol (PAgP) or Link Aggregation Control Protocol (LACP).

| Protocols | Desc                                                                                                                                                                                   |
| --------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| PAgP      | Proprietary to Cisco. It enables connected devices to group similary configured ports dynamically into a single channel                                                                |
| LACP      | Defined in the IEEE 802.1ad standard. Like PAgP, it learns from a connected device which ports between the two are identically configured and dynamically forms a channel between them |

Once a channel is formed, load balancing can be used by the connected devices to utilize all the ports in the channel.
Load balancing is performed by reducing part of the binary addressing in the frame or packet to a numeric value and then associating the numeric value to one of the ports in the channel.

Load balancing can use MAC or IP addresses, source or destination addresses, or both source and destination address pairs. With load balancing, you are guaranteed that all links in the channel will be utilized; however, you are not guaranteed that all the ports will be utilized the same.

For example, if you are load balancing based on source addresses, you are guranteed that different source MAC address will use different ports in the channel.
All traffic from a single-source MAC address, however, will always use the same port in the channel.

For example, if you are load balancing based on source addresses, you are guaranteed that different source MAC addresses will use different ports in the channel.
All traffic from a single-source MAC address, however, will always use the same port in the channel. Given this situation, if one deivce is generating a lot of traffic, that link possibly be utilized more than other links in the channel.
In such situation, you may want to load balance based on the destination address or both the source and destination addresses.

### EtherChannel Configuraiton

You should make sure that all interfaces in the channel are configured identically; otherwise, a channel may not form.

```
Switch(config)# interface TYPE
Switch(config-if)# channel-group GROUP_# mode MODE
Switch(config-if)# port channel load-balance {dst-ip | dst-mac | src-dst-ip | src-dst-mac | src-ip | src-mac}
```

The *group_#* specifies the channel group to which the interface belongs, which can be from 1 to 6 (remeber that you can have up to six EtherChannels on your switch).

**EtherChannel Modes**

| Mode      | Protocol | Desc                                                                                                                                               |
| --------- | -------- | -------------------------------------------------------------------------------------------------------------------------------------------------- |
| auto      | PAgP     | Passively listens for PAgP queries from a Cisco device configured with either desirable or on. By default, the interface is not part of a channel. |
| desirable | PAgP     | Generates PAgP queries to form a channel, but by defaul is not part of a channel.                                                                  |
| on        | PAgP     | Generates PAgP queries and assuems the port is part of a channel.                                                                                  |
| active    | LACP     | Enables a channel if the other side responds to its LACP messages.                                                                                 |
| passive   | LACP     | Passively listens for LACP messages to from a channel from active port.                                                                            |

When using PAgP, one side needs to be configured as desirable and the other side as desirable or auto; or you can configure both sides to be on.
When using LACP, one side needs to be active and the other side can be active or passive.

Use the `port-channel load-balance` command to configure the type of load balancing you want to use on the channel.
If you omit this command, it defaults to load balancing based on source MAC address (src-mac)

Configuration of SwitchA forming an EtherChannel to SwitchB using PAgP:
```
SwitchA(config)#interface g1/0/1
SwitchA(config-if)#channel-group 1 mode auto
SwitchA(config-if)#exit
SwitchA(config)#interface g1/0/2
SwitchA(config-if)#channel-group 1 mode auto
SwitchA(config-if)#exit
```

Because the auto mode is used on SwitchA for PAgP, SwitchB must use either a mode of on or desirable
```
SwitchB(config)#interface g1/0/4
SwitchB(config-if)#channel-group 1 mode on
SwitchB(config-if)#exit
SwitchB(config)#interface g1/0/5
SwitchB(config-if)#channel-group 1 mode on
SwitchB(config-if)#exit
```

### Exercise 10-3: Working with EtherChannel

```
### configure EtherChannel

VAN-SW1#config t
Enter configuration commands, one per line.  End with CNTL/Z.
VAN-SW1(config)#interface E1/0
VAN-SW1(config-if)#channel-group 1 mode auto

VAN-SW1(config-if)#interface E1/1
VAN-SW1(config-if)#channel-group 1 mode auto

### EtherChannel summary
VAN-SW1(config)#do show etherchannel summary
Flags:  D - down        P - bundled in port-channel
        I - stand-alone s - suspended
        H - Hot-standby (LACP only)
        R - Layer3      S - Layer2
        U - in use      f - failed to allocate aggregator

        M - not in use, minimum links not met
        u - unsuitable for bundling
        w - waiting to be aggregated
        d - default port


Number of channel-groups in use: 1
Number of aggregators:           1

Group  Port-channel  Protocol    Ports
------+-------------+-----------+-----------------------------------------------
1      Po1(SD)         PAgP      Et1/0(I)    Et1/1(I)
```

Group: 1
Protocol: PAgP
Ports: Et1/0, Et1/1

```
### show interfaces port-channel 1
VAN-SW1(config)#do show interfaces port-channel 1
Port-channel1 is up, line protocol is up (connected)
  Hardware is Ethernet, address is 0000.0000.0000 (bia 0000.0000.0000)
  MTU 1500 bytes, BW 10000 Kbit/sec, DLY 1000 usec,
     reliability 255/255, txload 1/255, rxload 1/255
  Encapsulation ARPA, loopback not set
  Keepalive set (10 sec)
  Auto-duplex, Auto-speed, media type is unknown
  input flow-control is off, output flow-control is unsupported
  ARP type: ARPA, ARP Timeout 04:00:00
  Last input never, output never, output hang never
  Last clearing of "show interface" counters never
  Input queue: 0/2000/0/0 (size/max/drops/flushes); Total output drops: 0
  Queueing strategy: fifo
  Output queue: 0/40 (size/max)
  5 minute input rate 0 bits/sec, 0 packets/sec
  5 minute output rate 0 bits/sec, 0 packets/sec
     0 packets input, 0 bytes, 0 no buffer
     Received 0 broadcasts (0 multicasts)
     0 runts, 0 giants, 0 throttles
     0 input errors, 0 CRC, 0 frame, 0 overrun, 0 ignored
     0 input packets with dribble condition detected
     0 packets output, 0 bytes, 0 underruns
     0 output errors, 0 collisions, 0 interface resets
     0 unknown protocol drops
     0 babbles, 0 late collision, 0 deferred
     0 lost carrier, 0 no carrier
     0 output buffer failures, 0 output buffers swapped out
```

**VAN-SW2**
```
### EtherChannel configuration on E1/0 and E1/1
VAN-SW2#config t
VAN-SW2(config)#interface E1/0
VAN-SW2(config-if)#channel-group 1 mode on

VAN-SW2(config-if)#interface E1/1
VAN-SW2(config-if)#channel-group 1 mode on

### verify
VAN-SW2(config)#do show etherchannel summary
Flags:  D - down        P - bundled in port-channel
        I - stand-alone s - suspended
        H - Hot-standby (LACP only)
        R - Layer3      S - Layer2
        U - in use      f - failed to allocate aggregator

        M - not in use, minimum links not met
        u - unsuitable for bundling
        w - waiting to be aggregated
        d - default port


Number of channel-groups in use: 1
Number of aggregators:           1

Group  Port-channel  Protocol    Ports
------+-------------+-----------+-----------------------------------------------
1      Po1(SU)          -        Et1/0(P)    Et1/1(P)
```

Group: 1
Protocol: -
Ports: Et1/0, Et1/1

---

## Chapter Review

VTP is a Cisco-proprietary protocol that transmits VLAN informations across trunk port.
Swtiches must be in the same domain to share messages.
There are three modes for VTP: client, server, and transparent.

Server and transparent switches can add, change, and delete VLANs, but server switches advertise these changes.
Clients can accept updates only from server switches.

There are three VTP messages: advertisement request, subset advertisement, and summary advertisement.
Servers generate summary advertisements every five minutes on trunk connections.
The configuration revision number is used to determine which server switch has the most current VLAN information.

VTP pruning is used to prune off VLANs that are not active between two switches, but it requires switches to be in server and/or client mode.

On the Cisco switche, use the `vtp domain` command and `vtp server|client|transparent` commands to configure VTP. The default mode is server.
To configure VTP password, use the `vtp password` command.

BPDUs are used by STP to learn about other neighboring switches.
These are generated every two seconds as multicasts.
When running STP, a roor switch is elected. The switch ID is composed of a priority and the switch's MAC address.
Each switch chooses a root port to reach the root switch.
Each segment has one port on one switch that becomes a designated port, which is used to forward traffic to and from the segment.
This is typically the port on the switch with the lowest accumulated path cost.

There are five port states: blocking (20 sec), listening (15 sec), learning (15 sec), forwarding, disabled.
PortFast puts a port immediately into forwarding mode and should be used only on non-switch ports.

PVST+ has an instance of STP running per VLAN, this is proprietary to Cisco but standarized by IEEE with MSTP.

RSTP reduces convergence to a few seconds by having switches determine valid alternate root ports and backup designated ports that they can use when topology changes takes place.
PVST+ with RSTP is enabled with the `spanning-tree mode rapid-pvst` command.

EtherChannels bundle layer 2 connections between devices, creating a single logical port from STP's perspective.
Load balancing can then be performed on the ports in the channel.
PAgP or LACP is used to form the channel. No more than eight interfaces can be part of the channel.

If your CPU and/or port utilization is high, you may have a layer 2 loop.
Typically you should use a protocol analyzer and look for multiple copies of the same frame in your frame captures.

---

## Quick Review

### VLAN Trunking Protocol

VTP is used to share VLAN information to ensure that switches have a consistent VLAN configuraiton.

VTP has three modes: server (can make and accept changes and propagates changes), transparent (can make changes, ignores VTP messages), and client (accept changes from server and doesn't store them in NVRAM).
The default mode is server.

VTP messages are propagated only across trunks. For a switch to accept a VTP message, the doamin name and optional password must match.
There are three VTP messages: advertisement request (client or server request), subset advertisement (server response to an advertisement), and summary advertisement (server sends out every five minutes).
The configuration revision number is used in the VTP message to determine whether it should be processed or not.

VTP pruning allows for the dynamic addition and removal of VLANs on a trunk based on whether or not there are any active VLANs on a switch.
Requires switches to be in server and/or client mode.

### Spanning Tree Protocols

STP is defined in 802.1d. It removes loops from your network.
The switch with the loweset switch ID (priority + MAC address) is elected as the root.

Each switch chooses the best path to the root, and this port is called a root port.
Each segment needs a switch port to access the rest of the network, this port is called a designated port.

BPDUs are used to elect root switches and to share topology information.
BPDUs are multicasts that are advertised every two seconds.

There are five STP port states: blocking (only processing BPDUs, 20 sec), listening (only processing BPDUs, 15sec), learning (processing BPDUs and building the CAM table, 15 sec), forwarding (processing BPDUs, building CAM table, and forwarding user traffic), and disabled (the port is not enabled).

Root and designated ports will eventually move into a forwarding state, which can take between 30 and 50 seconds.

PortFast keeps a port in a forwarding state when STP is recalculating: it should *not* be used on switch-to-switch connections because it could lead to inadvertent loops.

PVST+ is proprietary to Cisco and allows for a separate STP instance per VLAN.

### Rapid Spanning Tree Protocol

RSTP has three port states: discarding, learing, and forwarding.
RSTP supports two additional port types: alternative (secondary to a root port), and backup (secondary to a designated port).

### EtherChannels

From STP's perspective, and EtherChannel, which is a grouping of layer 2 physical connections between devices, is seen as a single logical connection.

Ports must be configured identically in an EtherChannel. PAgP or LACP can be used to form a channel

---

### Questions

1.  Which VTP mode(s) can create and delete VLANs?

A. Client and server
B. Server
C. Client and transparent
D. Transparent
**E. Server and transparent**

2.  The root switch is the one elected with the `__________`.

A. lowest MAC address
B. highest MAC address
**C. lowest switch ID**
D. highest switch ID

3.  The switch port that is chosen to forward traffic for a segment is called a(n) `__________`.

A. root port
B. alternate port
C. backup port
**D. designated port**

4.  With STP, which of the following is true concerning a port that is in a listening state? (Choose two.)

**A. It remains there for 15 seconds.**
B. It forwards BPDUs and builds the CAM table. = learning
C. It remains there for 20 seconds. = blocking
**D. It forwards BPDUs.**

5.  How many port states are there in RSTP?

**A. 3**
B. 4
C. 5
D. 6

discarding, learning, and forwarding

6.  What port role will be assigned to a port that has the second-best path to the root switch?

A. Root
B. Designated
**C. Alternate**
D. Backup = secondary for designated port

7.  Which command enables RSTP with PVRST+ on a Cisco switch?

**A. spanning-tree mode rapid-pvst**
B. spanning-tree state rapid-pvst
C. stp state rapid-pvst
D. spanning-tree mode rstp

8.  Which of the following is/are true concerning EtherChannels?

A. You can have up to six ports in a channel. = 8 ports
B. You can have up to eight channels on a switch. = 6 channels
**C. Ports must be configured identically to form a channel.**
D. RSTP dynamically groups ports into a channel. = PAgP, LACP

9.  What symptom should you look for to determine whether you have a layer 2 loop?

A. High number of broadcast and/or multicast frames
**B. High port utilization**
C. User switch interfaces dropping and reconnecting
D. Port address tables not being updated

10.  What tool would you use to determine whether you had a broadcast storm caused by a layer 2 loop?

A. show interface command
**B. Protocol analyzer**
C. debug broadcast command
D. traceroute command

11.  You have two switches with VTP configured that are not connected together. The first switch is running in server mode with VLANs Accounting, HR, and Executives and a configuration revision value of 55 The second switch is also running in server mode with VLANs Engineering, Sales, and Marketing and a configuration revision value of 57. You connect the two switches together with a crossover cable. What will happen? (Choose two.)

**A. If the domain names don’t match, nothing occurs.**
B. If the domain names don’t match, the VLANs on the higher
revision switch are used and the other ones are deleted.
C. If the domain names match, the Engineering, Sales, and Marketing VLANs are deleted.
**D. If the domain names match, the Accounting, HR, and Executives
VLANs are deleted.** (higher revision value is used)

### Performance-based Questions

1.  Using the following exhibit, identify characteristics of STP and EtherChannel by placing the description on the left side of the diagram into the appropriate category on the right side of the diagram. Not all descriptions found on the left will necessarily be used.

![[Pasted image 20251017042532.png]]

* **EtherChannel**
	* Combines bandwidth of multiple Fast Ethernet of Gigabit Ethernet Ports
	* Allows redundancy on the links
* **STP**
	* Designed to prevent layer 2 loops
	* Places redundant links in a blocking state
