## Configuring Device Passwords

Securing your Cisco device starts with configuring the different passwords that may exist on the device.

### Enable Password and Secret

The first password to discuss is the password that an administrator will need to enter when navigating from user EXEC mode to privileged EXEC mode using the `enable` command.

Two types of enable passwords can be configured: the `enable password`, which is not encrypted in the configuration file, and the `enable secret`, which is encrypted in the configuration file.

If bot the enable password and the enable secret are set, you will need to use the secret to access privileged EXEC mode.

You can configure the enable password with the `enable password` command and the enable secret with the `enable secret` command:
```
VAN-R1>enable
VAN-R1#config term
VAN-R1(config)#enable password ciscopass
VAN-R1(config)#enable secret ciscosecret

### configuration check
VAN-R1(config)#do show running-config
enable secret ~~~~~
enable password ciscopass
```

> you can remove a feature by adding a **no** at the beginning of a command.
> if you want to remove the enable secret, you can use the `no enable secret` command, and if you want to remove the enable password, you can use the `no enable password` command

### Securing the Console and Auxiliary Port

The next password to configure on your device is the console password, which is an additional password required when someone connects to the console port of the device.

Kepp in mind that an administrator would need to supply the conole port password before even entering privileged EXEC mode and would need to supply the enable password or enable secret as well.

To configure a console password, navigate to the line con 0 port from global configuration mode and then set the password

```
Router>enable
Router#config term
Router(config)# line con 0
Router(config-line)# password conpass
```

With the preceding commands configured, if you connect to the console port on your device, you will notice that you are not prompted for a password.
This is because after setting the password, you must use the `login` command to indicate to the Cisco device that authentication is required on the port and to prompt for the password

```
Router(config-line)# login
```

Your Cisco router may have an auxiliary (AUX) port next to the console port. The auxiliary port is used as a backup line, where a modem can be connected to enable you to access your router remotely and perform administration changes.

Typically, you would remotely access the router with SSH using the IP address of the router, but if something went wrong with the interface and you could not connect from across the network, you could connect a modem to the router's auxiliary port and then dial into the router.

Note that if ou do not connect a modem t the auxiliary port, it acts like another console port, and you can connect to it locally to administer the device.

> No matter whether you do or don't connect a modem to they auxiliary port, you need to confgiure a password on the port.

To configure a password on the auxiliary port, navigate to the AUX line from global configuration mode and then set the password with the commands.

```
Router> enable
Router# config term
Router(config)# line aux 0
Router(config-line)# password auxpass
Router(config-line)# login
```

### Securing VTY Ports

If you want to administer the device remotely with telnet or SSH, you will need to configure a password on the virtual type terminal (VTY) ports.
To configure a password on the VTY ports, navigate to the VTY lines and then use the `password` command.

```
Rotuer> enable
Router# config term
Rotuer(config)# line vty 0 15
Router(config-line)# password telnetpass
Router(config-line)# login
```

> You should use SSH instead of telent, because telent sends all communication in clear text from the administrator's machine to the device.
> So someone who can tap into that communication can grab your username and password for the device.
> SSH encrypts all communication from the administrator's machine to the device, including the authentication traffic.

### Exercise 17-1: Configuring Passwords on Cisco Routers

* Configure console, auxiliary, and VTY password for VAN-R1 and LA-R1 routers.

![[Pasted image 20250920182157.png]]

```
#### VAN-R1 ####
VAN-R1>enable
VAN-R1#config term

### VAN-R1 EXEC mode password
VAN-R1(config)#enable password ciscopass

### VAN-R1 EXEC mode password verify
VAN-R1(config)#do show running-config

### VAN-R1 console password
VAN-R1(config)#line con 0
VAN-R1(config-line)#password conpass
VAN-R1(config-line)#login
VAN-R1(config-line)#exit

### VAN-R1 auxilary password
VAN-R1(config)#line aux 0
VAN-R1(config-line)#password auxpass
VAN-R1(config-line)#login
VAN-R1(config-line)#exit

### VAN-R1 VTY password
VAN-R1(config)#line vty 0 15
VAN-R1(config-line)#password vtypass
VAN-R1(config-line)#login
VAN-R1(config-line)#exit

#### LA-R1 ####
LA-R1>enable
LA-R1#config term

### LA-R1 EXEC mode password
LA-R1(config)#enable password ciscopass

### LA-R1 EXEC mode password verify
LA-R1(config)#do show running-config

### LA-R1 console password
LA-R1(config)#line con 0
LA-R1(config-line)#password conpass
LA-R1(config-line)#login
LA-R1(config-line)#exit

### LA-R1 auxilary password
LA-R1(config)#line aux 0
LA-R1(config-line)#password auxpass
LA-R1(config-line)#login
LA-R1(config-line)#exit

### LA-R1 vty password
LA-R1(config)#line vty 0 15
LA-R1(config-line)#password vtypass
LA-R1(config-line)#login
LA-R1(config-line)#exit
```

### Configuring Users

When setting up the security for the console port, auxiliary port, or the VTY ports, you can increase secruity by requiring a username and password instead of just a password.

#### Creating User Accounts

You can create a list of user account names and passwords that are stored locally on your Cisco device.
To do this, you use the `username` command and fill in the username and password parameters.

```
Router>enable
Router#config term
Rotuer(config)#username myuser password myuserpass
Router(config)#username anotheruser password userpass02
```

Next, use the `login local` command on each of the port types that will use that list for authentication.

In the `login local` command, `login` means force authentication (just lkike with the password option in the previous discusson), but `local` means use the local database of usernames and passwords for the authentication (not just the port password).
For example, the following commands would configure the console port to require someone to log on with a username and password to get local access to the device:

```
Router(config)#line con 0
Router(config-line)#login local 
```

You would use the `login local` command on the VTY ports and the auxiliary port if you wanted to require authentication that is verified against the username and password list.

#### Privilege Levels

There are 16 privilege levels on Cisco devices, numbered 0 to 15, with 0 being the lowest amount of privilege and 15 being the highest amount of privilege.
To give you an idea of the capailities of the levels, when you are in euser EXEC mode, you have privilege level 1, which is why you cannot make changes to the device. When you move to privileged EXEC mode, your privilege level is raised to 15 (full administrative capabilities). This is why you have to move to privileged EXEC mode to make changes to the device.

The exciting part of privilege levels is that you can assign a privilege level to a user, and then associate that privilege level to a commond so that the user can execute that command.
To associate a privilege level to a user, use the `privilege` parameter with the `username` command:

```
Router(config)#username adminguy privilege 3 password somepass
```

If you want to change the privilege level of a command so the user can execute that command, you assign the command the same privilege level with the `privilege exec` command

```
### assigned the *show running-config* command to level 3
### user needs to have privilege level of at least level 3 to run that command

Router(config)#privilege exec level 3 show running-config
```

If you are unsure of your privilege leve, you can use the `show privilege` command

```
Router>show privilege
Current privilege level is 1
Router>enable
Router#show privilege
Current privilege level is 15
```

### Exercise 17-2: Creating Users on Cisco Devices

* configure few user account in the local user account database.
* modify the console port to require a username and password when logging on to the Cisco device.

```
#### VAN-R1 ####
VAN-R1>enable
VAN-R1#config term

### Add user bob and sue
VAN-R1(config)#username bob password bobpass
VAN-R1(config)#username sue password suepass

### login local
VAN-R1(config)#line con 0
VAN-R1(config-line)#login local
VAN-R1(config-line)#line aux 0
VAN-R1(config-line)#login local
VAN-R1(config-line)#line vty 0 15
VAN-R1(config-line)#login local
VAN-R1(config-line)#exit

### SAVE
VAN-R1(config)#do write

#### LA-R1 ####
LA-R1>enable
LA-R1#config term

### Add user bob and sue
LA-R1(config)#username bob password bobpass
LA-R1(config)#username sue password suepass

### login local
LA-R1(config)#line con 0
LA-R1(config-line)#login local
LA-R1(config-line)#line aux 0
LA-R1(config-line)#login local
LA-R1(config-line)#line vty 0 15
LA-R1(config-line)#login local
LA-R1(config-line)#exit

### SAVE
LA-R1(config)#do write
```

### Encrypting Passwords

```
VAN-R1#show startup-config
....
enable password ciscopass
username adminguy privilege 3 password 0 adminpass
line con 0
  password conpass
  login
....
```

When you look at the configuration file, you can see that all of the passwords, except the secret, are stored in plain text.
This means that if someone can gain physical access to your router, he or she can view the configuration file and see the passwords you are using.

You can encrypt all passwords in your Cisco configuration files with a quick, simple command, `service password-encryption`

```
Router#config term
Router(config)#service password-encryption
Router(config)#do write
```

When the command executes, it encrypts any plain-text password in the configuration file so that someone viewing the configuraiton file does not know what your passwords are.
After executing the command, you can view the configuraiton file to verify that the passwords are encrypted

```
### encryption verify
Router#show startup-config
```

### Exercise 17-3: Encrypting Passwords on Cisco Devices

* VAN-R1 password encrypt
* LA-R1 password ecrypt

```
#### VAN-R1 ####
VAN-R1>enable
VAN-R1#config term

### encrypt
VAN-R1(config)#service password-encryption

### SAVE
VAN-R1(config)#do write

#### LA-R1 ####
LA-R1>enable
LA-R1#config term

### encrypt
LA-R1(config)#service password-encryption

### SAVE
LA-R1(config)#do write
```

### Configuring SSH

Another security feature that you should configure on your devices is to configure the device to use SSH instead of telent.

Telnet uses TCP port 23 and does not encrypt the communication. SSH uses TCP port 22 and encrypts all communication including the username and password that are transmitted from the administartor's computer to the Cisco device.

Configure SSH requires a few preparation steps:

1. Configure a hostname on your router if one does not already exist.
2. Create a username and password that administrators will use to authenticate to the device when they connect using SSH.
3. Configure a domain name on the device, as this domain name is used to generate the cryptographic key used for the encryption

```
Router>3nalbe
Router#config term

### configure hostname
Router(config)#hostname VAN-R1

### create a username and password
VAN-R1(config)#username someuser password somepass

### configure domain name
VAN-R1(confi)#ip doamin-name somedomain.com
```

You will also need to verify that the Cisco device is using a crypto-supported IOS version, such as one that has K9 at the end of the IOS image filename.

After you have completed the preparation steps, you are ready to generate the encryption key with the `crypto key generate rsa` command

```
VAN-R1(config)#crypto key generate rsa
The name for the keys will be: VAN-R1.somedomain.com
Choose the size of the key modules in the range of 360 to 2048 for your General Purpose keys. Choosing a key modules grater than 512 may take a few minutes.
How many bits in the modules [512]: 512
% Generating 512 bit RSA keys, keys will be non-exportable...[OK]
```

Notice that the name for the key is based on the hostname and the domain nave that you configured. When you are asked the bit strength to use, accept the default of 512.

Now that you have the encryption key you can configure the VTY ports to only accept a connection if it is using SSH.
In the following code example, notice we are configuring authentication using the local usernames on the device. You can then use the `transport input ssh` command to specify that the only protocol to be used on these port is SSH.

```
VAN-R1(config)#line vty 0 15
VAN-R1(config-line)#login local
VAN-R1(config-line)#transport input ssh
```

At this point, the Cisco device will no longer accept telnet connections for remote administration.
You can take this one step further and use access control lists to limit which IP addresses can SSH into the device.

### Exercise 17-4: Enforcing SSH for Remote Atdministration

* Configure VAN-R1, and LA-R1 routers for remote administration using the SSH protocol only

```
#### VAN-R1 ####
VAN-R1>enable
VAN-R1#config term

### add ssh user
VAN-R1(config)#username mysshuser password mysshpass

### configure domain
VAN-R1(config)#ip domain-name exervanr1.loc

### generate SSH key
VAN-R1(config)#crypto key gereate rsa

### Configure VTY ports for authentication using a username and password
VAN-R1(config)#line vty 0 15
VAN-R1(config-line)#login local

### enforce SSH
VAN-R1(config-line)#transport input ssh

#### LA-R1 ###
LA-R1>enable
LA-R1#config term

### add ssh user
LA-R1(config)#username mysshuser password mysshpass

### configure domain
LA-R1(config)#ip domain-name exerlar1.loc

### generate SSH key
LA-R1(config)#crypto key generate rsa

### Configure VTY ports for authentication using a username and password
LA-R1(config)#line vty 0 15
LA-R1(config-line)#login local

### enforce SSH
VAN-R1(config-line)#transport input ssh
```

---

## Configure Layer 2 Security Features

### Disable Unused Ports

The first security best practice for hardening your switch is to disable any unused ports on the switch.
This will help prevent an unauthorized person from connecting to an empty port and gaining network access.

To disable the port, use the `shutdown` command on the port

```
VAN-SW1>enable
VAN-SW1#config term
VAN-SW1(config)#interface g0/10
VAN-SW1(config-if)#shutdown
```

If you wanted to shut down a number of ports on your switch at one time, you could use the `interface range` command to select the ports

```
VAN-SW1>enable
VAN-SW1#config term
VAN-SW1(config)#interface range g0/12 - 24
VAN-SW1(config-if)#shutdown
```

### Port Security

After disabling any unused ports on the switch, your next step in hardening the switch is to configure port security on the used ports.

port security is a feature that enables you to specify which MAC address are authorized to use a port. If an unauthorized device connects to the port, the port security feature can shut down the port until the administrator enables it.

To review port security, navigate to the port and place the port in access mode, which means that an endpoint device, such as workstation, is going to connect to the port to use it:

```
VAN-SW1>enable
VAN-SW1#config term
VAN-SW1(config)#interface g0/7
VAN-SW1(config-if)#switchport mode access
```

Next, you'll enable the port security feature on the port and then specify the MAC address that is authorized to use the port.
To save you having to know and type in the MAC address, you can use the *sticky* option, which means that the switch will dynamically configure port security with whatever connects to the port.

If you set the maximum number of addresses to learn to 1, then *sticky* will learn only one the address of the currently connected device and will configure port security with that MAC address

```
VAN-SW1(config-if)#switchport port-security
VAN-SW1(config-if)#switchport port-security mac-address sticky
VAN-SW1(config-if)#switchport port-security maximum 1
```

Lastly, specify what happens when an unauthorized device connects to the port on the switch will the violation mode.

disable the port by using the shutdown mode:
```
VAN-SW1(config-if)#switchport port-security violation shutdown
```

### DHCP Snooping

A common problem encountered on enterprise network today occurs when a rogue DHCP server is placed on the network and gives out bogus IP addresses to network clients.
This causes the client computers to be unable to access network resources, because the address the client is assigned is typically on a different subnet.

A rogue DHCP server presents great security rist to the organization, as a hacker could have placed the rogue DHCP server on the network to give out her own IP address range, including the default gateway and DNS server settings.
This gives the attacker the ability to perform a man-in-the-middle attack, because she can have the default gateway set to her own system, causing all traffic to flow through her system.

You can use a layer 2 switch feature called *DHCP snooping* to mitigate rogue DHCP servers.
With DHCP snooping, you can categorize a port as either a *trusted port* or an *untrusted port*. You configure the port that your DHCP server is connected to as a trusted port, indicating that the port is under your control and is authorized to generate DHCP server messages.
You then configure all other ports as untrusted ports, because the DHCP server is not connected to them. Then, if someone connectes a rogue DHCP serer to one of the untrusted ports, the switch will drop the DHCP server (related messages such as DHCPOFFER, DHCPACK, and DHCPNACK, protecting the network from the rogue DHCP server).

#### Configuring DHCP Snooping

The DHCP snooping feature is disabled by default and must be enabled globally and then enabled for each VLAN on the switch.

For example, the following commands enable DHCP snooping on the switch and then for VLAN 1:

```
Switch>enable
Switch#config term
Switch(config)#ip dhcp snooping
Switch(config)#ip dhcp snooping vlan 1
```

Keep in mind that these two commands should be the last commands you run. The reason these should be the last two commands is because now DHCP snooping has been enabled, but we did not specify any trusted ports, which means that your real DHCP server on the network is currently not allowed to give addresses out to clients until you configure it in a trusted port.

To enable your DHCP server to give addresses out on the network, you configure the switch interface that the DHCP server is connected to as a trusted port by navigating to the interface and using the `ip dhcp snooping trust` command

```
Switch(config)#interface g/1/0/2
Switch(config-if)#ip dhcp snooping trust
```

#### DHCP Snooping Binding Database

As the switch is intercepting DHCP messages, it is building up the *DHCP snooping binding database*, which is a listing of the untrusted hosts (hosts connected to untrusted ports) that have received IP addresses from the DHCP server.

The DHCP snooping binding database contains an entry for each untrusted interface that has a system connected with details such as the interface ID, the MAC address of the client, the IP address of the system connected to that port, and the VLAN the interface is a port of.
If you want to view the DHCP snooping binding database, you can use the `show ip dhcp snooping binding` command.

The DHCP snooping binding database is maintaned by the switch, so as DHCPACK messages are seen by the switch, it adds the entry to the database, and as DHCPRELEASE messages are seen, it removes the entries from database.

### Dynamic ARP Inspection

When a device talks to another device on the network, it must first learn the MAC address of that device so that it can send data to that device.
Devices use ARP to learn MAC addresses of devices on the network by broadcasting an ARP request message out saying "Whoever has this IP address, I need to know your MAC address." The broadcast is seen by all systems but ignored by all except the one system that has that specific MAC address. That system sends an ARP reply, which says something to the effect of, "That is my IP address, and there is my MAC address." This is the important part from a security point of view:when a device receives the ARP reply, it stores that information in an area of memory known as the ARP cache, which is a listing of IP addresses and corresponding MAC addresses.
The important thing to note here is that devices on the network will trust any information in the ARP cache by default.

Attackers have learned to perform APR poisoning attacks, which enable them to put incorrect information in the ARP cache unknowlingly that your system will trust.
For example, if the attacker wants to perform a man-in-the-middle attack, he could poison your ARP cache by specifing that his MAC address corresponds to the IP address of the default gateway. Then, when you surfed the Internet, all traffic would be sent to the attacker's system, where he could capture the traffic and then forward it to the real default gateway.

To improve security and help preent ARP posisoning attacks (and man-in-the-middle attacks), Cisco swtches include the *Dynamic ARP inspection (DAI)* feature.
If you enable the DAI feature on the switch, the switch will intercept all ARP messages and then compare the information in the ARP message with the data stored in the DHCP snooping binding database (which has a list of IP addresses and MAC addresses).
For example, after you enable DAI, if an attacker sends out an ARP poision message that says he is using the IP address of the default gateway and gives the MAC address of his system, the switch will look up that IP address in the DHCP snooping binding database and verify that it is the correct MAC address to go with that IP address. If it is not, the packet is dropped, which means that the attacker would not be successful in poisoning the ARP cache.

Keep in mind that DAI performs checks only on untrusted ports, because it uses the DHCP snooping binding database, which stored information only on untrusted ports. Also like DHCP snooping, DAI is configured on a per-VLAN basis.

To configure dynamic ARP inspection on the switch for VLAN  1:

```
Switch>enable
Switch#config term
Switch(config)#ip arp inspection vlan 1
```

If you have a number of switches connected together, you would configure the connected ports of the switchs (trunk ports) as trusted ports so that your switches do not verify the ARP messages comming from those ports.

For example, if port 24 on switch is connected to another switch:

```
Switch(config)#interface g1/0/24
Switch(config-if)#ip arp inspection trust
```

---

## Implementing Access Control Lists

By default, once you set up routing, your router will enable any packet to flow from one interface to another.
You may want to implement policies to restrict the flow of traffic, for security or traffic policy reasons.

Cisco enables you to control the flow of traffic from one interface to another by using access control lists (ACLs). ACLs, are a powerful feature of Cisco IOS. Cisco actually supports ACLs for protocols other than IP, including Internetwork Packet Exchange (IPX), AppleTalk, layer 2 traffic, and others.

### ACL Overview

ACLs, known for their ability to filter traffic as it either enters or leaves an interface, can also be used for other purposes, including restricting remote access (VTY) to an IOS device, filtering routing information, priorizing traffic with queing, triggering phone calls with dial-on-demand routing (DDR), changing the administrative distance of router, and specifying traffic to be protected by an IPsec VPN, among many other purposes.

#### Definition

ACLs are basically a set of commands, grouped together by a number of name, which are used to filter traffic entering or leaving an interface. ACL commmands define specifially which traffic is permitted and which is denied.
ACLs are created in Global Configuration mode.

Once you create your group of ACL statements, you must activate them. For filtering traffic between interfaces, the ACL is activated in Interface Subconfiguration mode.
This can be physical interface, such as ehternet0, or a logical interface, such as ehternet0.1.
When activating an ACL on an interface, you must specify in which direction the traffic should be filtered:

* **Inbound**
	* As the traffic comes into an interface from an external soucre, IOS compares the packet to the interface ACL before IOS forwards the packet to another interface.
* **Outbound**
	* The packet is received on an interface and forward to the exit interface; before the traffic exits an interface to the network, IOS compares the packet to the ACL.

One restriction that ACLs have is that they cannot filter traffic that the router itself originates.
For example, if you execute a ping or traceroute from the router, or if you telnet from the router to another device, ACLs applied to the router's interfaces cannot filter these connections outbound.
However, if an external device tries to ping, traceroute, or telent *to* the router or *through* the router to a remote destination, the router can filter these packets.

#### Types

ACLs come in two varienties: *numbered* and *named*.
Numbered and named ACLs define how the router will reference the ACL. You can think of this as being similar to an index value.

A numbered ACL is assigned a unique number among all ACLs, whereas a named ACL is assigned a unique name among all named ACLs.
These are then used by the router to filter traffic.

Each of these references to ACLs supports two types of filtering: *standard* and *extended*.
Standard IP ACLs can filter only on the source IP address inside a packet, whereas extended IP ACLs can filter on the source and destingation IP addresses in the packet, the IP protocol (TCP, UDP, ICMP, ans so on), and protocol information (such as the TCP or UDP source and destination port numbers or ICMP message types).

With an extended ACL, you can be very precise in your filtering.
For example, you can filter a specific telent session from a user's PCs to a remote telnet server.
Standard ACLs do not suport this form of granularity. With a standard ACL, you can either permit or deny all traffic from a specific source device.

| Filtered Info                      | Standard ACL | Extended ACL |
| ---------------------------------- | ------------ | ------------ |
| Source addr                        | Yes          | Yes          |
| Dest addr                          | No           | Yes          |
| Ip protocol(IP, TCP, or UDP)       | No           | Yes          |
| Protocol Information (port number) | No           | Yes          |

The two types of ACLs can be statically defined on the IOS device or dynamically downloaded via an authentication server.
Dynamic ACLs are typically used when a user authenticates to the network, such as via a switch port using IEEE 802.1X; once a user is successfully authenticated, the switch downloads an ACL from an authentication server and applies it to the user's switch port. The ACL is then used to filter the traffic.
Once the user leaves the network, the dynamic ACL is removed from the switch port.

### ACL Processing

ACLs are basically statements that are grouped together by either a name or a number. Within this group of statements, when a packet is processed by an ACL, IOS will go through certain steps in finding a match against the ACL statements.

ACLs are processed *top-down* by IOS. A packet is compared to the first statement in the ACL, and if IOS finds a match between the packet and the statement, IOS will execute one of two actions included with the statement: *permit* or *deny*.

If IOS doesn't find a match of packet contents to the first ACL statement, IOS will proceed to the next statement in the list, again going through the same matching process. If the second statement matches the packet contents, IOS execues one of the two actions.
If there is no match on this statement, IOS will keep going through the list until it finds a match. If IOS goes through the entire list and dosen't find a match in the ACL statements to the ACL contents, the router will *drop* the packet.

The top-down processing of ACLs brings out the following very importanta points:

* Once a match is found, no further statements are processed in the list.
* The order of statements is important, since after the first match, the rest of the statements are not processed.
* If no match is found in the list, the packet is dropped.

#### Statement Ordering

If a match is found on a statement, no further statements are processed.
Threfore, the order of the statements is *very* important in an ACL. If you have two statements, one denying a host and one permitting the same host, whitchever one appears *first* in the list will be executed and the second one will be ignored.

Because order of statements is important, you should alsways place the most specific ACL statements at the top of the list and the least specific at the bottom of the list.

You have an ACL on your router with two statements in this order:

1. Permit traffic from subnet 172.15.0.0/16
2. Deny traffic from host 172.16.1.1/32

Remeber that the router processes these statements from the *top down*. Let's assume that a packet is received on the router with a source IP address of 172.16.1.1 Given the proceding ACL, the router compares the packet contents with the first statement.
Does the packet have a source address from network 172.16.0.0/16? Yes. Therfore, the result indicates that the router sould permit the packet. Notice that the second statement is never processed once the router finds a match on a statement.
in this example, any traffic from the 172.16.0.0/16 subnet is permitted, even traffic from 172.16.1.1.

Let's reverse the order of the two statements in the ACL and see how this reordered ACL will affect traffic flow:

1. Deny traffic from host 172.16.1.1
2. Permit traffic from subnet 172.16.0.0/16.

If 172.16.1.1 sends traffic through the router, IOS first compares these packets with the first ACL statement.
Since the source address matches 172.16.1.1, the router drops the packet and stops processing statements in the ACL. In this example, it doesn't matter what traffic 172.16.1.1 is sending, because it's dropped. If another device, say 172.16.1.2, sends traffic through the router, the router compares the packet contents to the first ACL statement. the router proceeds to the next statement in the list. Comparing the packet contents to the statement, there is a match. Therfore, the router will execute the result, permitting the traffic from 172.16.1.2.

#### Implicit Deny

Another importanat aspect of the top-down process is that if the router compares a packet to every statement in the list and does not find a match against the packet contents, the router will *drop* the packet. This process is referred to as *implicit deny*.

At the end of every ACL is an invisible statement that drops all traffic that doesn't match any of the proceding statements in the ACL.
Given this process, it makes no sense to have a list of only deny statements, since the implicit deny drops all traffic anyway. Therefore, every ACL should have at lease one *permit* statement; otherwise, an ACL with only deny statements will drop all the traffic, given the deny statements are hidden implicit deny statement.

#### Important Configuraiton Guidelines

Configuring an ACL is not a simple process. To get the configuration process right, you should be guided by the following list:

* Statement order is important. Put the most restrictive statements at the top of the list and the least restrictive at the bottom.
* ACL statements are processed top-down until a match is found, and then no more statements in the list are processed.
* If no match is found in the ACL, the packet is dropped (implicit deny).
* Each grouping of ACL statements needs either a unique number or a unique name.
* The router cannot filter traffic that it, itself, originates.
* Only one IP ACL can be applied to an interface in each direction (inbound or outbound) two or more ACLs cannot be applied inbound or outbound to the same interface. (Actually, one ACL for each protocol, such as IP and IPX, can be applied to an interface in each direction)
* Applying an empty ACL to an interface permits all traffic by default. In order for an ACL to have an implicit deny statement, you need at least one actual permit or deny statement in the ACL.

### Creating an ACL

To create a numbered ACL:

```
Router(config)# access-list ACL_# permit|deny conditions
```

Prior to IOS 11.2, you could give an ACL only a number as an identifer.
Starting with IOS 11.2, an ACL can be referenced by a number or name.

The purpose of the `ACL_#` is to group your statements together into a single list or policy. You cannot choose just any number for an ACL. Each Layer 3 protocol assigned its own range or ranges of numbers

**Valid numbers for IP ACLs**

| ACL Types   | Numbers            |
| ----------- | ------------------ |
| IP Standard | 1-99, 1300-1999    |
| IP Extended | 100-199, 2000-2699 |

Numbered ACLs give you a limited number of lists that you can create, which is based on the range of numbers assigned to a protocol type.
However, named ACLs do not have this restriction. Basically, the number of named ACLs on a router is restircted only be the amount of RAM and NVRAM your router has.

The `conditions` in an ACL statement tell the router what conditions in the packet need to match in order for the router to execute the action (`permit` or `deny`).
The conditions can include matching of IP addresses and protocol information.
When IOS compares a packet to the conditions, if it finds a match, no more ACL statements are processed; if it dosen't find a match, IOS proceeds to compare the packet to the next ACL statement in the list.

### Matching on Addresses: Wildcard Masks

When dealing with IP addresses in ACL statements, you can use *wildcard masks* to match on a range of addresses instead of manually entering every IP address that you want match on.

First, a wildcard mask is *not* a subnet mask.
Like an IP address or a subnet mask, a wildcard mask is composed of 32 bits.

**Subnet Mask Vs. Wildcard Mask**

| Bit value | Subnet Mask       | Wildcard Mask |
| --------- | ----------------- | ------------- |
| 0         | Host component    | Must match    |
| 1         | Network component | Ignore        |

With a wildcard mask, a 0 in a bit position means that the corresponding bit position in the address of the ACL statement *must* match the same bit position in the IP address in the examined packet.
A *1* in a bit position means that the corresponding bit position in the address of the ACL statement does *not* have to match the bit position in the IP address in the examined packet.
In other words, the wildcard mask and the address in the ACL statement work in tandem.

The wildcard mask tells the router which addressing bits in the address of the ACL statement must match the bits in the packet to which is being compared.

In reality, a wildcard mask is more like an *inverted* subnet mask.
For instance, if you wnat to match on any address in a subnet or network, you can simply take the subnet mask, invert its bit values, and you have a corresponding wildcard mask.

Assume that you have a subnet mask of 255.255.0.0. Its binary representaion is 11111111.11111111.00000000.00000000. When you convert this to a wildcard mask, invert the bits: 00000000.00000000.11111111.11111111. Then convert this to decimal: 0.0.255.255. This is the corresponding wildcard mask for the subnet mask of 255.255.0.0.
In this example, the wildcard mask tells the router that the first 16 bits in the IP address of the examined packet for the router to continue processing the statement; otherwise, the router will proceed to the next ACL statene.

Another example, assume you want to match on a subnet that has a subnet mask of 255.255.240.0.

|         | Subnet Mask                         | Wildcard Mask                       |
| ------- | ----------------------------------- | ----------------------------------- |
| Binary  | 11111111.11111111.11110000.00000000 | 00000000.00000000.00001111.11111111 |
| Decimal | 255.255.240.0                       | 0.0.15.255                          |

#### Special Wildcard Masks

Two special types of wildcard masks exits: *0.0.0.0* and *255.255.255.255*.

A wildcard mask of 0.0.0.0 tells IOS that all 32 bits of the address in the ACL statement must match those found in the IP packet in order IOS to execute the action for the statement.
A 0.0.0.0 wildcard mask is called a *host mask*.

192.168.1.1 0.0.0.0. This statement tells IOS to look for the exact same IP address (192.168.1.1) in the IP packet. If IOS dosen't find a match, IOS will go to the next ACL statement.
If you configure 192.168.1.1 0.0.0.0, the IOS will convert this to the following syntax: *host 192.168.1.1* (note the keyword *host* that precedes the IP address).

A wildcard mask of 255.255.255.255 tells the router the exact opposite of a 0.0.0.0 mask.
In this mask, all of the bit values are 1s, which tells IOS that it doesn't matter what is in the packet that it is comparing to the ACL statement (*any* address will match).
Typically, you would record this as an IP address of 0.0.0.0 and a wildcard mask of 255.255.255.255, If you enter this, IOS will convert the address and amsk to the keyword *any*.

Actually, the IP address that you enter with this mask doesn't matter.
For instance, if you enter 192.168.1.1 255.255.255.255. This still matches any IP address.

#### Wildcard Mask Examples

| IP ADDR    | Wildcard Mask   | Matches                                                                |
| ---------- | --------------- | ---------------------------------------------------------------------- |
| 0.0.0.0    | 255.255.255.255 | ANY                                                                    |
| 172.16.1.1 | 0.0.0.0         | Match ONLY if the address is 172.16.1.1                                |
| 172.16.1.0 | 0.0.0.255       | Match only on packets are in 172.16.1.0/24 (172.16.1.0-172.16.1.255)   |
| 172.16.1.0 | 0.0.255.255     | Match only on packets are in 172.16.0.0/16 (172.16.0.0-172.16.255.255) |

### Activating an ACL

Once you have built your IP ACL, it will do noting until you apply it to a process in IOS.

To have IOS filter traffic between interfaces, you must enter the appropriate interface or interfaces and activate your ACL.

```
Router(config)# interface TYPE [SLOT_#/]PORT_#
Router(config-if)# ip access-group ACL_# in|out
```

At then end of the `ip access-group` command, you must specify which ACL you are activating an in which direction:

* In
	* As traffic comes into the interface
* Out
	* As traffic leaves the interface

Note taht you can apply the same ACL to multiple interfaces on a router, or you can activate the same ACL twice on the same interface: inbound and outbound.
You can also apply a nonexist ACL to an interface. A **nonexistence** ACL is an ACL to have an implicit deny, it needs at least one *permit* or *deny* statement.
It is highly recommended that you do *not* apply nonexistent ACLs to a router's interface.
In this situcation, when you create the very first statement in the list, the implicit deny is automatically placed at the bottom, which might create reachability issues for your router.

Assume that you have applied an ACL (#10) to a router's ethernet0 interface and this ACL currently dosen't have any *permit* or *deny* statements. You are connected to the router via telnet on this interface, and your PC has an IP address of 192.168.1.1. You create an entry in ACL#10 that permits traffic from 172.16.0.0/16. As soon as you do this, you lose your telnet connection.
As soon as the router has one statement in it, the implicit deny is added at the bottom. In this example, since your PC had a source address of 192.168.1.1, and this wasn't included in the first statement, the router dropped your connection because it couldn't find any matching statements in ACL #10

### Standard Numbered ACLs

Standard IP ACLs are simple and easy to configure.

First, standard IP ACLs filter on only the *source IP address* in an IP packet.

```
### create an entry in a standard numbered IP ACL
Router(config)# access-list {1-99 | 1300-1999} {permit | deny} SOURCE_IP_ADDR [wildcard_mask] {log}
```

With a standard numbered IP ACL, you can use list numbers of 1-99 and 1300-1999.
Following this is the action the router should take if there is a match on the condition.
The condition is based solely on the source IP address. You follow up the source IP address parameter with an optional wildcard mask. If you omit the mask, it defaults to 0.0.0.0 (an exact match).

Next is the optional *log* parameter, which was introduced to standard ACLs in IOS 12.0.
This parameter will cause any match of this statement to be printed to the console port of the router. These messages, by default, will not appear on a *non-console* condition, such as a VTY or TTY, to the IOS device unless you execute the following:

```
Router# terminal monitor
```

> The `terminal monitor` command is good only for your current session: when you log out and then log back into the IOS device, you'll need to re-execute the command to see logging output on your VTY or TTY session.

You can also forward these ACL logging messages to a syslog server.
This setup is useful for debugging and security purposes. Once you have created your ACL, you can proceed to activate it on interface with the `ip access-group ACL_# in|out` command.

#### Standard IP ACL Examples

```
Router(config)# access-list 1 permit 192.168.1.1
Router(config)# access-list 1 deny 192.168.1.2
Router(config)# access-list 1 permit 192.168.1.0 0.0.0.255
Router(config)# access-list 1 deny any
Router(config)# interface serial 0
Router(config-if)# ip access-group 1 in
```

In this example, the first ACL statement in ACL#1 says that in order to execute the `permit` action, the IP packet must have a source address of 192.168.1.1. If it dosen't, IOS proceedes to the second statements.
Remeber that if you omit the wildcard mask on a standard ACL, it defaults to 0.0.0.0 (exact match of the corresponding address in the ACL statement).
The second ACL statements says that in order to execute the `deny` action, the IP packet must have a source address of 192.168.1.2; if it dosen't, IOS proceeds to the third statement.
The third ACL statement says that in order to execute the `permit` action, the IP packet must have a source address between 192.168.1.0 and 192.168.1.255.
The fourth statement is actually not necessary: it drops any packet. You don't need this statement since an invisible implicit `deny any` statement occurs at the end end of every ACL.

The last two commands in the ACL example activate ACL#1 on serial 0 as traffic comes into the interface.

You could have written the preceding ACL like this:
```
Router(config)# access-list 1 deny 192.168.1.2
Router(config)# access-list 1 permit 192.168.1.0 0.0.0.255
Router(config)# interface serial 0
Router(config-if)# ip access-group 1 in
```

Another example of standard ACL:

```
Router(config)# access-list 2 deny 192.168.1.0
Router(config)# access-list 2 deny 172.16.0.0
Router(config)# access-list 2 permit 192.168.1.1
Router(config)# access-list 2 permit 0.0.0.0 255.255.255.255
Router(config)# interface ehternet 0
Router(config-if)# ip access-group 2 out
```

The first ACL statement appears to deny all traffic from 192.168.1.0/24.
In reality, it will accomplish nothing. Remeber that if you omit the wildcard mask for the address, it defaults to 0.0.0.0. The problem is that you'll never have a packet with a source address of 192.168.1.0, since this is a network number, and not a host address.

The second statement has the same problem. The third and fourth statements are okay.

Updated configuration:
```
Router(config)# access-list 2 deny 192.168.1.0 0.0.0.255
Router(config)# access-list 2 deny 172.16.0.0 0.0.255.255
Router(config)# access-list 2 permit 192.168.1.1
Router(config)# access-list 2 permit 0.0.0.0 255.255.255.255
Router(config)# interface ethernet 0
Router(config)# ip access-group 1 out
```

In this example, the first statement now says that any packet with a source address from network 192.168.1.0/24 should be dropped.
The second statement will drop any traffic from the Class B network 172.16.0.0/16.
The third statement wil permit traffic from 192.168.1.1.
The fourth statement will permit traffic from anywhere.

There is still a problem with this configuration.
In this situation, you need to put more specific entry before the less specific one (thrid statement never will executed).

Updated configuration:
```
Router(config)# access-list 2 permit 192.168.1.1
Router(config)# access-list 2 deny 192.168.1.0 0.0.0.255
Router(config)# access-list 2 deny 172.16.0.0 0.0.255.255
Router(config)# access-list 2 permit any
Router(config)# interface ethernet 0
Router(config)# ip access-group 1 out
```

Note that you must first remove the old ACL from the interface before applying the new ACL.

#### Restricting VTY Access to the router

You can also use ACL to restrict VTY access (telnet and SSH) to your router.
You may want to do this to allow only network administrators to access the CLI of your IOS device remotely.

Setting this up is almost the same as setting up restricted access on an interface.

First, you need to create a standard ACL that has a list of *permit* statement that allow your corresponding network administrators remote access; include IP address of their PCs in this list.
Next, you need to activate your ACL.

However, you will not do this on any of the router's interfaces. If you were to activate this ACL on an interface, it would allow any type of traffic from your administrators but drop *all* other traffic.

Remember that when someone accesses your router via telnet or SSH, the router associates this connection with a VTY line. Therefore, you'll apply your standard ACL to the VTYs

```
Router(config)# line vty 0 4
Router(config-line)# access-class STANDARD_ACL_# in|out
```

Remeber that your router supports five telnets by default (0-4), and more on certain IOS devices.
You can configure all VTYs simultaneously by specifying the beginning and ending line numbers after the *vty* parameter.

If you don't apply the restriction to all of your VTYs, you are leaving a back-door into your router, which may cause a security problem.

Also notice the command used to apply the ACL to the line: `access-class`.
This is different from activating an ACL on a router's interface. If you use the *in* parameter, you are restricting telnet and SSH access to the router itself. The *out* parameter is kind of unique. By using this parameter, you are restricting what destination this router can telnet or SSH to when someone uses `telnet`, `connect`, or `ssh` command.
This creates an exception to a standard ACL and has the router treat the address in the ACL statements as a destination address; it causes the router to compare this address to the address in the `telnet` command before allowing the user on the router to telnet to the specified destination.

```
# using a standard ACL to filter telnet traffic to a router
Router(config)# access-list 99 permit 192.168.1.0 0.0.0.255
Router(config)# line vty 0 4
Router(config-line)# access-class 99 in
```

In this example, only traffic from 192.168.1.0/24 is allowed to telnet or SSH into this router.
Because of the implicit deny at then end of `access-list 99`, all other connections to this router (via the VTYs) will be dropped.

You can also use extended ACLs to restrict access to the IOS device, but this configuraiton is much more complex.
Second, extended ACLs are applied to interfaces and thus won't be able to restrict telnet access *from* the router to a remote destination.
And thrid, whenever you apply an ACL to an interface on the router, you'll affect the performance of the router on that interface.
Depending on the router model, the IOS version, and the features you have enabled, the degradation in performance will vary.

Therfore, if you only want to restrict telnet or SSH access to or from the router, using a standard ACL and the `access-class` statement on yoru VTYs is the best approach.

### Excercise 17-5: Configuring Standard Numbered ACLs

* Create two standard access lists on the VAN-R1 router.
* First ACL will block all traffic from the 14.0.0.0 network except traffic from one IP address
* Second ACL will be used to limit from which remote workstation the administrator is allowed to administer the router

```
VAN-R1>enable
VAN-R1#config term

### VTY restrict
VAN-R1(config)#access-list 1 permit 12.0.0.0 0.255.255.255.255
VAN-R1(config)#line vty 0 15
VAN-R1(config-line)#access-class 1 in
VAN-R1(config-line)#exit

### permits only 14.0.0.5 and 14.0.0.1
VAN-R1(config)#access-list 2 permit 14.0.0.5 0.0.0.0
VAN-R1(config)#access-list 2 permit 14.0.0.1 0.0.0.0
VAN-R1(config)#interface g0/0
VAN-R1(config-if)#ip access-group 2 out
VAN-R1(config-if)#exit
```

### Extended Numbered ACLs

Extended IP ACLs are much more flexible in what you can match on than standard ACLs.

Extended ACLs can match on all of the following information:

* Source and destination IP address
* TCP/IP protocol (IP, TCP, UDP, ICMP, and so on)
* Protocol information, such as port numbers for TCP and UDP, or message types for ICMP

#### Command Syntax

```
Router(config)# access-list {100-199 | 2000-2699} {permit | deny}
					IP_protocol
					source_addr source_wildcard_mask
						[protocol_information]
					destination_addr destination_wildcard_mask
						[protocol_information] [log]
```

The configuration of an extended ACL is more complicated than that of a standard one.
Extended IP numbered ACLs can use list numbers in the ranges 100-199 and 2000-2699.
After the action (permit or deny) comes the IP protocol that you wnat to match on. This is the first major difference between an extended ACL and a standard one.
These IP protocols inlclude: `ip, icmp, tcp, gre, udp, igrp, eigrp, igmp, ipinip, nos, and ospf`. If you wnat to match on any IP protocol, use the `ip` keyword for the protocol.
If Cisco doesn't have a name for the IP protocol you want to specify, use the number of the protocol instead, such as 6 for TCP.

The second major differences is that you must specify both the source and destination address and their respective wildcard masks.
With a standard ACL, you can specify only the source address, and the wildcard mask is optional. Depending on the IP protocol, you may be able to add protocol information for the source and/or destination.
For example, TCP and UDP enable you to specify both source and destiantion port numbers, and iCMP enables you to specify ICMP message types.
As with standard ACLs, you can log messages to the console or syslogserver with the *log* parameter.

Once you have created your extended numbered IP ACL, you must activate it on your router's interface with the `ip access-group` command.

Note, that this is the same configuration used with a standard ACL. Once you activate the ACL, the router will begin filtering traffic on the interface.

#### TCP and UDP

```
# Configure an extended ACL for TCP or UDP:
Router(config)# access-list {100-199 | 2000-2699} {permit | deny}
					{tcp | udp} SOURCE_ADDR SOURCE_WILDCARD_MASK
					{operator source port_#}
					DEST_ADDR DEST_WILDCARD_MASK
					{operator dest_port_#}
					[established] [log] 
```

After specifying the action (permit or deny), you configure the IP protocol: tcp or udp.

##### Operators

With TCP and UDP, you can specify the source, destination, or both source and destination port numbers or names.
To specify how to perform the match, you must configure an operator.

The operator tells the router how to match on the port number(s) or names.

**Vaild operators for TCP and UDP ACL entries**

| Operator | Description           |
| -------- | --------------------- |
| lt       | Less than             |
| gt       | Greater than          |
| neq      | Not equal to          |
| eq       | Equal to              |
| range    | Range of port numbers |

##### Ports Numbers and Names

For TCP and UDP connections, you can list either the name or the number of the port.
For example, if you wanted to match on telnet traffic, you could use either the keyword `telnet` or the number 23.

**Common port names and numbers for TCP connections**

| Port Name   | Command Parameter | Port Number |
| ----------- | ----------------- | ----------- |
| FTP Data    | ftp-data          | 20          |
| FTP Control | ftp               | 21          |
| Telnet      | telnet            | 23          |
| SMTP        | smtp              | 25          |
| WWW         | www               | 80          |
| POP3        | pop3              | 110         |

##### Common UDP port names and numbers

| Port Name | Command Parameter | Port Number |
| --------- | ----------------- | ----------- |
| DNS Query | dns               | 53          |
| TFTP      | tftp              | 69          |
| SNMP      | snmp              | 161         |
| IP RIP    | rip               | 520         |

> One common problem that occurs when setting up an ACL is that the administrator specifies the wrong protocol for the application, such as TCP for TFTP, RIP or DNS queries, instead of UDP. This is also true of the port number or names.

##### The established keyword

The `established` keyword is used only for TCP connections.

The assumption behind the use of this keyword is that you are originating TCP traffic on the inside of the network and filtering the returning traffic as it comes back into your network.
In this situation, this keyword allows (or denies) any TCP traffic that has a certain flag or flag bits set in the TCP segment header, indicating that this is returing traffic back into your network.

#### ICMP

```
# Configure an extended ACL for ICMP:
Router(config)# access-list {100-199 | 2000-2699} {permit | deny} icmp
					SOURCE_ADDR SOURCE_WILDCARD_MASK
					DEST_ADDR DEST_WILDCARD_MASK
					[icmp_message] [log] 
```

Unlike TCP and UDP, ICMP doesn't use ports. Instead, ICMP uses message types. And where TCP and UDP extended ACLs enable you to specify both source and destination ports, ICMP enables you to enter an ICMP message.

**Common ICMP messages and brief descriptions**

| Message Type                | DESC                                                |
| --------------------------- | --------------------------------------------------- |
| administratively-prohibited | Indicates the packet was filtered                   |
| echo                        | Used by ping to check a destnination                |
| echo-reply                  | Response to an echo message created by ping         |
| host-unreachable            | Subnet is reachable, but the host is not responding |
| net-unreachable             | Network/subnet is not reachable                     |
| traceroute                  | Filters on traceroute information when ICMP is used |

> If you execute the `no access-list` command, followed by the ACL number, the entire ACL and its referenced commands are deleted.
> What most administrator don't realize, or forget, is that if you preface any numbered ACL statement with the `no` parameter, it has exactly the same effect: the entire ACL is deleted.
> For example, executing the `no access-list 100 permit tcp any any` command causes the router basically to ignore everyting after the 100 parameter, causing the router to execute the command as if it were `no access-list 100`

#### Extended IP ACL Example

```
### TCP permit
Router(config)# access-list 100 permit tcp 
					any 172.16.0.0 0.0.255.255
					established log

### UDP permit (DNS server)
# DNS is using UDP
# DNS server ip is 172.16.1.1
Router(config)# access-list 100 permit udp
					any host 172.16.1.1 eq dns log

### TCP permit (telnet)
# telnet is using TCP connections, so permit to TCP
Router(config)# access-list 100 permit tcp
					172.17.0.0. 0.0.255.255
					host 172.16.1.2 eq telnet log

### ICMP message permit
# only echo-reply is permiteed, echo is deny
Router(config)# access-list 100 permit icmp
					any 172.16.0.0 0.0.255.255
					echo-reply log

### logging for dropped packets
Router(config)# access-list 100 deny ip any any log

Router(config)# interface G0/0
Router(config-if)# ip access-group 100 in
```

The assumption behind this example is that it is restricting what traffic can come into a network.

The first statement says that if any TCP session has any source address and is destined to 172.16.0.0/16, it will be permitted if contain TCP flag bits are set (established) in the TCP segement header, indicative of returning traffic.
Remeber that the keyword any is the same as 0.0.0.0 255.255.255.255, Also the *log* keyword will cause a match on this statement to be printed on the console.
Since TCP port isn't specified, all TCP connections will match on this statement.

The second line of this example, allows a DNS query from any source device to be sent to an internal DNS server (172.16.1.1).
Remeber that the 0.0.0.0 wildcard mask is removed and the keyword *host* is inserted in the front of the IP address.
A match on this statement is also logged.

The third line allows any telnet connection from devices in the 172.17.0.0/16 network if the destination device is 172.16.1.2.
Remeber telent uses TCP.
A match on this statement is also logged.

The fourth line allows any replies to a ping to come back to devices with an address of 172.16.0.0/16.
Note that only the echo replies are allowed echos not allowed, preventing someone from this interface from executing pings.
A match on this statement is also logged.

The fifth line isn't necessary because all traffic not matching on the previous *permit* statement will be dropped. However, if you want what is dropped, you'll need to configure this statement with the *log* parameter.

The last part of the configuration shows the ACL applied inbound on ethernet0.

### Named ACLs

Starting with IOS 11.2, Cisco routers support both numbered and named ACLs.
One of the original limitations of numbered ACLs was that you could create only so many of them.
Originally, you could have only 99 standard IP ACLs and 100 extended IP ACLs.

Unlike in numbered ACLs, in named ACLs you can delete a single entry in the ACL without deleting the entire ACL. No need to worry about when the named ACLs came into ply, just know that it was a welcome feature because it meat we were not limited by numeric values.

#### Creating Named ACLs

```
Router(config)# ip access-list {standard | extended} ACL_NAME
```

The first thing you must specify is the type of ACL: standard or extended.
Second, you must give the ACL a name that groups the ACL statements together. This name must be unique among all named ACLs.

After you enter this command, you are taken into the appropriate ACL subconfiguration mode:

```
Router(config-std-acl)#

OR

Router(config-ext-acl)#
```

Once you are in Subconfiguration mode, you can enter your ACL commands.

```
#### Standard named ACL
Router(config)# ip access-list standard ACL_NAME
Router(config-std-acl)# permit|deny SOURCE_IP_ADDR [wildcard_mask]

#### Extended named ACL
Router(config)# ip access-list extended ACL_NAME
Router(config-ext-acl)# permit|deny IP_PROTOCOL
						SOURCE_IP_ADDR WILDCARD_MASK
							[PROTOCOL_INFORMATION]
						DEST_IP_ADDR WILDCARD_MASK
							[PROTOCOL_INFORMATION] [log]
```

Creating a standard or extended named IP ACL is similar to creating a numbered one.
Once you have created your extended numbered IP ACL, you must activate it on your IOS device's interface with the `ip access-group` command, referencing a name instead of a number.

#### Example of a Named Access List

```
### create named extended acl & entering subconfiguration mode
Router(config)# ip access-list extended do_not_enter

### TCP permit
Router(config-ext-acl)# permit tcp any 172.16.0.0 0.0.255.255 established log

### UDP permit (DNS server)
Router(config-ext-acl)# permit udp any host 172.16.1.1 eq dns log

### telnet permit
Router(config-ext-acl)# permit tcp 172.17.0.0 0.0.255.255 host 176.16.1.2 eq telent log

### ICMP message permit
Router(config-ext-acl)# permit icmp any 176.16.0.0 0.0.255.255 echo-reply log

### dropped packet logging
Router(config-ext-acl)# deny iip any any log

### apply ACL to G0/0 interface
Router(config)# interface G0/0
Router(config-if)# ip access-group do_not_enter in
```

### ACL Remarks

Starting in IOS 12.0(2)T, you can embed remarks or comments within your ACL statements.
Remarks work with named or numbered ACLs.

```
Router(config)# access-list ACL_# remark REMARK

or 

Router(config)# ip access-list standard|extended ACL_NAME
Router(config-{stc|ext}-acl)# remark REMARK
```

The remark can be up to 100 characters in length.

### Access List Verification

Once you have created and activated your ACLs, you can verify their configuration and operation with various *show* commands.
One common command that you can use is the Privildege EXEC `show running-config` command, which will display your ACL and the interface or interfaces on which it is activated.
However, you can use many other commands as well.

If you simply want to see which ACLs are activated on your router's interface, you can use the `show ip interfaces` command

```
Router# show ip interfaces
GigabitEhternet0/0 is up, line protocol is up
  Internet address is 172.16.1.1/24
  ....
  Outgoing access list is not set
  Inbound  access list is 100
  ....
```

To view the statements in your ACLs, use either of the following two commands:

```
Router# show access_lists [ACL_# or ACL_NAME]
Router# show ip access-list [ACL_# or ACL_NAME]
```

```
Router# show access-lists
Extended IP access list 100
  permit tcp 172.16.0.0 0.0.255.255 any established
      (189 matches)
....
```

You can clear these counters with `clear access-list counters [ACL_# or ACL_NAME]` command.

Also notice that using the `show access-lists` command displays all ACLs from all protocols on your router.
If you want to view only a particular ACL:

```
Router# show access-lists 100
Router# show ip access-lists 100
```

### ACL Changes

Prior to the addition of the sequenced ACL feature, you basically had to make ACL changes in an external text editor, delete the old ACL on the router, and paste in the new commands.
However, starting in IOS 12.3, you can edit ACLs on your IOS device on-the-fly with the *sequenced ACL* feature.
Sequenced ACLs enable you to insert and delete statements and remarks in an existing ACL.

With sequenced ACLs, each ACL command is given a unique sequence number. By default, the sequence numbers start at 10 and increment by 10.

```
Router# show access-lists
Extended IP access list 101
  10 permit ip host 192.168.101.69 any
  20 permit ip host 192.168.101.89 any
```

ACL 101 is using sequenced ACLs. The sequence numbers are added when the router boots up and loads the ACL or when you add or change the ACL from the CLI or Cisco Configuration Professional (CP).
Whenever you save the IOS's configuration to NVRAM, the sequence numbers are not stored with the ACL statements: Cisco implemented this feature for backward compatibility with older IOS versions that do not support sequenced ACLs.

Sequenced ACLs work with both named and numbered ACLs; however, to edit a numbered ACL, you must treat it as through it were a named ACL.
Once you enter the ACL subconfiguration mode, you can delete an entry by prefacing the sequence number with `no` command.

```
Router(config)# ip acess-list {standard|extended} ACL_NAME_OR_#
Router(config-{std|ext}-nacl)# no SEQUENCE_#
```

To instert a statement in an ACL, enter the ACL subconfiguration mode and preface the ACL statement with a sequence number that dose not currently exist in the list of statements.

```
Router(config)# ip acess-list {standard|extended} ACL_NAME_OR_#
Router(config-{std|ext}-nacl)# SEQUENCE_# {permit | deny}
							    ACL_CONDITION
```

Since sequence numbers increment by 10, if you need to insert more than nine statements in the same place in your ACL, you'll first need to resequence the entries in the list:

```
Router(config)# ip access-list resequence ACL_NAME_OR_#
					STARTING_SEQ_# increment
					
### the inital sequence number is 100, and the increment is 100:
Router(config)# ip access-list resequence 101 100 100
Extended IP access list 101
  100 permit ip host 192.168.101.69 any
  200 permit ip host 192.168.101.89 any
```

---

## Understanding ACL Placement

First, don't go crazy with ACLs and create and dozens of them across all of your routers.
This makes testing and troubleshooting your filtering rules almost impossible.

The second point is that you will want to limit the nubmer of statements in your ACL.
An ACL with hundreads of statements is almost impossible to test and troubleshoot. It's not unusual to see an ACL have a lot of unnecessary and overlapping commands that have been carried over from years past.

As to where you should place your ACLs, the following two rules hold true in most situations:

* Standard ACLs should be placed as close to the destination devices as possible
* Extended ACLs should be placed as close to the source devices as possible.

### Standard ACLs

You want to place standard ACLs as close to the destination that you wnat to prevent the source from reaching, since they enable you to filter only on the source IP address in the packet headers.

If you put the standard ACL too close to the source, you could be preventing the source from accessing other valid services in your network.
By putting the standard ACL as close to the destination as possible, you are still enabling the source to access other resources, while restricting it from accessing the remote destination device or devices.

![[Pasted image 20250923023139.png]]

In this example, the user (192.168.5.1) shouold be prevented from accessing the server (192.168.1.1).

```
### ACL configuration
Router(config)# access-list 1 deny host 192.168.5.1
Router(config)# access-list 1 permit any
```

The goal is to prevent 192.168.5.1 from accessing the server at 192.168.1.1, and allow to everyone else to access the server.

Your first choice is to place this ACL on RouterC.
If you placed it here, 192.168.5.1 would not be able to reach 192.168.1.1, but the user wouldn't be able to access anything else either.

If you placed the ACL on RouterB, the user would be access the 192.168.4.0 network, but noting else.

You actually have two choices for placing the ACL on RouterA: interfaces E0 and E1.
If you placed it inbound on E1, the user wouldn't be able to access network 192.168.2.0. Therefore, you would have to place it outbound on E0 of Router!.

Note that there is still an issue with using standard ACLs. Any traffic from 192.168.5.1 is dropped as it attempts to leave this interface.
So the user is prevented from reaching not only the server but anything else on this segment.
Another issue with standard ACLs, since you typically place them as close to the destination as possible, is that they are not very network-friendly: packets travel almost all of the way to the destination and *then* they are dropped. This wastes bandwidth in your network, especially if the source is sending a lot of traffic to the destination.

### Extended ACLs

Given the preceding example, it would be much better to place the standard ACL as close the source as possible to prevent unwanted traffic from traversing almost the whole network before being dropped. With a standard ACL, though, you would be preventing the user from accessing most of the resources in the network.

Extended ACLs, however, don't have this limitation, since they can filter on *both* the source and estination addresses in the IP packet headers.
Given this ability, it is recommended that you place extended ACLs as *close* to the source as possible, thus preventing unwanted traffic from traversing your network.

```
### deny traffic from 192.168.5.1 to 192.168.1.1
Router(config)# access-list 100 deny ip host 192.168.5.1 host 192.168.1.1
Router(config)# access-list 100 permit ip any any
```

This configuraiton example is preventing only traffic from 192.168.5.1 to 192.168.1.1.
Now question is, where should you place this ACL? => you should place it on RouterC.
RouterC has two interfaces, though. In that case, placing the extended ACL as close to the source as possible means place it on E1 interface in the inbound direction.
If you were to place it on E0, and the router had another interface that it could use to reach the destination, the source still might be able to get around the filter.
If you place it on RouterC's E1 interface, 192.168.5.1 can access every location except 192.168.1.1.
Likewise, any other traffic is permitted to go anywhere in the network.

You can be more specific with your filtering in this example. For example, if you want to restrict just telnet access, but allow other types of access from 192.168.5.1 to 192.168.1.1, then you should specify the IP protocol (tcp) and the destination prot name or number (telnet or 23).